import json
import urllib.parse
import kaiten.error
from kaiten.processes.externalprintprocess import ExternalPrintProcess

class CloudSlicePrintProcess(ExternalPrintProcess):
    def __init__(self, *args, **kwargs):
        super(CloudSlicePrintProcess, self).__init__(*args, **kwargs)
        self._cloud_slice_print_steps = kaiten.enum.enum("cloud_slice_print_steps",
            "awaitingcloudslice")
        self._awaiting_slice = False
        self._awaiting_response = False
        self._error_response = False

    def _success_callback(self, response):
        try:
            self._check_response(response)
        except Exception:
            self._log.error("Bad cloudslicer response %r" % response, exc_info=True)
            self._error_response = True

    def _error_callback(self, **kwargs):
        self._log.error("Error during HTTP request {0}: {1}".format(self._url, kwargs))
        self._error_response = True
        self._stop_waiting()

    def _check_response(self, response):
        json_res = json.loads(response)
        self._progress = json_res.get('progress', 0)

        if json_res.get('failed', False):
            self._log.error("Cloudslice failed: %r" % response)
            self._error_response = True
        elif json_res.get('completed', False):
            # If our slice is completed then let's grab the resultant
            # .makerbot URL and get on with it
            sliced_url = json_res.get('result', None)
            self._log.debug('sliced url: {0}'.format(sliced_url))
            if not sliced_url:
                raise kaiten.error.ThingiverseException
            self._url = sliced_url
        else:  # Still pending
            self._awaiting_response = False
            return

        self._stop_waiting()

    def _await_slice(self):
        url = urllib.parse.urlparse(self._url)
        path = "{0}?{1}".format(url.path, url.query)
        while self._awaiting_slice and not self._error_response:
            # If we aren't waiting on a response, let's send out a request
            if not self._awaiting_response:
                # Hack to prop up broken http requests -- we are not correctly
                # closing our sockets when we get a successful response, and
                # a reference loop is keeping the python socket object alive
                # after being orphaned, and the default gc settings do not
                # always trigger a cleanup before we run out of sockets, so
                # we request a full gc cleanup here before every request.
                import gc
                gc.collect()

                self._request = self._machine_manager._server.http_request(
                    url.netloc,
                    path,
                    "GET",
                    params={},
                    https=(url.scheme == "https"),
                    token=None,
                    success_callback=self._success_callback,
                    error_callback=self._error_callback,
                    timeout=60,
                )
                self._awaiting_response = True
            yield

    def _stop_waiting(self):
        # Keep this idempotent since we have a number of callbacks that can
        # call this after we are done waiting -- maybe even after evicting
        # the contract...
        if self._awaiting_slice:
            self._contract_duration = self._original_contract_duration
            self._machine_manager._server.reschedule_contract_generator(self)
            self._awaiting_slice = False

    def _set_filepath(self):
        """
        Override implementation
        """
        if not self._machine_manager._server.is_online():
            self._log.error("Attempted cloud slice print while offline")
            yield kaiten.error.printing_network_error
        self._step_change(self._cloud_slice_print_steps.awaitingcloudslice)
        self._machine_manager._server.mixpanel_event("cloud_slice_print_started",
            self._client, url=self._url)

        # Wait till the slice is complete, using a slower contract duration only
        # while waiting for the slice to rate limit request generation.
        self._original_contract_duration = self._contract_duration
        self._set_contract_duration(5000)
        self._machine_manager._server.reschedule_contract_generator(self)
        self._awaiting_slice = True
        try:
            yield from self._await_slice()
        finally:
            self._stop_waiting()

        if self._error_response:
            yield kaiten.error.cloud_slicing_error

        # Then call into ExternalPrintProcess._set_filepath to leverage the
        # downloading logic there
        # We don't worry about if self._url is valid since
        # ExternalPrintProcess handles that check
        yield from super(CloudSlicePrintProcess, self)._set_filepath()
