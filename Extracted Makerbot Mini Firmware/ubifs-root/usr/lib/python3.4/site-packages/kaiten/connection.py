import datetime
import errno
import logging
import socket
import ssl
import weakref

import kaiten.constants
import kaiten.error
import kaiten.log

class Connection():
    """ Base class for all kaiten connection objects """

    def __init__(self):
        self._log = kaiten.log.getlogger(self)

    def read(self):
        "Template read function, not implemented."
        raise NotImplementedError

    def write(self, data):
        "Template write function, not implemented."
        raise NotImplementedError

    def close(self):
        raise NotImplementedError

class SocketConnection(Connection):
    """ A Posix socket connection.
    Major functionality is via 'read','write','stop'.
    """

    def __init__(self, socket, address, ssl_wrap=False):
        """
        @param socket a socket object
        @param address
        """
        Connection.__init__(self)
        if ssl_wrap:
            options = {
                'server_side': True,
                'do_handshake_on_connect': False,
                'keyfile': kaiten.constants.ssl_keyfile,
                'certfile': kaiten.constants.ssl_certfile,
            }
            self._socket = ssl.wrap_socket(socket, **options)
            # We can't read or write until we complete the handshake
            self._need_ssl_handshake = True
        else:
            self._socket = socket
            self._need_ssl_handshake = False
        self._address = address
        # Don't allocate any buffer initially
        self._buffer = None
        self._view = None

    def set_buffer(self, size):
        """
        Allocate a single buffer for reads from the socket.  Calling read
        will then return a memoryview into this buffer.  If size is set to
        None, the read behavior will return to allocating a byte string of
        limited size for each read, and the current buffer will eventually
        be garbage collected.  Calling this to change the buffer size will
        create a new buffer and let the old one be garbage collected, so
        the number of calls to this function should be limited.
        """
        if size is None:
            self._buffer = None
            self._view = None
        else:
            self._buffer = bytearray(size)
            self._view = memoryview(self._buffer)

    def write(self, *data):
        """
        Writes data to the socket, where data consists of zero or more byte
        arrays.  For perfomance reasons you should actually use this instead
        of concatenating several byte arrays into one.  This function is a
        python iterator; the caller must iterate completely over this function
        to ensure all data is written.
        """
        while self._need_ssl_handshake:
            # Let read() actually do the handshake
            yield
        for datum in data:
            i = 0
            while i < len(datum):
                try:
                    sent = self._socket.send(datum[i:])
                except IOError as e:
                    if e.args[0] in (errno.EINTR, errno.EAGAIN):
                        yield
                        continue
                    elif e.args[0] in (errno.EBADF, errno.EPIPE):
                        raise kaiten.error.ConnectionWriteException
                    else:
                        raise
                else:
                    if sent:
                        i += sent
                    yield

    def read(self):
        """ Not a generator because that would be stupid. """
        if self._need_ssl_handshake:
            # Don't try to read anything until the handshake is done
            self._socket.do_handshake()
            self._need_ssl_handshake = False
            return None
        try:
            if self._buffer:
                n = self._socket.recv_into(self._buffer)
                if None is n:
                    return None
                elif not n:
                    return b''
                else:
                    subview = self._view[:n]
                    return subview
            else:
                return self._socket.recv(4096)
        except socket.timeout as e:
            #timeouts are implemented differently than other IOErrors
            #they don't set errno, so we need to catch them explicitly
            return None
        except IOError as e:
            if e.args[0] in (errno.EINTR, errno.EAGAIN):
                return None
            else:
                raise

    def stop(self):
        # NOTE: use SHUT_RD instead of SHUT_RDWR or you will get annoying
        # 'Connection reset by peer' errors.
        try:
            self._socket.shutdown(socket.SHUT_RD)
            self._socket.close()
        except IOError as e:
            # NOTE: the Python socket implementation throws EBADF when you
            # invoke methods on a closed socket.
            if errno.EBADF != e.args[0]:
                raise
            else:
                pass #self._log.debug('handled exception', exc_info=True)

    def close(self):
        self._socket.close()

    def fileno(self):
        return self._socket.fileno()

    def peer_name(self):
        try:
            return self._socket.getpeername()
        except Exception:
            return '?'

class SocketManager(object):
    """
    Manage connection objects, making sure that there is a hard cap on the
    number of socket file decriptors open by all connection objects
    managed here.  (There is no cap on the number of connection objects.
    hence the name SocketManager.)  Only connections explicitly registered
    upon creation will have their sockets managed here.

    Registered connections must have the methods close() and peer_name()
    """
    def __init__(self, max_sockets=96):
        self._max_sockets = max_sockets
        self._log = kaiten.log.getlogger(self)

        # Maps connection objects to connection times if they are droppable,
        # otherwise maps them to None.  We use weak references to reduce the
        # number of callbacks we have to deal with.
        self._conn_map = weakref.WeakKeyDictionary()

    def register(self, connection, droppable=True):
        """
        Try to register a new connection.  If no existing connections are
        droppable, the new connection is closed and an error is raised.
        """
        if len(self._conn_map) >= self._max_sockets:
            # Return tuples with the value listed first so we sort by value
            droppable = [(v,k) for (k,v) in self._conn_map.items() if v]
            if not droppable:
                connection.close()
                self._log.info('Refused connection %s', connection.peer_name())
                raise kaiten.error.TooManySocketsException
            # Get the least recently created connection
            victim = sorted(droppable)[0][1]
            # We just close the connection here and trust that
            # our error handling will take care of the rest.
            self._log.info('Dropping connection %s', victim.peer_name())
            victim.close()
            del self._conn_map[victim]
        if droppable:
            self._conn_map[connection] = datetime.datetime.utcnow()
        else:
            self._conn_map[connection] = None

    def persist(self, connection):
        """
        Mark an existing connection as not droppable.  Takes no action if
        the connection has not been registered.
        """
        if connection in self._conn_map:
            self._conn_map[connection] = None
