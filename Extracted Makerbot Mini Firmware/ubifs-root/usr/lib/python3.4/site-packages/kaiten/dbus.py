import ctypes
import datetime
from functools import wraps
import ipaddress
import json
import os
import sys
import threading
import contextlib

# The python host scripts that we run to analyze kaiten generally
# cannot import dbus because it is really hard on ubuntu to get
# dbus-python installed in a way that is usable by python 3.3.
# (For python3.4 it works out of the box.)
try:
    import dbus
    import dbus.exceptions
    import dbus.service
    import dbus.mainloop.glib
except ImportError:
    pass

import kaiten.avahi
import kaiten.constants
import kaiten.decorator
import kaiten.error
import kaiten.jsonrpc
import kaiten.log
import kaiten.usb
import kaiten.util

JsonRpcException = kaiten.jsonrpc.JsonRpcException

WIFI_TECH = '/net/connman/technology/wifi'

def _dbus_jsonrpc_generator(jsonrpc_expose=True):
    """
    A decorator which allows us to write jsonrpc methods which call dbus
    methods.  The methods must be called on a wrapped dbus interface as
    returned by _get_interface, and it must be called as follows:

    result = yield wrapped_interface(args)

    The result of this call will be the same as if you had called the
    method on the unwrapped interface, except that on the unwrapped
    interface this call would block all of kaiten waiting for a reply.

    Note that this decorator automatically applies the jsonrpc and
    pass_callback decorators.  If you want to directly call a function
    decorated with this from within kaiten, you need to pass it a callback
    which can handle the result/error from the method.  This is true even
    if you set jsonrpc_expose to False, which prevents it from being
    as a jsonrpc method (making it only callable directly from kaiten).

    The dbus_init argument allows a method to be invoked before the dbus
    interface is fully initialized, and should only be used internally
    during the initialization sequence
    """
    def outer_decorator(func):
        @wraps(func)
        def decorator(self, *args, callback=None, dbus_init=False, **kwargs):
            # The actual implementation of this is hidden away at the
            # bottom of the file.  It is not pretty.
            return _dbus_generator_backend(func, self, args, kwargs,
                                           callback, dbus_init)
        decorator = kaiten.decorator.pass_callback(decorator)
        if jsonrpc_expose:
            decorator = kaiten.decorator.jsonrpc(decorator)
        return decorator
    return outer_decorator

class DBusManager(object):
    def __init__(self, server, queue):
        self._log = kaiten.log.getlogger(self)
        self._server = server
        self._queue = queue # Queue on which to place generators to be executed
        self._start_glib_thread()
        self._last_wifi_scan = None
        self._wifi_refresh = datetime.timedelta(seconds=10)
        self._tethering = False
        self._cached_services = None

        # Aspirational: actual state is kept in server.network_state()
        self._wifi_enabled = False

        # This doesn't actually initialize the bus, it just installs a contract
        # generator which will initialize all components as they become ready.
        self._initialized = False
        self._initialize_bus()

        # Also install a contract generator to keep wifi connections up
        self._reconnector_inst = self._reconnector()
        self._server.add_net_change_callback(self._reconnector_update)
        self._ap_name = ""
        self._reconnector_enabled = True

    def _start_glib_thread(self):
        """
        Start a seperate slave thread to run the glib main loop that
        will invoke dbus callbacks
        """
        dbus.mainloop.glib.threads_init()
        dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
        self._glib = ctypes.CDLL('libglib-2.0.so')
        self._gmain_loop = self._glib.g_main_loop_new(None, 0)
        def run_glib():
            self._glib.g_main_loop_run(self._gmain_loop)
        self._glib_thread = threading.Thread(target=run_glib)
        self._glib_thread.start()
        self._glib_running = True

    def close(self):
        if self._glib_running:
            self._glib_running = False
            self._glib.g_main_loop_quit(self._gmain_loop)
            self._glib_thread.join()

    @contextlib.contextmanager
    def disable_reconnector(self):
        """ A context manager during which reconnector will be disabled.
        """
        self._reconnector_enabled = False
        yield
        self._reconnector_enabled = True

    def set_reconnector_enabled(self, state):
        """Set whether reconnector is enabled."""
        self._reconnector_enabled = state

    @_dbus_jsonrpc_generator()
    def connman_get_services(self):
        """ Dump connman debug info @INTERNAL """
        result = yield self._connman.GetServices()
        log_str = json.dumps(result, indent=4, separators=(',', ': '), sort_keys=True)

        # We can't return the result directly because json.dumps makes unparseable json
        return log_str

    def _get_connected(self, services, require_wifi=False):
        """
        Sift through the large list of services returned by GetServices, and
        return a single service that we are "connected to".  Returns a tuple of
        (service_path, dict), or (None, None) if no service is "connected".
        """
        def state_filter(state):
            def inner_filter(s):
                if s[1]["State"] != state: return False
                if require_wifi: return s[1]["Type"] == "wifi"
                return True
            return inner_filter
        online = list(filter(state_filter('online'), services))
        if len(online) == 0:
            # Prefer online networks, but ready is also fine
            online = list(filter(state_filter('ready'), services))
        if len(online) == 0:
            return (None, None)
        elif len(online) > 1:
            # If we have a wired connection, prefer that.
            wired_online = [s for s in online if s["Type"] == 'wired']
            if len(wired_online) > 0:
                online = wired_online
        return online[0]

    def _get_connection_details(self, properties):
        """
        Sift through the massive service property dict that connman gives us
        and produce a dict of values that we actually care about.  Passing in
        None will produce the same result as a service that is not connected.
        """
        state = {}
        if not properties or properties['State'] not in ('online', 'ready'):
            state['state'] = 'offline'
            return state
        state['state'] = properties['Type']
        if 'Address' in properties['IPv4']:
            state['ip'] = properties['IPv4']['Address']
            gateway = properties['IPv4'].get('Gateway', None)
            netmask = properties['IPv4'].get('Netmask', None)
            static = (properties['IPv4']['Method'] == 'manual')
        elif 'Address' in properties['IPv6']:
            state['ip'] = properties['IPv6']['Address']
            gateway = properties['IPv6'].get('Gateway', None)
            netmask = properties['IPv6'].get('Netmask', None)
            static = False
        else:
            # We still sometimes get into this state, and raising an
            # error turns out to be more spammy than just logging here.
            self._log.error('Connection to %s reported success but no address',
                            properties.get('Name', 'ethernet'))
            state['state'] = 'offline'
            return state
        if gateway: state['gateway'] = gateway
        if netmask: state['netmask'] = netmask
        state['static'] = static
        if 'Nameservers' in properties:
            state['dns'] = list(properties['Nameservers'])
        if properties['Type'] == 'wifi':
            state['name'] = properties['Name']
        return state

    def _update_good_aps(self, services):
        """
        Update self._good_aps based on the results of GetServices().  In
        order to keep the list of APs we should try to reconnect to up
        to date, we have to invoke this when we first connect to connman
        and also manually update self._good_aps when we change things.
        """
        for path, properties in services:
            if not properties['Favorite'] or not properties['AutoConnect']:
                # Not an AP we should try to reconnect to
                continue
            if path not in self._good_aps:
                if properties['State'] == 'online':
                    self._good_aps.insert(0, path)
                else:
                    self._good_aps.append(path)

    @staticmethod
    def _wifi_hash(path):
        """ Use a 4 hex digit hash of the path """
        return ('%04x' % hash(path))[-4:]

    @staticmethod
    def default_network_state():
        return {
            'state' : 'offline',
            'wifi' : 'initializing',
            'tethering': False,
            'tether_name': ''
        }

    @_dbus_jsonrpc_generator(jsonrpc_expose=False)
    def _network_state(self):
        """
        Return a dict describing the network connection state, which will always
        contain "state" set to one of "offline", "wired", "wifi".  If state is
        not offline, "ip" will be set to the current ip address, and if state is
        wifi, "name" will be set to the wifi's SSID.  If all you want is the ip
        address or online/offline status, please use the "ip" field of the
        system notification instead.
        """
        state = {}
        services = yield self._connman.GetServices()
        path, properties = self._get_connected(services)
        state.update(self._get_connection_details(properties))
        self._update_good_aps(services)
        if state['state'] == 'wifi':
            state['service_hash'] = self._wifi_hash(path)
        elif state['state'] == 'ethernet':
            state['service_hash'] = 'eth'
        # I am moving wifi state checks to be the last dbus call to fix
        # an annoying race condition that really should be fixed by not
        # checking wifi state here.
        techs = yield self._connman.GetTechnologies()
        wifi_status = [t[1] for t in techs if t[0] == WIFI_TECH]
        if not wifi_status:
            state['wifi'] = 'borked'
        else:
            self._log.info("Queried dbus network state")
            self._tethering = bool(wifi_status[0]['Tethering'])
            if wifi_status[0]['Powered']:
                state['wifi'] = 'enabled'
                self._wifi_enabled = True
            else:
                state['wifi'] = 'disabled'
        state['tethering'] = self._tethering
        state['tether_name'] = self._ap_name
        return state

    @_dbus_jsonrpc_generator(jsonrpc_expose=False)
    def current_wifi_path(self):
        services = yield self._connman.GetServices()
        path, properties = self._get_connected(services)
        state = self._get_connection_details(properties)
        self._log.info("Got state {}".format(state))
        if state['state'] == 'wifi':
            return path
        else:
            return ''

    def _make_variant(self, string):
        """
        Make a given string into a dbus string with variant level
        """
        if string is None:
            return None
        return dbus.String(string, variant_level=1)

    def _get_ethernet(self, services):
        """
        Return list of all available ethernet type connman services
        """
        def ethernet_filter(s):
            return s[1]["Type"] == "ethernet"
        return list(filter(ethernet_filter, services))

    def _get_service_by_path(self, service_path):
        if service_path.lower() == "ethernet":
            services = yield self._connman.GetServices()
            wired_services = self._get_ethernet(services)
            if len(wired_services) == 0:
                raise JsonRpcException(77, "no wired connections found")
            service_path = wired_services[0][0]
        service = self._get_interface(
            'net.connman', 'net.connman.Service', service_path)
        return service

    @_dbus_jsonrpc_generator()
    def set_static_ipv4(self, service_path:str, ip:str=None, netmask:str=None,
        gateway:str=None, dns:list=None, use_static:bool=True):
        """
        Sets a static IPv4 address

        If no netmask or gateway is provided, connman will do the best it
        can to fill these in.  DNS servers can be added whether or not a
        static IP is set, and must be explicitly cleared by passing an empty
        list.

        @param service_path: the service path we want to set the static ip on
                             If 'ethernet' is passed kaiten finds the correct
                             service
        @param ip: Static IP string to set in the form (X.X.X.X)
        @param netmask: Netmask string in the form (X.X.X.X)
        @param gateway: Default gateway in the form (X.X.X.X)
        @param dns: List of dns servers, or null to keep current settings
        @param use_static: Set to false to return to using DHCP
        """
        method = "manual" if use_static else "dhcp"

        #Test that all the given IPv4 addresses are valid
        for p in (ip, netmask, gateway):
            if p is None:
                continue
            try:
                ipaddress.IPv4Address(p)
            except ipaddress.AddressValueError:
                raise JsonRpcException(78, "bad static ip params")

        service = yield from self._get_service_by_path(service_path)

        #Create ip configuration dict excluding keys value pairs if the value
        #is None
        ip_conf = {"Method": self._make_variant(method)}
        if ip is not None:
            ip_conf["Address"] = self._make_variant(ip)
        if netmask is not None:
            ip_conf["Netmask"] = self._make_variant(netmask)
        if gateway is not None:
            ip_conf["Gateway"] = self._make_variant(gateway)

        #Set the IPv4 configuration catching exceptions
        try:
            yield service.SetProperty("IPv4.Configuration",
                                      ip_conf, signature='sv')
            if dns is not None:
                # We need to make sure that this is typed as an array of
                # strings even when it is an empty array...
                dns = dbus.Array(dns, signature='s')
                yield service.SetProperty("Nameservers.Configuration",
                                          dns, signature='sv')
        except TypeError as e:
            raise JsonRpcException(78, "bad static ip params")

    @_dbus_jsonrpc_generator()
    def get_static_ipv4(self, service_path:str) -> dict:
        """
        Gets static IPv4 address settings

        The format of the returned settings dict matches the input
        format for set_static_ipv4.  If use_static is False, this will
        be the only element returned, otherwise all four will be present.

        @param service_path: the service path we want to set the static ip on
                             If 'ethernet' is passed kaiten finds the correct
                             service

        @return: A dict of static IP settings
        """
        service = yield from self._get_service_by_path(service_path)
        properties = yield service.GetProperties()
        config = properties['IPv4.Configuration']
        method = config['Method']
        if method == 'dhcp':
            result = {'use_static': False}
        elif method != 'manual':
            raise Exception('Unhandled connection method')
        else:
            result = {'use_static': True}
            if 'Address' in config: result['ip']      = str(config['Address'])
            if 'Netmask' in config: result['netmask'] = str(config['Netmask'])
            if 'Gateway' in config: result['gateway'] = str(config['Gateway'])
        dnsconfig = properties['Nameservers.Configuration']
        dnslist = list(map(str, dnsconfig))
        if len(dnslist) > 0:
            result['dns'] = dnslist
        return result

    def _scan(self, force=False, retry_count=2):
        """
        Scan wifi if we don't have recent results, or if force is True

        Sometimes scan gives us spurious errors, such as a dbus timeout.  So
        we both retry the scan if it fails and don't raise an error even if
        the retry fails.
        """
        if self._last_wifi_scan is None or force:
            expired = True
        else:
            expiry = self._last_wifi_scan + self._wifi_refresh
            expired = expiry < datetime.datetime.utcnow()
        if expired:
            for i in range(retry_count):
                try:
                    yield self._wifi_tech.Scan()
                except dbus.DBusException as e:
                    continue
                self._last_wifi_scan = datetime.datetime.utcnow()
                break

    @_dbus_jsonrpc_generator()
    def wifi_scan(self, force_rescan:bool=False) -> list:
        """
        Scan wifi networks, return a list of wifi APs.

        Each element of the list is a dict with members 'path', 'name',
        'strength', and 'password'.  'path' is a unique AP identifier
        suitable for passing to wifi_connect, 'name' is a human readable
        AP name, and 'strength' is a integer between 0 (weakest) and 100
        (strongest).  'password' takes one of three values:  'none' for
        unsecured APs, 'stored' for a secured AP that the bot knows the
        password to, and 'required' for all other secured APs.

        @param force_rescan: Might make getting a stale AP list less likely
        @return: A list of wifi APs, see the full docstring for details
        """
        if self._tethering:
            if self._cached_services is None:
                raise Exception("Cannot scan while tethering")
            services = self._cached_services
        else:
            yield from self._scan(force_rescan)
            services = yield self._connman.GetServices()
        def dictify(path, connman_dict):
            if 'none' in connman_dict['Security']:
                password = 'none'
            elif connman_dict['Favorite'] == 1:
                # Weird name -- actually means we have at some point connected
                password = 'stored'
            else:
                password = 'required'
            return {
                'path': str(path),
                'name': str(connman_dict.get('Name', '')),
                'password': password,
                'strength': int(connman_dict.get('Strength', 0))
            }
        wifi_aps = [ dictify(*x) for x in services if x[1]['Type'] == 'wifi' ]
        return wifi_aps

    def _wifi_start_connect(self, service, path, password, name):
        """
        Unconditionally initiate connection to the given wifi service.
        Does not check if the connection already exists or wait for the
        connection to complete.
        """
        errors = []
        info = []

        # WARNING: ConnmanAgent methods are called by the glib thread
        class ConnmanAgent(dbus.service.Object):
            @dbus.service.method(dbus_interface='net.connman.Agent',
                                 in_signature='oa{sa{ss}}', out_signature='a{sv}')
            def RequestInput(self, service, request):
                result = {}
                def fill_input(field, data, data_name):
                    if field not in request: return
                    result[field] = data
                    info.append(data_name + '-requested')
                    requirement = request[field]['Requirement']
                    if requirement == 'mandatory' and data is None:
                        errors.append(data_name + '-required')
                fill_input('Passphrase', password, 'password')
                fill_input('Name', name, 'name')
                return result

            @dbus.service.method(dbus_interface='net.connman.Agent',
                                 in_signature='os', out_signature='')
            def ReportError(self, service, error):
                errors.append(str(error))

        # Connect with the password handler in place
        agent = ConnmanAgent(self._bus, path)
        try:
            yield self._connman.RegisterAgent(path, signature='o')
            try:
                # Two minute timeout because connman docs note that this method
                # only returns when the service is _fully_ connected and
                # helpfully notes that setting a longer D-Bus timeout "might be
                # a really good idea"
                # http://git.kernel.org/cgit/network/connman/connman.git/tree/doc/service-api.txt
                yield service.Connect(timeout=120000)
            except dbus.DBusException as e:
                if errors:
                    if 'password-required' in errors:
                        raise JsonRpcException(51, 'wifi password required')
                    elif 'invalid-key' in errors:
                        raise JsonRpcException(52, 'invalid wifi password')
                    elif 'name-required' in errors:
                        raise JsonRpcException(53, 'wifi ssid name required')
                    else:
                        raise JsonRpcException(55, 'wifi error', errors)
                elif 'name-requested' in info:
                    raise JsonRpcException(54, 'invalid wifi ssid name')
                else:
                    raise
            finally:
                yield self._connman.UnregisterAgent(path, signature='o')
        finally:
            agent.remove_from_connection()

    def _wifi_connect(self, path, password=None, name=None):
        """
        Internal version of wifi_connect that does not handle the full
        process necessary to connect to a hidden wifi AP.
        """
        service = self._get_interface(
            'net.connman', 'net.connman.Service', path)

        # Set up notification for when the connection actually completes
        # TODO: Is this still necessary now that 'ready' counts as connected?
        result_dict = {'done': False}
        def property_callback(prop, value):
            if prop == 'State' and value in ['online', 'ready']:
                result_dict['done'] = True
                if 'wakeup_callback' in result_dict:
                    result_dict['wakeup_callback']()
                    del result_dict['wakeup_callback']
        watch = service.connect_to_signal('PropertyChanged', property_callback)

        try:
            # Connect and wait for connection verification _only_ if we are not
            # already connected, otherwise our wait could hang forever.
            properties = yield service.GetProperties()
            if properties['State'] not in ('online', 'ready'):
                yield from self._wifi_start_connect(service, path, password, name)
                if not result_dict['done']:
                    def fake_dbus_wait(**kwargs):
                        result_dict['wakeup_callback'] = kwargs['reply_handler']
                    yield fake_dbus_wait
        finally:
            watch.remove()

        yield service.SetProperty('AutoConnect', True, signature='sv')
        # Make sure that this ap is at the front of the list
        if path not in self._good_aps[:1]:
            if path in self._good_aps:
                self._good_aps.remove(path)
            self._good_aps.insert(0, path)

        properties = yield service.GetProperties()
        return self._get_connection_details(properties)

    @_dbus_jsonrpc_generator()
    @kaiten.decorator.require_secure
    def wifi_connect(self, path:str, password:str=None, name:str=None) -> dict:
        """
        Connect to a wifi AP

        The AP must be specfied by connman path, meaning that it
        must have shown up in a previous call to wifi_scan.  If
        wifi_scan reported that a password is required, then the
        password field will be used to connect.  Otherwise the
        password field will be ignored.

        @param path: Connman path of a wifi AP returned by wifi_scan
        @param password: Password for secured wifi networks
        @param name: Network name for hidden networks
        @return: IP address et al, formatted to match network_state()
        """
        if self._tethering:
            raise JsonRpcException(56, "Wifi cannot connect while tethered")
        with self._server.set_ifup_modifier('M'):
            try:
                return (yield from self._wifi_connect(path, password, name))
            except JsonRpcException as e:
                if e.code != 54: raise
                # We may have the wrong SSID, but we also end up here if we
                # have the right SSID.  The only way to tell is to check if
                # a new service appeared with the given name.
                services = yield self._connman.GetServices()
                def match(d):
                    return d['Type'] == 'wifi' and d.get('Name') == name
                matches = [s[0] for s in services if match(s[1])]
                if not matches: raise
                path = matches[0]
                result = yield from self._wifi_connect(path, password)
                result['path'] = path
                return result
            except dbus.DBusException as e:
                # If the AP we are connecting to disappeared, we want a
                # more informative error message.
                err_name = 'org.freedesktop.DBus.Error.UnknownMethod'
                err_msg_prefix = 'Method "GetProperties"'
                if e.get_dbus_name() != err_name: raise
                if not e.get_dbus_message().startswith(err_msg_prefix): raise
                raise JsonRpcException(50, "Service path disappeared", path)
        self._update_discovery(False)

    @_dbus_jsonrpc_generator()
    def wifi_disconnect(self, path:str=None):
        """
        Disconnect from the current wifi AP

        @param path: If given a connman path to an AP, disconnect that AP
        """
        if None is path:
            services = yield self._connman.GetServices()
            path, properties = self._get_connected(services, require_wifi=True)
            if not path: return
        if path in self._good_aps:
            self._good_aps.remove(path)
        interface = self._get_interface(
            'net.connman', 'net.connman.Service', path)
        with self._server.set_ifdn_modifier('M'):
            yield interface.SetProperty('AutoConnect', False, signature='sv')
            yield interface.Disconnect()

    @_dbus_jsonrpc_generator(jsonrpc_expose=False)
    def wifi_reset_autoconnect(self, path):
        """ Reset autoconnect on a path that has previously been disconnected
        from with wifi_disconnect but has not yet been forgotten.
        """
        interface = self._get_interface('net.connman', 'net.connman.Service',
                                        path)
        with self._server.set_ifdn_modifier('M'):
            yield interface.SetProperty('AutoConnect', True, signature='sv')

    @_dbus_jsonrpc_generator()
    def wifi_forget(self, path:str=None):
        """
        Completely forget the current wifi AP

        @param path: If given a connman path to an AP, forget that AP
        """
        if None is path:
            services = yield self._connman.GetServices()
            path, properties = self._get_connected(services, require_wifi=True)
            if not path: return
        if path in self._good_aps:
            self._good_aps.remove(path)
        interface = self._get_interface(
            'net.connman', 'net.connman.Service', path)
        with self._server.set_ifdn_modifier('M'):
            yield interface.Remove()

    def stop_connman(self):
        """ Stop connman, and yield until it's down"""
        cm_path = '/etc/init.d/S45connman'
        call = kaiten.util.subprocess_call
        yield from call([cm_path, 'stop'])
        old_pid = yield from kaiten.util.await_process('connmand', False)
        return old_pid

    def start_connman(self):
        """ Start connman, and yield until it's up
        """
        cm_path = '/etc/init.d/S45connman'
        call = kaiten.util.subprocess_call
        yield from call([cm_path, 'start'])
        new_pid = yield from kaiten.util.await_process('connmand', True)
        return new_pid

    @kaiten.decorator.jsonrpc
    @kaiten.decorator.contractify(interval=0.2)
    def wifi_reset(self) -> None:
        """
        Remove all of connman's cached information, restart connman.
        """
        cm_path = '/etc/init.d/S45connman'
        call = kaiten.util.subprocess_call
        self._good_aps.clear()
        self._log.info("Restarting connman...")
        old_pid = yield from self.stop_connman()
        yield from call(['rm', '-rf', '/var/lib/connman'])
        state = {'state': 'offline', 'wifi': 'disabled'}
        with self._server.set_ifdn_modifier('M'):
            self._server.network_state_change(full_state=state)

        self._log.info("Connman is now DOWN, was pid {}".format(old_pid))
        new_pid = yield from self.start_connman()
        self._log.info("Connman is now UP with pid {}".format(new_pid))

    @_dbus_jsonrpc_generator()
    def wifi_enable(self):
        """ Power on the wifi peripheral """
        self._wifi_enabled = True
        yield self._wifi_tech.SetProperty('Powered', True, signature='sv')

    def _do_wifi_enable(self):
        """
        Convenience method to enable wifi

        This logs any error in trying to enable wifi to netlog.
        """
        def callback(result=None, error=None):
            if error is not None:
                self._server.netlog('ENABLE_ERR', exc=error)
        self.wifi_enable(callback=callback)

    @_dbus_jsonrpc_generator()
    def wifi_disable(self):
        """ Power off the wifi peripheral """
        if self._tethering:
            yield from self._wifi_disable_tether()
        self._wifi_enabled = False
        with self._server.set_ifdn_modifier('M'):
            self._log.info("Disable wifi")
            yield self._wifi_tech.SetProperty('Powered', False, signature='sv')
        self._log.info("wifi: disabled")

    def _wifi_disable_tether(self):
        """
        Generator to stop tethering and wait for normal operation

        As part of disabling tethering we appear to power off and turn
        back on the wifi power, so sometimes things fail if we try
        them as soon as we get back up.
        """
        self._cached_services = None
        set_property = self._wifi_tech.SetProperty
        yield set_property('Tethering', False, signature='sv')

        # We want to wait a while for this to settle into the right state,
        # but we don't want to wait forever because we might never get into
        # the state we want.  This is pretty ugly but it is also the least
        # ugly thing I tried that actually worked...
        for i in range(10):
            techs = yield self._connman.GetTechnologies()
            try:
                wifi_status = [t[1] for t in techs if t[0] == WIFI_TECH][0]
            except IndexError:
                # Sometimes we don't get a wifi technology. ConnMan works in
                # mysterious ways. Just try again later.
                continue
            if not wifi_status['Tethering'] and wifi_status['Powered']:
                self._tethering=False
                break

    def _require_wifi(self):
        """ Ensure wifi is enabled """
        wifi_status = None
        def wifi_up_callback(result=None, error=None):
            nonlocal wifi_status
            if error is not None:
                self._log.error("Error bringing up wifi: {}".format(error))
                wifi_status = error

        self.wifi_enable(callback=wifi_up_callback)
        while None is wifi_status\
              and self._server.network_state()['wifi'] != 'enabled':
            yield
        if wifi_status == False:
            self._log.error("Could not connect to wifi: {}".format(wifi_status))
            yield kaiten.error.wifi_general_error

    def ensure_tether(self, state:bool):
        """
        Set tethering on or off from ANY broadcast state

        This is a utility generator for use in processes, so any error
        encountered that cannot be handled here will result in yielding
        an error code.
        """
        if self._server.network_state()['wifi'] != 'enabled':
            yield from self._require_wifi()
        if state == self._tethering:
            self._log.info("ensure tether: tether already %s", state)
            return
        # As with other dbus calls, just telling the dbus manager to get this
        # done eventually isn't good enough here - we can't proceed until the
        # tether is set up correctly, so we specify a callback and don't let
        # things proceed until we're actually ready.
        tether_status = None
        def tether_callback(result=None, error=None):
            nonlocal tether_status
            if error is not None:
                self._log.error("tether callback error: {}".format(repr(error)))
                tether_status = error
            else:
                tether_status = state
        self.wifi_tether(state, callback=tether_callback)
        while None is tether_status:
            yield
        while self._tethering != state:
            yield
        if tether_status != state:
            self._log.error("Tether command failed: wanted {} got {}".format(state, tether_status))
            yield kaiten.error.wifi_general_error
        if tether_status:
            self._server._machine_manager.push_light_state('tether')
            self._server._machine_manager.pop_light_state('priority_busy')
        else:
            self._server._machine_manager.pop_light_state('tether')
        self._update_discovery(False)
        self._log.info("ensure tether: tether set to {}, self._tether: {}".format(state, self._tethering))

    @_dbus_jsonrpc_generator(jsonrpc_expose=False)
    def wifi_tether(self, on:bool=True):
        """
        Start or stop tethering

        @INTERNAL - I think before release we should raise_priv this
                    since only the UI client should invoke this.

        @param on: Whether to turn tethering on or off
        """
        if not on:
            yield from self._wifi_disable_tether()
            self._server.auth_store.wifi_auth_ok = False
            self._log.info("tether: disabled")
            return

        # First we cache known APs so wifi_scan will still work
        #yield from self._scan()
        #self._cached_services = yield self._connman.GetServices()

        if self._ap_name == "":
            # this is generated here to avoid querying more usb things during
            # initialization
            self._ap_name = kaiten.constants.ap_name_base
            self._ap_name += kaiten.usb.get_serial()[-4:]

        set_property = self._wifi_tech.SetProperty
        yield set_property('TetheringIdentifier', self._ap_name, signature='sv')
        yield set_property('TetheringPassphrase', '', signature='sv')
        yield set_property('Tethering', True, signature='sv')
        self._server.auth_store.wifi_auth_ok = True

    @_dbus_jsonrpc_generator(jsonrpc_expose=False)
    def _log_strength(self):
        """
        Log the strength of the current AP to the network log
        """
        yield from self._scan()
        services = yield self._connman.GetServices()
        path, properties = self._get_connected(services, require_wifi=True)
        if not path: return
        strength = int(properties['Strength'])
        self._server.netlog('STRENGTH', value=strength)

    @_dbus_jsonrpc_generator(jsonrpc_expose=False)
    def _try_toggle(self):
        """
        Try to toggle the wifi power

        We don't actually turn the power back on here, but instead we
        leave _wifi_enabled True when we turn it off.  This means that
        as soon as we are notified that it actually turned off, we will
        try to turn it back on, and if that fails then the reconnector
        will keep trying to turn the wifi on.
        """
        self._server.netlog('TOGGLE')
        # This should basically never take the network down, so
        # we should make sure we log something unique if it does.
        with self._server.set_ifdn_modifier('R'):
            # We don't want to retry this here if it fails
            self._log.info("toggle wifi off")
            yield self._wifi_tech.SetProperty('Powered', False, signature='sv')

    @_dbus_jsonrpc_generator(jsonrpc_expose=False)
    def _try_reconnect(self, path):
        """
        Try to reconnect to a network that is already set to autoconnect.

        We also log the strength of that network to the network log.
        """
        modifiers = ['(%s)' % self._wifi_hash(path)]
        try:
            with self._server.set_ifup_modifier('R'):
                yield from self._scan()
                service = self._get_interface(
                    'net.connman', 'net.connman.Service', path)

                # Get and log the signal strength
                properties = yield service.GetProperties()
                strength = int(properties['Strength'])
                self._server.netlog('STRENGTH', value=strength,
                                    modifiers=modifiers)

                yield from self._wifi_start_connect(service, path, None, None)
        except Exception as exc:
            self._server.netlog('RCONN_FAIL', modifiers=modifiers, exc=exc)

    def _reconnector_update(self, state, old_state):
        # Defer the reconnector whenever our connection drops
        if old_state['state'] != 'offline' and state['state'] == 'offline':
            self._server.reschedule_contract_generator(self._reconnector_inst)

    @kaiten.decorator.contractify(interval=60)
    def _reconnector(self):
        """
        We sometimes get into a state where connman thinks it is trying
        to connect to an AP, but nothing is really happening.  I don't
        know where this is breaking down, but disabling and reenabling
        wifi is the only thing I have found that reliably fixes this.
        We also think that connman sometimes gives up on connecting to
        APs, but we don't really have any hard evidence that this
        happens.  So we also have logic to request AP reconnection when
        disabling and reenabling wifi does not work.

        We also use this to log our signal strength when connected.
        """
        idx = 0
        do_toggle = True
        while True:
            yield
            state = self._server.network_state()
            if not self._reconnector_enabled:
                do_toggle = False
                continue
            if self._tethering:
                do_toggle = False
                continue
            if state['wifi'] != 'enabled' and self._wifi_enabled:
                self._do_wifi_enable()
                continue
            if state['state'] == 'wifi':
                self._log_strength()
            if state['state'] != 'offline' or state['wifi'] != 'enabled':
                idx = 0
                do_toggle = True
                continue
            if not self._good_aps:
                continue
            if do_toggle:
                do_toggle = False
                self._log.info("Toggle wifi off, network state {}".format(state))
                self._try_toggle()
                continue
            do_toggle = True
            if idx >= len(self._good_aps):
                idx = 0
            ap = self._good_aps[idx]
            idx += 1
            self._try_reconnect(ap)

    @kaiten.decorator.contractify(interval=1)
    def _initialize_bus(self):
        """
        Setup all objects needed for dbus interaction.  We put them in
        a generator because this cannot complete until dbus and all dbus
        connected clients have started up.  We (ab)use the contractify
        generator to iterate this periodically until it completes.
        """
        # Lightweight check if dbus has started yet
        while not os.path.exists('/var/run/dbus/system_bus_socket'):
            yield

        # I don't think this can fail once the socket exists...
        self._bus = dbus.SystemBus()
        # Yes, this really defaults to True.
        self._bus.set_exit_on_disconnect(False)

        self._connman = self._get_interface(
            'net.connman', 'net.connman.Manager', '/')
        self._init_wifi()
        self._good_aps = []

        # Even though we have created connman interfaces, connman might not
        # yet be there on the other end.  So we invoke _network_state()
        # periodically until it succeeds.
        yield from self._dbus_retry(self._network_state, dbus_init=True)

        # Now we can initialize everything which depends on the bus
        self._initialized = True
        self._install_signal_handlers()
        self._log.info('DBus initialized')

    def _get_hostname(self):
        """
        Return the hostname that we want avahi to use.

        This needs to be unique for any two bots on the same network,
        and it would be nice to keep it short.
        """
        return "Makerbot-" + kaiten.usb.get_serial()[-6:]

    @kaiten.decorator.contractify(interval=1)
    def update_discovery(self, change_hostname=False):
        yield from self._dbus_retry(self._update_discovery, change_hostname)

    @_dbus_jsonrpc_generator(jsonrpc_expose=False)
    def _update_discovery(self, change_hostname):
        if self._discovery_iface:
            yield from self._do_update_discovery(change_hostname)

    def _do_update_discovery(self, change_hostname):
        hostname = self._get_hostname()
        avahi_hostname = yield self._avahi.GetHostName()
        if hostname != avahi_hostname and avahi_hostname.startswith(hostname):
            # Avahi does this thing sometimes where it will see its own hostname
            # being used on the a network it just came up on and will rename
            # itself to avoid a name conflict with itself... this is probably a
            # bug in avahi but in the meantime, let's check for this occurring
            # update our service, because that doesn't happen automatically and
            # if you get avahi advertising a service for a different hostname
            # it breaks the hell out of most clients
            self._log.warning("Avahi hostname changed to {}, updating service"\
                              .format(avahi_hostname))
            hostname = avahi_hostname
            change_hostname = True
        if change_hostname:
            try:
                yield self._avahi.SetHostName(hostname)
            except dbus.DBusException as e:
                # This is pretty stupid...
                if not str(e).startswith('org.freedesktop.Avahi.NoChangeError'):
                    raise
        yield self._discovery_iface.Reset()
        yield self._discovery_iface.AddService(
            kaiten.avahi.IF_UNSPEC,
            kaiten.avahi.PROTO_UNSPEC,
            dbus.UInt32(0),
            hostname,
            kaiten.avahi.SERVICE_TYPE,
            '',
            '',
            dbus.UInt16(kaiten.constants.tcp_port),
            self._build_mdns_records())
        yield self._discovery_iface.Commit()

    @_dbus_jsonrpc_generator(jsonrpc_expose=False)
    def kill_discovery(self):
        """ Tell avahi to shutdown discovery for our service """
        yield self._discovery_iface.Free()
        self._discovery_iface = None

    @kaiten.decorator.contractify(interval=1)
    def start_discovery(self):
        while not self._initialized:
            yield
        yield from self._dbus_retry(self._initialize_discovery)

    @_dbus_jsonrpc_generator(jsonrpc_expose=False)
    def _initialize_discovery(self):
        """ Connect to Avahi and register discovery. @INTERNAL"""
        self._log.info("Bringing up MDNS/SD discovery advertising...")
        hostname = self._get_hostname()
        self._avahi = self._get_interface(
            kaiten.avahi.DBUS_NAME,
            kaiten.avahi.DBUS_INTERFACE_SERVER,
            kaiten.avahi.DBUS_PATH_SERVER)
        iface_path = yield self._avahi.EntryGroupNew()
        self._discovery_iface = self._get_interface(
            kaiten.avahi.DBUS_NAME,
            kaiten.avahi.DBUS_INTERFACE_ENTRY_GROUP,
            iface_path)
        yield from self._do_update_discovery(True)
        self._log.info("mDNS/SD discovery online as %s", hostname)

    def _build_mdns_records(self):
        info = self._server.get_machine_info_dict()
        # agh
        info['firmware_version']\
            = str(kaiten.util.Version.from_dict(info['firmware_version']))
        return [dbus.ByteArray((key+ u'='+str(info[key])).encode('UTF-8'))
                for key in info.keys()]

    def _init_wifi(self):
        try:
            self._wifi_tech = self._get_interface('net.connman',
                'net.connman.Technology', WIFI_TECH)
            self._log.info('DBus wifi initialized')
        except Exception:
            self._wifi_tech = None
            self._log.warning('Wifi is broken', exc_info=True)

    def _dbus_retry(self, func, *args, **kwargs):
        """
        Retry a _dbus_jsonrpc_generator until it succeeds.

        This is meant to be yielded from in a contract generator with a
        reasonably long contract period so as not to overwhelm the system.
        func(*args, **kwargs) will be called indefinitely until it succeeds,
        at which point any result that it produces will be ignored.  This
        should not be called on anything that might fail for any reason
        other than dbus being unreliable, and it will definitely spam the
        log on every failure so that we can't end up with something like
        this running in the background forever without knowing about it.
        """
        state = 'idle'
        def callback(result=None, error=None):
            nonlocal state
            if error:
                self._log.error("Error in %s: %s", func.__name__, error)
                state = 'idle'
            else:
                state = 'done'
        kwargs['callback'] = callback
        while True:
            state = 'pending'
            func(*args, **kwargs)
            while state == 'pending':
                yield
            if state != 'idle': break
            yield

    def _get_interface(self, system, interface, path):
        """
        Return a wrapped dbus interface which accepts a second set of kwargs.
        So wrapped_interface(arg1, arg2, kwarg1=v1)(kwarg2=v2, kwarg3=v3) is
        equivalent to interface(arg1, arg2, kwarg1=v1, kwarg2=v2, kwarg3=v3)

        We also wrap the interfaces' connect_to_signal method with something
        that handles the thread queueing logic needed for dbus callbacks.
        """
        class InterfaceWrapper(object):
            def __init__(self, interface, dbus_manager):
                self._interface = interface
                self._dbus_manager = dbus_manager
            def __getattr__(self, name):
                attr = getattr(self._interface, name)
                if not callable(attr): return attr
                def func1(*args, **kwargs1):
                    def func2(**kwargs2):
                        kwargs1.update(kwargs2)
                        return attr(*args, **kwargs1)
                    return func2
                return func1
            def connect_to_signal(self, name, handler):
                def queue_handler(*args, **kwargs):
                    def generator_wrapper():
                        if False: yield
                        handler(*args, **kwargs)
                    self._dbus_manager._queue.push_back(generator_wrapper())
                return self._interface.connect_to_signal(name, queue_handler)
        proxy = self._bus.get_object(
            system, path,
            introspect=False,
            follow_name_owner_changes=True,
        )
        interface = dbus.Interface(proxy, interface)
        return InterfaceWrapper(interface, self)

    def _install_signal_handlers(self):

        def network_state_change(prop, value):
            if prop != 'State': return
            # _network_state uses the _dbus_jsonrpc_generator decorator,
            # so we have to invoke it with a jsonrpc callback
            def callback(result=None, error=None):
                if not error and result:
                    self._server.network_state_change(full_state=result)
                # Nothing to do if we have an error (already logged)
            self._network_state(callback=callback)
        self._connman.connect_to_signal('PropertyChanged', network_state_change)

        def wifi_tech_change(prop, value):
            self._log.info("wifi technology change: {}->{}".format(prop,
                                                                   value))
            if prop == 'Tethering':
                self._tethering = bool(value)
                partial_state = {'tethering': self._tethering,
                                 'tether_name': self._ap_name}
            elif prop == 'Powered':
                wifi = 'enabled' if value else 'disabled'
                partial_state = {'wifi': wifi}
                # The state encoded in self._wifi_enabled should latch - if
                # we ever are online, we should stay that way forever unless
                # explicitly disabled.
                if value:
                    self._wifi_enabled = True
            else:
                self._log.warning("Property {} unhandled, no notification"\
                                  .format(prop))
                return
            self._server.network_state_change(partial_state=partial_state)
        self._wifi_tech.connect_to_signal('PropertyChanged', wifi_tech_change)

        # Feed the current state to the server
        network_state_change('State', None)

def _dbus_generator_backend(func, self, args, kwargs, callback, dbus_init):
    """
    The actual implementation of _dbus_jsonrpc_generator, whose docstring
    you should read first.  This function calls func(*args, **kwargs) and
    then iterates the returned generator to completion.  However, every
    time the generator yields, it is assumed to have yielded a dbus method
    which needs to be called with completion callbacks.  Once this method
    has been invoked, the generator does not get iterated again until the
    reply_handler callback is invoked.  If the reply included a return
    value, it is sent to the generator.

    When the generator completes, we invoke the jsonrpc style callback to
    pass back the result.  If the generator raises an exception, we convert
    it to an appropriate jsonrpc error dict to pass to the callback.  If
    dbus returns an exception via the error_handler, we first give the
    generator a chance to handle it via throw(), then pass a jsonrpc error
    to the callback.

    Note that this depends on self being an instance of DBusManager.
    """
    dbus_error = {'code' : 99, 'message' : 'dbus method error'}
    if not dbus_init and not self._initialized:
        dbus_error['data'] = 'dbus not initialized'
        if callback: callback(error=dbus_error)
        return
    if not self._glib_running:
        # If we try to run our generator, our dbus calls will never return
        dbus_error['data'] = 'glib main loop terminated'
        if callback: callback(error=dbus_error)
        return
    generator = func(self, *args, **kwargs)
    def gen_next(*args, exc=None):
        try:
            if exc:
                self._log.error("Dbus exception: {} in {}".format(repr(exc),
                                                                  func.__name__))
                method = generator.throw(exc)
            elif len(args) == 0:
                method = next(generator)
            elif len(args) == 1:
                method = generator.send(args[0])
            else:
                method = generator.send(args)
            method(reply_handler=queue_reply_handler,
                   error_handler=queue_error_handler)
        except StopIteration as e:
            if callback: callback(e.value)
        except JsonRpcException as e:
            if callback: callback(error=kaiten.jsonrpc.exc_to_error(e))
        except dbus.DBusException as e:
            # These errors happen a lot during initialization, but they _should_
            # cause calls to fail so they can be retried if desired
            dbus_error['data'] = str(e)
            if callback: callback(error=dbus_error)
        except Exception as e:
            self._log.error("Uncaught exception in kaiten.dbus executing {}: {}"\
                            .format(func.__name__, repr(e)))
            error = {'code': -32603, 'message': 'internal error'}
            if callback: callback(error=error)
    def reply_handler(*args):
        if False: yield
        gen_next(*args)
    def error_handler(e):
        if False: yield
        gen_next(exc=e)
    def queue_reply_handler(*args):
        self._queue.push_back(reply_handler(*args))
    def queue_error_handler(e):
        self._queue.push_back(error_handler(e))
    gen_next()
