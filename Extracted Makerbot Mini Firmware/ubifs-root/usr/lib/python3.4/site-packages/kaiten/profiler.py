"""
An optional profiler for our task scheduler
"""

import datetime
import logging
import weakref

import kaiten.constants
import kaiten.log

class ProfileTask(object):
    """
    Stores a list of information pertaining to a given generator.
    """
    def __init__(self, name, expected_run_time=None):
        self.name = name
        self._expected_run_time = expected_run_time
        self.reset()

    def reset(self):
        self._time = datetime.timedelta(0)
        self._count = 0
        self._max_d = datetime.timedelta(0)
        self._extra_params = {}

    def accumulate(self, duration):
        self._count += 1
        self._time += duration
        if duration > self._max_d:
            self._max_d = duration

    def get_time(self):
        return self._time

    def ran_long(self, duration):
        # if expected_run_time is None always return false because
        # we can't define what "long" is
        return (self._expected_run_time is not None and
                duration > self._expected_run_time)

    def extra_param(self, name, param):
        """
        Accumulate information about an extra parameter. Specifically,
        keep track of a running sum and count of the parameters
        passed in for a given name so we can display an average.
        """
        acc = self._extra_params.setdefault(name, [0, 0])
        acc[0] += param
        acc[1] += 1

    def get_stats(self, duration):
        if not self._count: return None
        extras = self._extra_params.items()
        return (
            self.name,
            self._time * 100 / duration,
            self._time.total_seconds() * 1000 / self._count,
            self._max_d.total_seconds() * 1000,
            ', '.join('%s: %.1f'%(k, v[0]/v[1]) for k, v in extras)
        )


class Profiler(object):
    """
    Queues up various system events, and when iterated, logs
    basic profiling information about these events.
    """
    def __init__(self, server, full_logging):
        self._server = server
        self._log = kaiten.log.getlogger(self)
        self._full_logging = full_logging
        self._duration = datetime.timedelta(seconds=10)
        if self._full_logging: self._init_log()
        self._idle_task = ProfileTask('<IDLE>')
        self._tasks = weakref.WeakKeyDictionary()
        self._tasks[self._idle_task] = self._idle_task
        self._seen_tasks = set()
        self._last_tick = None
        self._task = None
        self._init_formatting()

    def _init_log(self):
        """ Create a separate log for the profiler """
        handler = logging.handlers.RotatingFileHandler(
            kaiten.constants.profiling_file,
            maxBytes=1024*1024, backupCount=3,
        )
        self._prof_log = logging.getLogger('PROFILER')
        self._prof_log.propagate = False
        self._prof_log.setLevel('INFO')
        self._prof_log.addHandler(handler)

    def _init_formatting(self):
        self._name_length = 24
        self._fmt = '%{}s %5.1f%% %8.2f %8.2f  %s'.format(self._name_length)
        self._header_suffix = '  USAGE    D_AVG    D_MAX'

    def tick(self, now=None):
        """
        This should be called whenever the scheduler is switching from
        one task to another.  The scheduler may specify when the switch
        occurs with the argument now.
        """
        if not now:
            now = datetime.datetime.utcnow()
        if self._last_tick:
            task = self._task if self._task else self._idle_task
            duration = now - self._last_tick
            if task.ran_long(duration):
                self._log.warning("Unusually long generator %s lasted %s",
                    task.name, duration)
            if self._full_logging:
                task.accumulate(duration)
        self._task = None
        self._last_tick = now

    def log_contract(self, contract):
        self._log_task(contract, self._contract_info)

    def log_io_generator(self, io_generator):
        self._log_task(io_generator, self._io_info)

    def log_extra_param(self, name, param):
        """
        Store the value of a parameter so that a running average will
        be displayed by the profiler.  The param is attached to the
        current task, and this must be called after the task has been
        logged.
        """
        if self._task:
            self._task.extra_param(name, param)

    def _contract_info(self, contract):
        return type(contract).__name__, contract.expected_run_time()

    def _io_info(self, io_generator):
        try:
            client = self._server._clients[io_generator.key]
            name = client.get_log_name()
        except Exception:
            name = type(io_generator).__name__
        return name, io_generator.expected_run_time()

    def _log_task(self, key, info_fn):
        if key not in self._tasks:
            name, expected_run_time = info_fn(key)
            if len(name) > self._name_length:
                name = name[:self._name_length-3] + '...'
            self._tasks[key] = ProfileTask(name, expected_run_time)
        self._task = self._tasks[key]
        if self._full_logging:
            self._seen_tasks.add(self._task)

    def __next__(self):
        """ Only iterated when self._full_logging is True """
        timestamp = str(self._last_tick)[:self._name_length]
        log_msg = ['', timestamp + self._header_suffix]
        tasks = list(self._seen_tasks) + [self._idle_task]
        tasks.sort(key=ProfileTask.get_time, reverse=True)
        for task in tasks:
            stats = task.get_stats(self._duration)
            if stats:
                log_msg.append(self._fmt % stats)
            task.reset()
        self._prof_log.info('\n'.join(log_msg))
        self._seen_tasks.clear()
        if self._task:
            self._seen_tasks.add(self._task)

    def contract_duration(self):
        return self._duration

    def expected_run_time(self):
        return datetime.timedelta(seconds=kaiten.constants.normal_generator_time)
