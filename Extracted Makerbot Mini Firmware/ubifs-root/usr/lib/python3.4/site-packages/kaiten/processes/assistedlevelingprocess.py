"""A Kaiten process for assisted leveling

AssistedLevelingProcess implements Assisted Leveling for the birdwing. It finds a
Z-position in the middle of the nozzle's travel, tries to move to that z-position over
each of the supplied leveling knobs, and through user input and feedback makes sure
that the build plate at that location is in the same place as the center when the
z position is the same.

This process runs its own homing for x,y, and z. It should probably be done without
filament loaded. It communicates with connected clients through the status dictionary.

The general flow is this:
- Home XY
- Move to center, home Z
- Move to the middle of the nozzle stroke and derive a slope.
- Use the slope to figure out which direction the HES changes as the nozzle moves.
- Cache the HES reading of this point, and set the Z-position of this point to 0.
- For each leveling knob:
   + Move to the knob
   + Move the build plate up until either the Bronx senses a collision or you hit 0
   + If you sensed a collision, move the build plate up until you reach 0 or your
     cached midpoint. If you reach 0, the build plate is too low. If you hit your
     cached midpoint at 0, you're ok, and if you hit your cached midpoint before
     0, the build plate is too high.
   + If the build plate is too high, move to a position defined by reflecting the
     current knob's position across the origin and redo the previous step
   + Now you're either too low, or done. If you're done, exit.
   + If you're too low, enter a user feedback loop (method active_level). Send
     different signals to connected clients if you're too low, too high, or ok; if
     you're, enforce a five-second timeout during which you must be ok before moving
     on.
"""
import logging
import datetime
import math
import os
import sys
import time

import kaiten.activities
import kaiten.enum
import kaiten.error

from kaiten.processes.process import Process
from kaiten.processes.zcalibrationprocess import ZCalibrationProcess

class AssistedLevelingProcess(Process):
    """Class implementing the leveling process.

    Override basically every method of interest in the superclass. Also, do a bunch
    of hacks to get the homing process to work for you.
    """
    def __init__(self, machine_manager, pymach, config):
        super(AssistedLevelingProcess, self).__init__(machine_manager,
                                                      pymach, config)
        self._tool_index = self._config["active_tool"]
        self._z_homed = False
        self._gantry_homed = False
        self._heated = False
        self._level_state = 0
        self._speed = 100
        self._threshold = self._config["leveling"]["threshold"] # mm
        self._assisted_level_steps = kaiten.enum.enum("assisted_level_steps",
            "preheating",
            "cooling",
            "initializing",
            "clear_filament",
            "remove_filament",
            "buildplate_instructions",
            "checking_first_point",
            "leveling_front",
            "leveling_front_inverse",
            "leveling_side",
            "leveling_side_inverse",
            "calibrating_z_offset",
            "finishing_level",
            "preheating_unloading",
            "unloading_filament",
            "done_coarse_level",
            "final_auto_level",
            "auto_level",
            "lock_knobs")
        self._assisted_level_states = kaiten.enum.enum("assisted_level_states",
                                                       "low",
                                                       "high",
                                                       "ok")
        self._assisted_level_knobs = kaiten.enum.enum("assisted_level_knobs",
                                                      "front",
                                                      "side")
        self._assisted_level_modes = kaiten.enum.enum("assisted_level_modes",
                                                      "standard",
                                                      "inverse")
        self._combinatoric_steps_formulae = ["checking_{side}_level",
                                             "tighten_{side}_knob",
                                             "leveling_{side}_{mode}_{state}"]
        self._combinatoric_steps = set()
        for formula in self._combinatoric_steps_formulae:
            for state in self._assisted_level_states:
                for knob in self._assisted_level_knobs:
                    for mode in self._assisted_level_modes:
                        self._combinatoric_steps.add(formula.format(side=knob,
                                                                    state=state,
                                                                    mode=mode))
        self._assisted_level_steps.extend(*[s for s in self._combinatoric_steps])
        
        self._mag_settings = self._config["home"]["mag_sense"]
        self._unloading_was_performed = False

        self.ignorable_toolhead_errors.add(kaiten.error.door_interlock_triggered)
        self.ignorable_toolhead_errors.add(kaiten.error.no_filament)
        self.ignorable_toolhead_errors.add(kaiten.error.filament_slip)

        log_path = kaiten.constants.leveling_log_file
        os.makedirs(os.path.dirname(log_path), exist_ok=True)
        self._hes_assisted_log = open(log_path, 'wb')
        self._seated_hes = None
        self._set_requires_heating(True)

        self._waiting_for_continue = False

        #Dynamic steps that the process can continue on
        self._continuable_steps = []

    def _do_initialize(self):
        self._start_time = datetime.datetime.utcnow()
        self._log.info("In init of assisted_level")

        self._machine_manager._server.mixpanel_event("assisted_leveling_start")

        self._step_change(self._assisted_level_steps.initializing)

        # make sure we don't have filament loaded for best results
        if not self._pymach.is_tool_connected(self._tool_index):
            yield kaiten.error.no_tool_connected
        if self._pymach.get_filament_presence(self._tool_index):
            self._step_change(self._assisted_level_steps.clear_filament)
            yield from self._wait_for_continue()
            yield from self._do_filament_unload()
            # After unloading request user to remove filament
            self._step_change(self._assisted_level_steps.remove_filament)
            yield from self._wait_for_continue()
            self._unloading_was_performed = True
            self._step_change(self._assisted_level_steps.initializing)


        # move z-axis away the move-away distance
        yield from self._ensure_move_axis('z',
            self._config["home"]["move_away_mm"]["z"],
            self._config["home"]["rate_mm_per_s"]["z"],
            True)
        yield from self._pymach.set_position(2, 0)
        yield from self._pymach.set_position(3, 0)

        self._log.debug("assisted leveling homing xy")
        yield from self._create_and_run_activity(
            kaiten.activities.GantryHomeActivity,
            self._environment)
        self._gantry_homed = True
        # make sure we are relatively cooled off since HES sensor
        # is sensitive to temperature changes,
        # or at least maintaining temperature
        current_temperature = self._pymach.get_temperature(0)

        #If the bot at hand is set to hot level we should preheat here.
        if self._config['leveling'].get('Level_Hot', False):
            yield from self._ensure_tool_attached()
            target_temp = self._config["home"]["temperature"]
            if current_temperature > target_temp:
                self._step_change(self._assisted_level_steps.cooling)
            else:
                self._step_change(self._assisted_level_steps.preheating)
            yield from self._heat_to_temperature([target_temp],
                                                 wait=True,
                                                 wait_check=[True])
            self._heated = True
            self.overrides_heater_watchdog = True
            self._step_change(self._assisted_level_steps.initializing)
        else:
            if current_temperature > self._config["leveling"]["cool_temp_c"]:
                self._step_change(self._assisted_level_steps.cooling)
                yield from self._pymach.cool()
                yield from self._pymach.toggle_fan(0, True)
                while self._pymach.get_temperature(0) \
                       > self._config["home"]["cool_temp_c"]:
                    yield
                yield from self._pymach.toggle_fan(0, False)
                self._step_change(self._assisted_level_steps.initializing)
            else:
                # cool in case we were heating up
                yield from self._pymach.cool()
            yield from self._ensure_tool_attached()

        if self._parked():
            yield from self._unpark()

        # Do a coarse z-home
        # We should have the moose style leveling home in the middle-ish
        fixed_x = self._config["leveling"]["positions"]["fixed"]["x"]
        fixed_y = self._config["leveling"]["positions"]["fixed"]["y"]

        yield from self._create_and_run_activity(
            kaiten.activities.ZHomeActivity,
            home_position=[fixed_x, fixed_y],
            do_fine_home=False, park=False)

        self._z_homed = True

        # Display the assisted leveling animation
        self._step_change(self._assisted_level_steps.buildplate_instructions)
        yield from self._wait_for_continue()
        self._step_change(self._assisted_level_steps.checking_first_point)

    def unload_filament(self, tool_index=0, error_dict=None):
        self.tasklets = self._do_filament_unload();

    def _do_filament_unload(self):
        with self._machine_manager.light_context("print"):
            self._step_change(self._assisted_level_steps.preheating_unloading)
            self._cancellable = True
            # TODO: handle multiple extruders more elegantly
            temperature_settings =\
                [self._config["toolheads"]["bronx"]["heater"]["print_temperature_default"]]
            yield from self._pymach.load_temperature_settings([temperature_settings[0]])
            yield from self._pymach.heat()
            yield from self._pymach.wait_for_heaters_at_target(10,
                                                               [True]*self._config['toolhead_count'])
            #if unload:
            self._cancellable = False
            self._step_change(self._assisted_level_steps.unloading_filament)
            yield from self._create_and_run_activity(
                kaiten.activities.UnloadFilamentActivity)
            yield from self._do_filament_cleanup()

    def _do_filament_cleanup(self):
        #If this bot is not set to level the plate whilst hot, we should cool now
        if not self._config['leveling'].get('Level_Hot', False):
            yield from self._pymach.cool()
        self._cancellable = True
        yield

    def _do_cancel(self, error_code=None):
        yield from self._pymach.motor_abort()
        yield kaiten.error.ok

    # TODO Let's clean this method up, it doesn't do a bunch but is immense
    def _is_platform_below_toolhead(self):
        """Determines whether the platform is above or below the tip of the nozzle.

        Because of the use of self._sign, we can assume that in HES ticks:
        - 0 is around where the nozzle is seated
        - As the nozzle is depressed, the readings will get more positive
        - Midpoint HES is therefore a positive number
        """
        yield from kaiten.util.sleep(2)
        #subtract to move from current frame to original frame and make sign positive
        self._log.debug("ipbt: about to sample, target midpoint hes {0},"\
                       "hes threshold {1}"\
                       .format(self._midpoint_hes, self._hes_threshold))
        self._hes_assisted_log.write(bytes("_is_platform_below_toolhead\n",
                                           'UTF-8'))
        self._hes_assisted_log.write(bytes('hes_target:{0}\nhes_threshold:{1}\n'\
                                           .format(self._midpoint_hes, self._hes_threshold),
                                           'UTF-8'))
        self._hes_assisted_log.write(bytes('zpos_threshold:{0}\n'\
                                           .format(self._threshold),
                                           'UTF-8'))

        (current_mag, throwaway_jitter)  = yield from self._sample_hes()
        z_loc = self._pymach.get_move_buffer_position()[2]
        self._hes_assisted_log.write(bytes("zpos:{0}\n"\
                                           .format(z_loc),
                                           'UTF-8'))
        if self._seated_hes:
            current_mag -= self._seated_hes
        current_mag *= self._sign
        self._log.debug("ipbt: z_loc {0}, threshold {1},"\
                       "hes {2}, midpoint {3}, jitter {4}"\
                       .format(z_loc, self._threshold, current_mag,\
                               self._midpoint_hes, throwaway_jitter))

        # Since position gets more negative as you move up, and find_knob_z only moves
        # until it reaches 0, if our current location is less than the millimetric
        # threshold (and by definition greater than 0) then the collision event never
        # fired and we are where we expect the build plate to be. Since our midpoint
        # is usually going to be higher than the collision threshold, this will usually
        # mean that the build plate is below level.
        if z_loc <= self._threshold:
            # This case checks if we're at 0 and nozzle is below its midpoint (or not
            # touched), including the threshold. Recall that because of the sign,
            # the mag should be more positive the more the nozzle is depressed.
            # If the nozzle is not yet depressed to its midpoint, the build plate
            # is below the nozzle.
            if current_mag < (self._midpoint_hes - self._hes_threshold):
                self._log.debug("ipbt: stopped at 0, build plate below, "\
                               "hes {0}, midpoint {1}, threshold {2}, seated {3}"\
                               .format(current_mag,\
                                       self._midpoint_hes,\
                                       self._hes_threshold,\
                                       self._seated_hes))
                return "below"
            # This case checks if we are above the midpoint (pretty unlikely since the
            # collision event should have triggered first)
            # but if it's true, then the build plate is above the nozzle.
            elif current_mag > (self._midpoint_hes + self._hes_threshold):
                self._log.debug("ipbt: stopped at 0, build plate above, "\
                               "hes {0}, midpoint {1}, threshold {2}, seated {3}"\
                               .format(current_mag,\
                                       self._midpoint_hes,\
                                       self._hes_threshold,\
                                       self._seated_hes))

                return "above"
            # This case checks if we stopped right where we think we should have.
            # This also is pretty unlikely since the midpoint is usually larger than
            # the Bronx collision event threshold, but if it does happen then we get
            # to short circuit. midpoint-threshold < current < midpoint+threshold.
            else:
                self._log.debug("ipbt: stopped at 0, build plate in place,"\
                               " hes {0}, midpoint {1}, threshold {2}, seated {3}"
                               .format(current_mag,\
                                       self._midpoint_hes,\
                                       self._hes_threshold,\
                                       self._seated_hes))
                return "ok"
        # This case means the collision event fired before we got inside our threshold.
        # Again because the Bronx collision threshold is lower than the midpoint
        # threshold, we have to check if we have room to move down.
        else:
            # This case checks if, even though we stopped, the nozzle isn't at the
            # midpoint yet. This is actually pretty likely. In this case, we can
            # creep the build plate up further and further until we get to the
            # threshold.
            if current_mag < self._midpoint_hes+self._hes_threshold:
                self._log.debug("ipbt: stopped early @ {0}, got room, "\
                               "current {1}, midpoint {2}, threshold {3}, seated {4}"
                               .format(z_loc,\
                                       current_mag,\
                                       self._midpoint_hes,\
                                       self._hes_threshold,\
                                       self._seated_hes))
                # We can creep up until we get to the midpoint.
                # We make sure to never go lower than the positive threshold
                # so we don't creep forever. But we use the positive threshold.
                # If at that point we're still
                # under our threshold, we stopped way early and the build plate is in
                # fact below the nozzle still.
                while current_mag < (self._midpoint_hes+self._hes_threshold)\
                      and (self._pymach.get_move_buffer_position()[2]\
                           > self._threshold):
                    yield from self._ensure_move_axis(2,
                                                      -self._threshold/2,
                                                      10,
                                                      True)
                    self._hes_assisted_log\
                        .write(bytes("_is_platform_below_toolhead\n", 'UTF-8'))
                    (current_mag, throwaway_jitter)\
                        = yield from self._sample_hes()
                    self._hes_assisted_log.write(bytes('zpos:{0}\n'\
                                                       .format(self._pymach.get_move_buffer_position()[2]),
                                                       'UTF-8'))
                    if self._seated_hes:
                        current_mag -= self._seated_hes
                    current_mag *= self._sign
                self._log.debug("ipbt: moved up, ended at {0} with hes {1}, "\
                               "midpoint {2}, threshold {3}"\
                               .format(self._pymach.get_move_buffer_position()[2],\
                                       current_mag,
                                       self._midpoint_hes,
                                       self._hes_threshold))
                # If we never found the midpoint in our creep
                if math.fabs(self._pymach.get_move_buffer_position()[2])\
                   <= self._threshold:
                    # If we are still below the midpoint, then we are below the nozzle
                    if current_mag < (self._midpoint_hes - self._hes_threshold):
                        self._log.debug("ipbt :Still under at 0, current {0}, "\
                                       "midpoint {1}, threshold {2}, seated {3}"
                                       .format(current_mag, self._midpoint_hes,
                                               self._hes_threshold,
                                               self._seated_hes))
                        return "below"
                    # If we are within our threshold, then we're done
                    else:
                        self._log.debug("ipbt: within threshold at 0"\
                                       ", current {0}, midpoint {1}, threshold {2}"\
                                       "seated {3}"
                                       .format(current_mag, self._midpoint_hes,
                                               self._hes_threshold,
                                               self._seated_hes))
                        return "ok"
                # Our while loop ended when it reached the top of our
                # threshold range, and we're above  the millimietric threshold:
                # we are too high.
                else:
                    self._log.debug("ipbt: above")
                    return "above"
            # In this case, we stopped early because we hit 0, but stopped slow enough
            # that we're reading above the threshold
            else:
                self._log.debug("ipbt: stopped @ {0}, too high, "\
                               "current {1}, midpoint {2}, threshold {3}, seated {4}"
                               .format(z_loc,\
                                       current_mag,\
                                       self._midpoint_hes,\
                                       self._hes_threshold,\
                                       self._seated_hes))
                return "above"

    def _prep_extruder(self, threshold=None, position='fixed'):
        """Perform the initial setup for levelling - home Z, get a slope, etc.

        This actually handles everything that happens over the centerpoint of the
        build platform. It homes, gets a slope, determines the sign of the slope,
        and caches the midpoint reading.
        """
        hes_min_value = 10000
        pos_x = self._config["leveling"]["positions"][position]["x"]
        pos_y = self._config["leveling"]["positions"][position]["y"]
        yield from self._pymach.move([pos_x, pos_y, 0, 0], self._speed,
                                     [False, False, False, True])
        distance = self._config["leveling"]['slope_sample_distance']
        yield from self._ensure_move_axis(2, -distance, 10, True)
        yield from kaiten.util.sleep(1)
        self._hes_assisted_log.write(bytes("_prep_extruder\n", 'UTF-8'))
        (bottom, jitter_throwaway) = yield from self._sample_hes()
        self._hes_assisted_log.write(bytes('zpos:{0}\n'\
                                           .format(self._pymach.get_move_buffer_position()[2]),
                                           'UTF-8'))

        # If we are starting to prep and are already past the min value
        # we should back off and reapproach
        while math.fabs(bottom) > hes_min_value:
            self._log.debug("Begin prep extruder with hes too high (at {0}), moving down {1}mm".format(bottom, distance))
            yield from self._ensure_move_axis(2, distance, 10, True)
            yield from kaiten.util.sleep(1)
            (bottom, jitter_throwaway) = yield from self._sample_hes()

        self._midpoint_hes = 0
        blist = []
        while math.fabs(self._midpoint_hes) < hes_min_value:
            self._log.debug("Moving up {0}mm, current hes {1} jitter {2}"\
                           .format(distance, bottom, jitter_throwaway))
            yield from self._ensure_move_axis(2, -distance, 10, True)
            yield from kaiten.util.sleep(1)
            self._hes_assisted_log.write(bytes("_prep_extruder: while loop\n", 'UTF-8'))
            (self._midpoint_hes, jitter_throwaway) \
                = yield from self._sample_hes()
            self._hes_assisted_log.write(bytes('zpos:{0}\n'\
                                               .format(self._pymach.get_move_buffer_position()[2]),
                                               'UTF-8'))
            if math.fabs(self._midpoint_hes) < hes_min_value:
                bottom = self._midpoint_hes
                blist.append(bottom)

        slope = (self._midpoint_hes-bottom)/distance
        self._sign = math.copysign(1, slope)

        self._log.debug("After move, midpoint hes {0}, saw hes vals {1}"\
                       .format(self._midpoint_hes, blist))
        if (threshold is None):
            self._hes_threshold = math.fabs(slope*self._threshold)
            self._log.debug("with slope {0} and threshold {1} calculated hes thresh {2}, jitter {3}"\
                       .format(slope,\
                               self._threshold,\
                               self._hes_threshold,
                               jitter_throwaway))
        else:
            self._hes_threshold = math.fabs(slope*threshold)
            self._log.debug("with slope {0} and threshold {1} calculated hes thresh {2}, jitter {3}"\
                       .format(slope,
                               threshold,\
                               self._hes_threshold,
                               jitter_throwaway))

        #rebase_hes adds to go from the original frame to the current frame
        #so we subtract here to move midpoint_hes into the original frame.
        #If we don't have a seated_hes, we haven't yet rebased, and therefore are still
        #in the original frame.
        if self._seated_hes:
            self._midpoint_hes -= self._seated_hes
        self._log.debug("seated HES {0}"\
                       .format(self._seated_hes))
        self._log.debug("Midpoint hes reframed to original, now {0}"\
                       .format(self._midpoint_hes))
        self._midpoint_hes *= self._sign
        yield from self._pymach.set_position(2, 0)
        yield from self._ensure_move_axis(2, 10, 10, False)


    def _move_to_knob(self, side:str, invert:bool):
        """
        Moves nozzle above the leveling position
        """
        if self._parked():
            yield from self._unpark()
        knobs = self._config['leveling']['positions']
        x_cor = knobs[side]["x"]
        y_cor = knobs[side]["y"]
        if invert:
            x_cor = -(x_cor - knobs['fixed']['x'])
            y_cor = -(y_cor - knobs['fixed']['y'])
        yield from self._pymach.set_position(3, 0)
        yield from self._ensure_move([x_cor, y_cor, 10, 0], self._speed,
                                     [False, False, False, False])

    def _active_level(self):
        """Run the user feedback loop with connected clients.

        Get HES readings and give feedback to the UI based on them. This can be a bit
        slow because of lag issues with the different layers of the system talking to
        each other, but what can you do.
        """
        self._hes_assisted_log.write(bytes("_active_level\n", 'UTF-8'))
        self._hes_assisted_log.write(bytes('hes_target:{0}\nhes_threshold:{1}\n'\
                                           .format(self._midpoint_hes, self._hes_threshold),
                                           'UTF-8'))

        #subtract seated_hes to move the mag from current frame to original frame
        (current_mag, throwaway_jitter)  = yield from self._sample_hes(0.33)
        self._hes_assisted_log.write(bytes('zpos:{0}\n'\
                                           .format(self._pymach.get_move_buffer_position()[2]),
                                           'UTF-8'))
        val = current_mag
        if self._seated_hes:
            val -= self._seated_hes
        val *= self._sign
        string = "mag {0} target {1} bounds {2}".format(val,
                                                        self._midpoint_hes,
                                                        self._hes_threshold)
        if val < (self._midpoint_hes - self._hes_threshold):
            yield from self._handle_led(False)
            string += ' (lo)'
            self._log.debug(string)
            return 'low'
        elif val > (self._midpoint_hes + self._hes_threshold):
            yield from self._handle_led(False)
            string += " (hi)"
            self._log.debug(string)
            return 'high'
        else: # midpoint ~= val
            yield from self._handle_led(True)
            string += "(ok)"
            self._log.debug(string)
            return 'ok'

    def _do_cleanup(self):
        self._machine_manager._server.mixpanel_event("assisted_leveling_end")
        self._log.info("in _do_cleanup of assistedlevelingprocess.py")
        self._step_change(self._assisted_level_steps.finishing_level)
        yield from self._pymach.set_position(3,0)
        yield from self._pymach.toggle_fan(0, False)
        if self._z_homed:
            yield from self._ensure_move_axis(2, self._config['park']['z'],
                                              self._config["max_speed_mm_per_second"]['z'],
                                              relative=False)
        if self._gantry_homed:
            yield from self._xypark()
        if self._heated:
            yield from self._pymach.cool()
        self._pymach.set_toolhead_idle_update_period(0, 0.5)
        yield from self._pymach.shutdown()

        self._hes_assisted_log.flush()
        self._hes_assisted_log.close()
        yield from self._pymach.cool()

    def _level_axis(self, side, find_knob=True):
        """
        Control the general leveling flow, from moving to ending, for a knob pos

        Axis is expected to be a string corresponding to the name of a knob in
        the printer settings file.
        """
        self._log.debug("Leveling {0}".format(side))
        self._step_change(self._assisted_level_steps["checking_%s_level" % (side.lower())])
        yield from self._ensure_move_axis(2, 5, self._speed, False)
        yield from self._move_to_knob(side, False)

        self._step_change(self._assisted_level_steps["checking_%s_level" % (side.lower())])
        #This is basically the Z-homing procedure without centering or setting
        #position find_knob_z is z home but stopping when it gets ton 0 instead
        #of an axis length
        trigger = self._midpoint_hes - self._hes_threshold
        if self._hes_threshold > self._midpoint_hes:
            trigger = self._midpoint_hes
        self._log.debug("finding z = 0.0")
        #Move to 0.0 (height of fixed position) and match the HES value
        yield from self._ensure_move_axis(2, 0.0, self._speed, False)

        self._feedback_mode = 'standard'

        level = False
        level_timeout = datetime.datetime.utcnow()
        check_timeout = False
        (value, jitter) = yield from self._sample_hes()
        self._log.debug("Before active leveling, at 0, hes {} +- {}".format(value, jitter))
        while not level:
            status = yield from self._active_level()
            self._step_change(self._assisted_level_steps["leveling_{0}_{1}_{2}".format(side.lower(),
                                                            self._feedback_mode,
                                                                                       status)])
            if status == 'ok':
                if not check_timeout:
                    #The case where this is the first time we're just right after a reset
                    level_timeout = datetime.datetime.utcnow()
                    check_timeout = True
                elif check_timeout and (datetime.datetime.utcnow()-level_timeout).seconds\
                     > self._config['leveling']['Timeout_Duration']:
                    #The case where we're calling it level
                    level = True
            else:
                #the case where we reset level
                check_timeout = False
            yield
        self._log.debug('finished leveling')

    def _find_elevation_of_points(self, points):
        """
        Finds HES/Zpos values for all points

        This is useful in determining what point to level to as well as
        if we should adjust any of the knobs
        """
        yield from self._pymach.configure_hes(0, 0, 10000)
        points_vals = {}
        lowest_point = None
        for pnt in points:
            yield from self._ensure_move_axis(2, 10, 3, False)
            yield from self._move_to_knob(pnt, False)
            yield from self._pymach.find_knob_z(-10.0, 1.0)
            (hes_val, throwaway) = yield from self._sample_hes()
            current_pos = yield from self._pymach.get_axes_position()
            points_vals[pnt] = {'zloc':current_pos[2], 'hes':math.fabs(hes_val)}
        yield from self._ensure_move_axis(2, 10, 3, False)
        return points_vals

    def _adjust_outlier_points(self, in_points_vals, ref_point):
        """
        Adjust points who's zeroed z position is too far from the ref_point zpos
        """
        points_vals = in_points_vals.copy()
        adjusted = False
        try:
            thumbscrew_thread_pitch =  self._config['leveling']['leveling_bolt_mm_per_turn']
            delta_threshold =\
                self._config['leveling']['outlier_adjust_threshold_mm']
        except KeyError:
            self._log.error('Adjusting by bots thread pitch is not supported.')
            return adjusted

        ref_vals = points_vals[ref_point]
        points_vals.pop(ref_point, None)

        def determine_adjustment(delta_ref):
            if math.copysign(1, delta_ref) == -1:
                return 'low'
            else:
                return 'high'

        for i in points_vals.items():
            p_name = i[0]
            p_dict = i[1]
            # Determine delta of zlocs between the given point and the ref point
            delta_ref = p_dict['zloc'] - ref_vals['zloc']
            adjustments = {'front': 'ok', 'side': 'ok'}
            # If the delta is too large, determine in which direction
            delta_sign = math.copysign(1, delta_ref)
            if delta_sign==1 or math.fabs(delta_ref) >= delta_threshold:
                points_vals[p_name]['level_pos'] = determine_adjustment(delta_ref)
            else:
                points_vals[p_name]['level_pos'] = 'ok'
                self._log.debug("Delta less than the thresh, don't adjust")
                continue

            turns = round(math.floor(abs(delta_ref/thumbscrew_thread_pitch)))

            # If we're too high, we always want to tell the user to tighten so
            # the next step works better
            if delta_sign == 1:
                turns = max(turns, 1)

            adjust_step = 'adjust_knob_{0}_{1}_{2}'.format(
                p_name,
                points_vals[p_name]['level_pos'],
                turns)
            # Add the adjust_knob step string to the continuable_steps list
            # so that kaiten will allow us to call continue_process during
            # this generated step
            self._continuable_steps.append(adjust_step)
            self._step_change(adjust_step)
            adjusted = True
            yield from self._wait_for_continue()
            self._step_change(self._assisted_level_steps.checking_first_point)
            yield from kaiten.util.sleep(1) #Sleep so the user can see the check
            self._continuable_steps.pop() #Pop the adjust_knob step off
        return adjusted

    def _do_leveling(self, threshold=None, fixed_z=None):
        self._step_change(self._assisted_level_steps.checking_first_point)
        yield from self._move_to_knob("fixed", False)
        if None is fixed_z:
            yield from self._pymach.find_knob_z(-10, 1.0)
        else:
            yield from self._pymach.move_axis(2, fixed_z,
                                              10, False)
        yield from self._prep_extruder(threshold, "fixed")

        sides = ('front', 'side')
        for side in sides:
            yield from self._handle_led(False)
            yield from self._level_axis(side)
            self._machine_manager._server.play_buzzer("notify")
            if side == sides[-1]:
                self._step_change(self._assisted_level_steps.final_auto_level)
                yield from self._wait_for_continue()
            else:
                self._step_change(self._assisted_level_steps.auto_level)
                yield from self._wait_for_continue()
            yield from self._handle_led(False)

        yield from self._pymach.move_axis(2, 10, 3, relative=True)
        if self._config['leveling']['lock']:
            self._step_change(self._assisted_level_steps.lock_knobs)
            yield from self._wait_for_continue()

        if self._config['leveling']['calibrate_z']:
            safe = self._config['home'].get('safe_z_home_position', None)
            if safe:
                yield from self._pymach.move([safe['x'], safe['y'], 0, 0], 100,
                                             [False, False, True, True])

            if ZCalibrationProcess.should_calibrate_hot(self._machine_manager, self._config):
                self._step_change(self._assisted_level_steps.preheating)
                temp = [self._config['home']['temperature']]
                yield from self._pymach.load_temperature_settings(temp)
                yield from self._pymach.heat()
                yield from self._pymach.wait_for_heaters_at_target(10,
                   [True]*self._config['toolhead_count'])

            self._step_change(self._assisted_level_steps.calibrating_z_offset)

            if self._config['home']['z_calibration_type'] == 'endstop':
                yield from self._create_and_run_activity(
                       kaiten.activities.EndstopZCalibrationActivity,
                       ZCalibrationProcess.should_use_alternate_home(
                           self._machine_manager, self._config))
            else:
                yield from self._create_and_run_activity(
                      kaiten.activities.ZCalibrationActivity)

    def _do_moose_leveling(self, threshold=None):
        self._pymach.set_toolhead_idle_update_period(0, 0.1)
        points = ["fixed", "front", "side"]
        adjusted = True
        # While the points need adjustment, keep checking them
        while adjusted:
            #Test and list the points from lowest elevation to highest
            points_vals = yield from self._find_elevation_of_points(points)
            self._log.debug("found point vals: {0}".format(points_vals))
            adjusted = yield from self._adjust_outlier_points(
                points_vals, ref_point="fixed")
        yield from self._do_leveling(threshold, points_vals['fixed']['zloc'])


    def _do_general_leveling(self, threshold=None, is_coarse_pass=False):
        self._pymach.set_toolhead_idle_update_period(0, 0.1)
        yield from self._move_to_knob("fixed", False)
        yield from self._pymach.find_knob_z(-10, 1.0)
        yield from self._prep_extruder(threshold, "fixed")
        sides = ("front", "side")
        for side in sides:
            yield from self._handle_led(False)
            yield from self._level_axis(side)
            self._machine_manager._server.play_buzzer("notify")
            if side == sides[-1]:
                #is_coarse_pass will be True if we are using general leveling
                #as a first pass leveling, so we want to let the client know
                #that we are done coarsse leveling but not all leveling
                if is_coarse_pass:
                    self._step_change(self._assisted_level_steps.done_coarse_level)
                    yield from self._wait_for_continue()
                else:
                    self._step_change(self._assisted_level_steps.final_auto_level)
                    yield from self._wait_for_continue()
            else:
                self._step_change(self._assisted_level_steps.auto_level)
                yield from self._wait_for_continue()
            yield from self._handle_led(False)

        if self._config['leveling']['lock']:
            yield from self._pymach.move_axis(2, 10, 3, relative=True)
            self._step_change(self._assisted_level_steps.lock_knobs)
            yield from self._wait_for_continue()

        if self._config['leveling']['calibrate_z']:
            self._step_change(self._assisted_level_steps.calibrating_z_offset)
            yield from self._create_and_run_activity(
                kaiten.activities.ZCalibrationActivity,
                target_hes = self._midpoint_hes)

    def _store_knob_position(self, side, inverted):
        self._log.debug("Getting {0} {1} position"\
                       .format(side, inverted))
        yield from self._pymach.find_knob_z(-10, 1.0)
        self._hes_assisted_log.write(bytes("_store_knob_position\n", 'UTF-8'))
        (average, jitter) = yield from self._sample_hes()
        self._hes_assisted_log.write(bytes('{0}\n'\
                                           .format(self._pymach.get_move_buffer_position()[2]),
                                           'UTF-8'))
        while average*self._sign < self._midpoint_hes:
            yield from self._ensure_move_axis(2, -self._threshold/2,
                                              1.0, True)
            self._hes_assisted_log.write(bytes("_store_knob_position : while loop\n",
                                               'UTF-8'))
            (average, jitter) = yield from self._sample_hes()
            self._hes_assisted_log.write(bytes('zpos:{0}\n'\
                                               .format(self._pymach.get_move_buffer_position()[2]),
                                               'UTF-8'))
        self._log.debug("HES {0} at pos {1}, target {2}"\
                       .format(average*self._sign,
                               self._pymach.get_move_buffer_position()[2],
                               self._midpoint_hes))
        self._side_positions[side][inverted]['pos']\
            = self._pymach.get_move_buffer_position()[2]
        self._side_positions[side][inverted]['mag'] = average

    def _do_run(self):
        if self._config['leveling']['method'] == 'standard':
            yield from self._do_general_leveling()
        elif self._config['leveling']['method'] == 'moose':
            yield from self._do_moose_leveling()
        elif self._config['leveling']['method'] == 'cold':
            yield from self._do_leveling()
        elif self._config['leveling']['method'] == 'two-pass':
            threshold = 0.15
            yield from self._do_general_leveling(threshold, is_coarse_pass=True)
            self._step_change(self._assisted_level_steps.checking_first_point)
            points_vals = yield from self._find_elevation_of_points(['fixed'])
            yield from self._do_leveling(None, points_vals['fixed']['zloc'])
        else:
            yield kaiten.error.default_config_missing_value

    def _handle_led(self, on, overwrite=False):
        if on:
            if not self._config['leveling']['use_toolhead_led']:
                yield self._pymach.set_chamber_blink(0.25)
            else:
                yield from self._pymach.set_led_brightness(0, 255)
        else:
            if not self._config['leveling']['use_toolhead_led']:
                yield self._pymach.set_chamber_blink(0.0)
            else:
                yield from self._pymach.set_led_brightness(0, 0)


    def get_info_dict(self):
        info = {
            'level_state': self._level_state,}
        info.update(super(AssistedLevelingProcess, self).get_info_dict())
        return info

    def contract_duration(self):
        return datetime.timedelta(0, 0, 0, 1)

    def _get_bronx_log(self, duration=None):
        """Monkeypatch the function in activitybase to log the output."""
        sample = yield from super(AssistedLevelingProcess, self)\
            ._get_bronx_log(duration)
        # log the hes readings
        self._hes_assisted_log.write(bytes('hes:{0}\n'.format(sample), 'UTF-8'))
        return sample

    def _rebase_hes(self, trigger=None):
        """Move to a new HES reference frame. Optionally ensure the nozzle is seated.

        @brief This method moves around between HES reference frames. Since we can't
        rely on the nozzle seating itself precisely back to 0 in between operations,
        we need to keep track of exactly where that seat was, even as we command
        the Bronx routine that provides endstop emulation to reset. Call this method
        whenever you need to prime the Bronx to be an endstop instead of using
        Machine.configure_hes raw.

        @param trigger If not None, set the trigger for Bronx endstop emulation to the
        specified value. If None, use the value in the printer settings.

        """
        yield from kaiten.util.sleep(1)

        if self._seated_hes is not None:
            (base_deviation, jitter) = yield from self._sample_hes()
        else:
            self._seated_hes = 0
            base_deviation = 0

        mag_settings = self._config["home"]["mag_sense"]
        self._log.debug("HOME: configuring hes with exponent {0}, threshold {1}"\
                        .format(mag_settings["exponent"], mag_settings["threshold"]))
        if trigger:
            threshold = int(trigger)
        else:
            threshold = mag_settings["threshold"]
        yield from self._pymach.configure_hes(0, mag_settings["exponent"],
                                              threshold)
        while not self._pymach.toolhead_acknowledged_hes(0):
            yield
        self._seated_hes += base_deviation
        self._log.debug("HOME: rebase adds {0} to set seated to {1}"\
                        .format(base_deviation, self._seated_hes))

    def _wait_for_continue(self):
       self._waiting_for_continue = True
       while self._waiting_for_continue:
            yield

    @kaiten.decorator.process_method(["clear_filament",
                                     "remove_filament",
                                     "buildplate_instructions",
                                     "auto_level",
                                     "final_auto_level",
                                     "done_coarse_level",
                                     "lock_knobs",
                                     "tighten_front_knob",
                                     "tighten_side_knob"])
    def continue_process(self):
        self._log.info("in continue process of assistedlevelingprocess.py")
        self._waiting_for_continue = False

    def _callable_methods(self):
        """This override exists so we handle dynamic steps with process methods

        Currently only overrides 'continue_process' allowable steps if
        self._contiuable_steps has the current step in it.
        """
        callable_methods = super(AssistedLevelingProcess, self)._callable_methods()
        # Here we allow certain dynamically generated steps to continue
        if self.step in self._continuable_steps:
            callable_methods['continue_process'] = self.continue_process
        return callable_methods
