"""
Log network stats to a special log
"""

import datetime
import logging
import weakref

import kaiten.constants
from kaiten.generators import IOGenerator

class Event(object):
    """
    Stores running statistics for a single event
    """
    def __init__(self, name):
        self._name = name
        self.count = 0
        self._float = False

    def accumulate(self, value):
        if not isinstance(value, int):
            self._float = True
        if self.count:
            self._max = max((value, self._max))
            self._sum += value
            self._min = min((value, self._min))
        else:
            self._max = value
            self._sum = value
            self._min = value
        self.count += 1

    def getline(self):
        names = self._name.split('\0')
        err = names[1] if len(names) > 1 else ''
        if not hasattr(self, '_min'):
            return '%32s %7d\t\t\t %s\n' % (
                names[0],
                self.count,
                err
            )
        else:
            #TODO: format for floats?
            return '%32s %7d %7d %7d %7d %s\n' % (
                names[0],
                self.count,
                self._min,
                self._sum / self.count,
                self._max,
                err
            )


class Logger(object):
    """ Queues up networking stats, and when iterated, logs them """
    def __init__(self, server):
        self._server = server
        self._duration = datetime.timedelta(minutes=20)
        self._stats = {}
        self._init_log()
        self._name_length = 32

    def _init_log(self):
        """ Create a log handler only for this log """
        self._handler = logging.handlers.RotatingFileHandler(
            kaiten.constants.netlog_file,
            maxBytes=1024*1024, backupCount=3,
        )
        # Hack to make handle.emit(None) just terminate a log entry
        class FakeFormatter:
            def format(*args): return ''
        self._handler.formatter = FakeFormatter()

    def _write_entry(self, stream, stats):
        """
        Generator to write to the log.

        Strictly speaking linux can't prevent us from blocking on
        file writes, but yielding once per line should keep us from
        ever blocking for too long.
        """
        timestamp = (str(datetime.datetime.utcnow())+' '*6)[:self._name_length]
        stream.write('\n%s NR_SAMP    MIN     AVG     MAX\n' % timestamp)
        yield
        for event in stats.values():
            if not event.count: continue
            stream.write(event.getline())
            yield
        # Terminate the log entry
        self._handler.emit(None)

    def event(self, name, value=None, modifiers=(), exc=None):
        """
        Log a named event with an optional data value

        For each event name, the event must be logged either always
        with a value or never with a value.
        """
        event_name = '_'.join([name] + list(modifiers))
        if exc: event_name += '\0' + str(exc)
        event = self._stats.setdefault(event_name, Event(event_name))
        if value is None:
            event.count += 1
        else:
            event.accumulate(value)

    def __next__(self):
        stream = self._handler.stream
        write_generator = self._write_entry(stream, self._stats)
        self._stats = {}
        writer = IOGenerator(write_generator, stream, False, True)
        self._server._iopoll.register(writer)

    def contract_duration(self):
        return self._duration

    def expected_run_time(self):
        return datetime.timedelta(seconds=kaiten.constants.normal_generator_time)
