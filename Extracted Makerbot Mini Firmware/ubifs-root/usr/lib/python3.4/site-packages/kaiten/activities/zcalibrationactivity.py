"""This activity handles Z Calibration.

This calibrates the z offset between the build plate and
 homing location, for machines where these are different.

The bot should be cooled before running this activity.

The bot also needs valid x and y references.
"""

import math

import kaiten.util

from kaiten.activities import ZHomeActivity

class ZCalibrationActivity(ZHomeActivity):

    def __init__(self, machine_manager, pymach, config, *,
        target_hes=None):
        """
        Passing in a target_hes will skip the first part of this activity
        """
        super().__init__(machine_manager, pymach, config)
        self._homed = False
        self._started_home = False
        self._target_hes = target_hes

    def run(self):
        if self._target_hes is None:
            target_hes = yield from self._get_target_hes()
        else:
            target_hes = self._target_hes
        hardpoint_position = yield from self._get_point_position(target_hes)
        self._update_reference_offset(hardpoint_position)

    def cancel(self, error_dict=None):
        if self._started_home and not self._homed:
            mbp = self._pymach.get_move_buffer_position()
            mbp[2] = 0
            yield from self._pymach.set_move_buffer_position(mbp)
        yield from self._pymach.abort()

    def _cleanup(self):
        self._log.info('calibration cleaning up')
        yield from self._pymach.toggle_fan(0, False)

    def _get_target_hes(self):
        fixed = self._config['leveling']['positions']['fixed']
        z_max_speed = self._config['max_speed_mm_per_second']['z']
        z_home_speed = self._config["home"]['rate_mm_per_s']['z']

        self._log.info("fixed {0}".format(fixed))
        yield from self._unpark()
        yield from self._xymove([fixed['x'], fixed['y']])
        yield from self._pymach.configure_hes(0, 0, 4000)
        self._started_home = True
        yield from self._pymach.home_axis(2, z_home_speed)
        self._homed = True
        for i in range(10):
            yield
        (mag, dummy) = yield from self._sample_hes()
        mag = math.fabs(mag)
        self._log.info("After standard home, got hes {0}".format(mag))
        yield from self._pymach.set_position(2,0)
        yield from self._ensure_move_axis(2, 15, z_max_speed, False)
        yield from kaiten.util.sleep(2)
        (lowmag, dummy) = yield from self._sample_hes()
        lowmag = math.fabs(lowmag)
        self._log.info("Nozzle seated to {0}".format(lowmag))
        return mag-lowmag

    def _get_point_position(self, target_hes):
        reference_point = self._config['home']['z_reference_point']
        self._log.info("target is {0}".format(target_hes))
        target_hes = math.fabs(target_hes)
        yield from self._xymove([reference_point['x'], reference_point['y']])
        (base_hes, dummy) = yield from self._sample_hes()
        self._log.info("base before find z is {0}".format(base_hes))
        yield from self._pymach.configure_hes(0, 0, 2000)

        yield from self._pymach.find_knob_z(
            0, self._config["home"]['rate_mm_per_s_fine']['z'])
        yield from kaiten.util.sleep(2)
        (mag, dummy) = yield from self._sample_hes()
        self._log.info('Calibration: find z terminated at z={0} with hes={1}'
                       .format(self._pymach.get_move_buffer_position()[2],
                               mag))
        mag = math.fabs(mag)
        mag += -math.fabs(base_hes)
        if mag < target_hes:
            self._log.info("under, creeping up")
            while mag < target_hes:
                yield from self._ensure_move_axis(
                    2, -self._config['home']['step_size'],
                    self._config['home']['rate_mm_per_s_fine']['z'],
                    True)
                yield from kaiten.util.sleep(2)
                (mag, dummy) = yield from self._sample_hes()
                mag = math.fabs(mag)
                mag -= math.fabs(base_hes)
                z_pos = self._pymach.get_move_buffer_position()[2]
                self._log.info("moved %f, mag %f, target %f",
                               z_pos, mag, target_hes)
            self._log.info('home terminates at pos=%f, mag=%f', z_pos, mag)
        return self._pymach.get_move_buffer_position()[2]

    def _update_reference_offset(self, offset:float):
        update_dict = {'home': {'z_reference_point': {'offset': offset}}}
        kaiten.util.update_calibration_settings(update_dict)
        self._machine_manager._server.reload_config()
