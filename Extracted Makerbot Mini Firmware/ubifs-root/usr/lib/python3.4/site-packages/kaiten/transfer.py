import binascii
import datetime
import os

import kaiten.decorator
import kaiten.log
import kaiten.util
import kaiten.constants

from kaiten.jsonrpc import JsonRpcException

def has_active_transfer(timeout=datetime.timedelta(seconds=10)):
    """
    Determine if we are actively transfering a file.

    It is actually fairly difficult to determine completely accurately
    if we are trasferring a file.  So we just check if we have recently
    sent or received a raw mode packet.  This can give false positives
    if we just finished a transfer or even possibly false negatives.
    So don't use this for anything that has to be very accurate.
    """
    global _last_raw_packet
    try:
        last_raw_packet = _last_raw_packet
    except NameError:
        return False
    if datetime.datetime.utcnow() - _last_raw_packet < timeout:
        return True
    else:
        # Faster to catch the NameError
        del _last_raw_packet
        return False

def _mark_raw_packet():
    global _last_raw_packet
    _last_raw_packet = datetime.datetime.utcnow()

class TransferMethods(object):
    """
    Methods for transferring files over JSONRPC raw mode.  This must
    be instantiated once per JSONRPC connection.
    """
    def __init__(self, server, jsonrpc):
        self._log = kaiten.log.getlogger(self)
        self._server = server
        self._jsonrpc = jsonrpc
        self._open_files = {}
        self._transfer_table = {}

    class Transfer(object):
        """
        Handles a single file transfer.  For writes, a valid length is required.
        We can't turn down an incoming raw data packet, even if we don't have
        anywhere to put this, so we sometimes have to fake this.
        """
        def __init__(self, parent, file_path, block_size=None,
                     do_write=True, length=None, fake=False):
            self.parent = parent
            self._log = parent._log
            self.block_size = block_size
            self.file_path = file_path
            self.do_write = do_write
            self.write_error = None
            self.closed = fake
            if fake: return
            self.crc = binascii.crc32(bytes('', 'UTF-8'))
            if do_write:
                self.written = 0
                self.length = length
                os.makedirs(os.path.dirname(file_path), exist_ok=True)
                try:
                    self.fileio = open(file_path, 'wb')
                except Exception as e:
                    self._log.error('Could not open %s for writing'% file_path)
                    raise JsonRpcException(45, "Open for write failure", file_path)
            else:
                try:
                    self.length = os.stat(file_path).st_size
                    self.fileio = open(file_path, 'rb')
                except Exception as e:
                    self._log.error('Could not open %s for reading'% file_path)
                    raise JsonRpcException(46, "Open for read failure", file_path)

        def write(self, data):
            """ Do not allow errors to be raised here, as it will terminate the
                sending connection.  Instead, set self.write_error so that future
                put_raw calls can raise an appropriate JsonRpcException
            """
            if not self.closed:
                try:
                    self.fileio.write(data)
                    self.written += len(data)
                    self.crc = binascii.crc32(data, self.crc)
                except Exception as e:
                    self._log.error('Transfer encountered a write error on %s',
                                    self.file_path, exc_info=True)
                    self.write_error = e
                    self.close()

        def write_progress(self):
            if self.closed: return
            self.parent._server.transfer_progress(
                self.file_path, int((self.written * 100) / self.length))

        def write_raw(self, length):
            # Rather than log progress on every call to self.write(), we
            # wait to log until we have written out all bytes requested
            while length > 0:
                data = yield
                if length < len(data):
                    self.write(data[0:length])
                    self.write_progress()
                    yield data[length:]
                else:
                    self.write(data)
                    length -= len(data)
            self.write_progress()

        def read(self):
            block = self.fileio.read(self.block_size)
            self.crc = binascii.crc32(block, self.crc)
            return block

        def close(self):
            """ Try to close the file, but don't raise any exceptions """
            self.closed = True
            try:
                self.fileio.close()
            except Exception as e:
                self._log.error('Transfer failed to close %s',
                                self.file_path, exc_info=True)

    @staticmethod
    def _chroot_file_path(file_path):
        return kaiten.util.chroot_path(kaiten.constants.home_dir, file_path)

    def transfer_init(self, file_path, file_id, block_size, do_write, length=None):
        """
        Starts a file transfer.  For writes, a valid length is required.
        """
        file_path = self._chroot_file_path(file_path)

        # First we close out any existing transfers that match this one
        if file_path in self._open_files:
            old_id = self._open_files[file_path]
            self._transfer_table[old_id].close()
            del self._transfer_table[old_id]
            del self._open_files[file_path]
        if file_id in self._transfer_table:
            old_path = self._transfer_table[file_id].file_path
            self._transfer_table[file_id].close()
            del self._open_files[old_path]
            del self._transfer_table[file_id]

        # Create a new transfer
        transfer = self.Transfer(self, file_path, block_size, do_write, length)
        self._transfer_table[file_id] = transfer
        self._open_files[file_path] = file_id

        return True

    def transfer_check(self, transfer, file_id):
        """ If any exceptions were raised during the previous write, clean up
            and reraise the same error.  This is also used to clean up after
            file transfer completion.
        """
        if transfer.closed:
            del self._open_files[transfer.file_path]
            del self._transfer_table[file_id]
            if transfer.write_error:
                try:
                    os.remove(transfer.file_path)
                except Exception as e:
                    pass
                # TODO: raise an appropriate JsonRpcException
                raise transfer.write_error

    @kaiten.decorator.jsonrpc
    def put_init(self, file_path:str, file_id:int, block_size:int, length:int):
        """
        Starts a host to device file transfer.

        @param file_path: Path that the file will be transferred to
        @param file_id: ID for the file being transferred
        @param block_size: Size of the blocks to read
        @param length: Length of the file to be transferred
        """
        self._server.transfer_progress(file_path, 0)
        self.transfer_init(file_path, file_id, block_size, True, length)

    @kaiten.decorator.jsonrpc
    @kaiten.decorator.pass_client
    def get_init(self, file_path:str, file_id:int, block_size:int,
                 do_raw:bool=True, client=None):
        """
        Starts a device to host file transfer.

        @param file_path: Path that the file will be transferred to
        @param file_id: ID for the file being transferred
        @param block_size: Size of the blocks to read
        @param do_raw: Not used
        """
        file_path = self._chroot_file_path(file_path)
        transfer = self.Transfer(self, file_path, block_size, False)

        def get_packet():
            """ Return arguments for a JsonRpc request """
            _mark_raw_packet()
            params = {'id': file_id}
            try:
                data = transfer.read()
            except Exception as e:
                self._log.error('Transfer encountered a read error on %s',
                                file_path, exc_info=True)
                params['crc'] = None
                transfer.close()
                return ('get_term', params, lambda r: None)
            if data:
                params['length'] = len(data)
                return ('get_raw', params, callback, data)
            else:
                params['crc'] = transfer.crc
                transfer.close()
                return ('get_term', params, lambda r: None)

        def callback(response):
            """
            This is already run from the clients send queue, so we
            can bypass make_client_request().
            """
            if 'error' in response:
                self._log.info('Host terminated transfer from %s:\n%r',
                               file_path, response['error'])
                transfer.close()
            else:
                yield from client.jsonrpc.request(*get_packet())

        self._server.make_client_request(client, *get_packet())

    @kaiten.decorator.jsonrpc
    def put_term(self, file_id:int, length:int, crc:int):
        """
        Completes a host to device file transfer.

        @param file_id: File ID of the file being transferred
        @param length: Length of the file being transferred
        @param crc: CRC for the file being transferred
        """
        if not file_id in self._transfer_table:
            raise JsonRpcException(37, 'Unknown file_id', file_id)
        transfer = self._transfer_table[file_id]
        self.transfer_check(transfer, file_id)

        # For now we just ignore length, since if the length is wrong,
        # the crc will also be wrong.
        if transfer.crc != crc:
            self._log.error('put_term: Transfer failed crc check')
            transfer.write_error = JsonRpcException(41,
                "Transfer failed crc check", [transfer.crc, crc])
            self._server.transfer_progress(transfer.file_path, 0, done=True)
        else:
            self._server.transfer_progress(transfer.file_path, 100, done=True)

        # We close out the file transfer with whatever we have written.
        # If our transfer failed, we delete the failed file
        transfer.close()
        self.transfer_check(transfer, file_id)

    @kaiten.decorator.jsonrpc
    @kaiten.decorator.jsonrpc_immediate
    def put_raw(self, file_id:int, length:int):
        """
        Put a file via the raw JSONRPC protocol.

        @param file_id: ID of the file being transferred
        @param length: Length of the file being transferred
        """
        _mark_raw_packet()
        if not file_id in self._transfer_table:
            # We need to receive the bytes so as not to screw up json parsing
            transfer = self.Transfer(self, '<fake>', fake=True)
            self._jsonrpc.set_raw_handler(transfer.write_raw(length))
            raise JsonRpcException(37, 'Unknown file_id', file_id)
        transfer = self._transfer_table[file_id]
        self._jsonrpc.set_raw_handler(transfer.write_raw(length))
        self.transfer_check(transfer, file_id)

    def cancel(self, filepath):
        """
        Cancel an ongoing transfer given its associated filepath.

        This is currently only used internally by print processes that are
        cancelled while a transfer is active. They must cancel the transfer so
        as not to trash future transfers to the same place.
        """
        if filepath not in self._open_files:
            # This transfer was already closed. Since this is most likely due
            # to a race between the client and printprocess cancelling the
            # transfer, and since this is the end state we want anyway, just
            # log instead of raising an error.
            self._log.info("Internal cancellation of already-cancelled transfer"
                           "{0} (current {1})".format(filepath,
                                                      repr(self._open_files.keys())))
            return
        file_id = self._open_files[filepath]
        del self._open_files[filepath]
        del self._transfer_table[file_id]
