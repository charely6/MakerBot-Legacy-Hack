"""
Classes for thingiverse API interactions
"""

import datetime
import dbm.dumb
import json

import kaiten.constants
import kaiten.error
import kaiten.log

class ThingiverseObject:
    """
    This is a base class for a Thingiverse object. The Thingiverse API is
    organized around objects (i.e. prints, users, layouts, etc.). This class
    should be subclassed for each Thingiverse object required.
    """
    def __init__(self, token, server, object_type, config):
        """
        @param object_type: should be the name used for the object in the thingiverse
        API. Then this object can infer the correct endpoint URLs in most
        cases
        @param token: thingiverse access token
        """
        self._log = kaiten.log.getlogger(self)
        self._token = token
        self._server = server
        self._object_type = object_type
        self._attributes = {}
        self._attribute_list = []
        self._id = None
        self._needs_sync = False
        self._error_response = False
        self._config = config

    def create(self, params = None):
        """
        Creates a new thingiverse object
        """
        params = params or {}
        if self._id is not None:
            # by convention, this object should already exist if it has an id
            self._log.info("Create {0} failed, already has ID".format(self._object_type))
            raise kaiten.error.ThingiverseException
        if not self._attribute_check(params):
            self._log.info("Create {0} failed, wrong attributes".format(self._object_type))
            raise kaiten.error.ThingiverseException
        self._attributes.update(params)
        def success_callback(data):
            self._parse_create_response(data)
            if self._needs_sync:
                self.sync()
        self._http_request(
            "/{0}".format(self._object_type),
            "POST",
            params,
            success_callback)

    def check_error_response(self):
        """
        Throw an exception if an error has occured.
        """
        if self._error_response:
            raise kaiten.error.ThingiverseException

    def load_from_id(self, identifier, params=None):
        """
        Loads an existing object from thingiverse
        """
        def success_callback(data):
            self._parse_data(data)
        self._http_request(
            "/{0}/{1}".format(self._object_type, identifier),
            "GET",
            params,
            success_callback)

    def id(self):
        return self._id

    def get(self, attribute, default = None):
        """
        Get an attribute defined in this object's attribute list.
        """
        if attribute in self._attributes:
            return self._attributes[attribute]
        else:
            return default

    def sync(self):
        if self._id is None:
            # need an id to update
            self._log.error("Sync {0} failed, need ID".format(self._object_type))
            raise kaiten.error.ThingiverseException
        def success_callback(data):
            self._needs_sync = False
        # TODO: only patch out of date attributes
        self._http_request(
            "/{0}/{1}".format(self._object_type, self._id),
            "PATCH",
            self._attributes,
            success_callback)

    def update(self, params):
        """
        Updates the remote object and locally cached attributes
        """
        self._needs_synced = True
        if not self._attribute_check(params):
            self._log.error("Update {0} failed, wrong attributes".format(self._object_type))
            raise kaiten.error.ThingiverseException
        self._attributes.update(params)
        self.sync()

    def _parse_create_response(self, json_data):
        data = self._parse_json(json_data)
        if "id" in data:
            self._id = data["id"]
        else:
            self._log.error("Create response missing ID: {0}".format(data))
            self._error_response = True

    def _parse_data(self, json_data):
        data = self._parse_json(json_data)
        if "id" in data:
            self._id = data["id"]
        for attr in self._attribute_list:
            if attr in data:
                self._attributes[attr] = data[attr]

    def _attribute_check(self, attributes):
        for key in attributes.keys():
            if key not in self._attribute_list:
                # bad attribute
                return False
        return True

    def _parse_json(self, data):
        try:
            parsed_data = json.loads(data)
        except ValueError:
            self._log.error("The json dict returned by thingiverse is corrupt: {0}".format(data))
            return {}
        return parsed_data

    def _error_callback(self, **kwargs):
        self._error_response = True

    def _http_request(self, path, verb, params=None, callback=None):
        params = params or {}
        # Security hotfix - do not pass oauth tokens to URLs from the config
        self._server.http_request(kaiten.constants.thingiverse_api_url_default,
                                  path, verb, params=params,
                                  token=self._token, encoding='json',
                                  success_callback=callback,
                                  error_callback=self._error_callback)

class Print(ThingiverseObject):
    """
    Print history object
    """
    def __init__(self, token, server, config):
        super().__init__(token, server, "prints", config)
        self._attribute_list = [
            "name",
            "thing_id", # int - Thing ID
            "printer_id", # int - Printer ID
            "printing_time", # int - Print time in seconds
            "uuid", # int - Existing S3 File ID
            "printer_uuid", # string - serial of the printer
            "state", # string - State of print,
            "error_code", # int - Error code
            "error_message", # string - Error message
        ]

class User(ThingiverseObject):

    def __init__(self, token, server, config):
        super().__init__(token, server, "users", config)
        self._attribute_list = ["name"]

    def load_me(self):
        """
        Loads the user object associated with the access token
        used during construction
        """
        self.load_from_id("me")

class Layout(ThingiverseObject):
    """
    A Layout is a construct that has a model file and slice file,
    or maybe just a model file, or maybe just a slice file, but
    definitely only one of each. They belong
    to things (Thingiverse things, which have very
    little to do with .thing files), but are different
    than the "files" that also belong to things. It's
    all very confusing, but they are also the central construct
    of the digital store and cloud library.
    """

    def __init__(self, token, server, config):
        super().__init__(token, server, "layouts", config)
        self._attribute_list = ["name", "print_credits"]

class Slice():
    """
    This object represents a Slice of a layout.
    The intended usage is to create this object and call start().
    The callback will tell you when the slice is ready and what the
    download URL is.
    """
    def __init__(self, token, server, layout_id):
        self._log = kaiten.log.getlogger(self)
        self._token = token
        self._server = server
        self._layout_id = layout_id
        self._slice_url = "/layouts/{0}/slice".format(layout_id)
        # states enum
        self.states = kaiten.enum.enum("states",
            "sliced",
            "not_sliced",
            "slicing",
            "queued")
        # config
        self._slice_poll_period_s = 5
        # internal state
        self._polling = False
        self._slice_invoked = False
        # public state
        self.failed_slice = False
        self.error = False
        self.state = None
        self.slice_progress = 0
        self.s3_download_url = None
        self._config = self._server._config

    def contract_duration(self):
        return datetime.timedelta(0, self._slice_poll_period_s)

    def expected_run_time(self):
        return datetime.timedelta(seconds=kaiten.constants.normal_generator_time)

    def __next__(self):
        if not self._polling:
            raise StopIteration
        self._update_slice_status()

    def start(self):
        self._update_slice_status()

    def cancel(self):
        if self._polling:
            self._stop_polling_status()

    def _parse_slice_status(self, response):
        try:
            data = json.loads(response)
        except ValueError:
            self._log.error("Error parsing slice response (layout_id: {0}): {1}".format(
                self._layout_id, response))
            self._process_error()
            return

        status = data.get("status", None)
        warnings = data.get("warnings", None)
        errors = data.get("errors", None)
        self.s3_download_url = data.get("s3_slice_download_url", None)

        if errors:
            self._log.error(
                "Slicing error: {0}, warnings: {1}, status: {2}, layout_id: {3}".format(
                errors, warnings, status, self._layout_id))
            self.failed_slice = True
            self._process_error()
            return

        if status == "not sliced":
            self.state = self.states.not_sliced
        elif status == "sliced":
            self.state = self.states.sliced
        elif status == "queued":
            self.state = self.states.queued
        elif status[:5] == "slice":
            if len(status) > 5 and ' ' in status:
                self.slice_progress = int(status.split()[-1])
                if self.slice_progress < 0 or self.slice_progress > 100:
                    self._log.error("Invalid slice progress: {0}, layout_id: {1}".format(
                        self.slice_progress, self._layout_id))
                    self._process_error()
                    return
            self.state = self.states.slicing
        else:
            self._log.error("Invalid slice status: {0}, layout_id: {1}".format(
                status, self._layout_id))
            self._process_error()
            return

        if self._polling and self.state == self.states.sliced:
            self._stop_polling_status()
        elif not self._slice_invoked and self.state != self.states.sliced:
            self._log.info("Invoking cloud slice...")
            self._server.mixpanel_event("cloud_slice_started")
            self._invoke_cloud_slice()

    def _start_polling_status(self):
        self._polling = True
        self._server.add_contract_generator(self)

    def _stop_polling_status(self):
        self._polling = False

    def _process_error(self, **kwargs):
        self.cancel()
        self.error = True

    def _invoke_cloud_slice(self):
        def callback(response):
            self._start_polling_status()
        # Security hotfix - do not pass oauth tokens to URLs from the config
        self._server.http_request(
            kaiten.constants.thingiverse_api_url_default,
            self._slice_url, "POST", {},
            token=self._token,
            encoding='json',
            success_callback=callback,
            error_callback=self._process_error)
        self._slice_invoked = True

    def _update_slice_status(self):
        # Security hotfix - do not pass oauth tokens to URLs from the config
        self._server.http_request(
            kaiten.constants.thingiverse_api_url_default,
            self._slice_url, "GET", {},
            token=self._token,
            success_callback=self._parse_slice_status,
            error_callback=self._process_error)

