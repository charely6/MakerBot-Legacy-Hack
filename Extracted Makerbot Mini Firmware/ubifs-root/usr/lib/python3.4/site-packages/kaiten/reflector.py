"""
The reflector is a relay server for connecting to clients outside of a local
network.

Overview of how it works:

* Periodically (every 30 seconds) the bot polls a directory server

* Directory verifies valid thingiverse token

* Response to directory poll may contain a Call Offer containing a relay server
address and a temp token

* If bot gets a Call Offer when it checks in, it connects to a specified relay
server passing the temp_token

* Relay server verifies then invalidates the temp_code and begins
relaying JSONRPC to between the bot and client
"""

import datetime
import json
import random
import queue as Queue

import kaiten.client
import kaiten.constants
import kaiten.usb
import kaiten.log

class Reflector:
    """
    This class exists as a Contract executed by the Server, so that the
    reflector directory can be periodically polled.
    """

    def __init__(self, server, config, machine_manager):
        """
        @param server: Kaiten's Server instance
        @param call_callback: Callback if polling the directory returns a
        Call Offer. Executes call_callback(address, token)
        """
        self._server = server
        self._config = config
        self._machine_manager = machine_manager
        self._serial = kaiten.usb.get_serial()
        self._log = kaiten.log.getlogger(self)
        # Keep track of the curent call id we are handling so that we don't
        # accidently try to handle it twice.
        self._current_call_id = None
        self._first_call = True
        self._poll_counter = 0
        self._reflectorExecutor = kaiten.reflector.ReflectorExecutor(self, self._server, self._config)
        self._frame_send_multiple = (int)(kaiten.constants.reflector_camera_frame_poll_period_s / kaiten.constants.reflector_directory_poll_period_s)
        self._frame_retry_multiple = (int)(kaiten.constants.reflector_frame_retry_period / kaiten.constants.reflector_directory_poll_period_s)
        self._frame_retry_attempts = kaiten.constants.reflector_frame_retry_period
        self._pending_requests = []

    def _reflector_queue_jsonrpc(self, jsonrpc_request):
        self._reflectorExecutor.queue_command(jsonrpc_request)

    def get_reflector_executor(self):
        return self._reflectorExecutor
        
    def contract_duration(self):
        return datetime.timedelta(0,
            kaiten.constants.reflector_directory_poll_period_s)

    def expected_run_time(self):
        return datetime.timedelta(seconds=kaiten.constants.normal_generator_time)

    def reload_config(self, config):
        self._config = config
        # Do a status update before updating the machine config to ensure that
        # the server hasn't forgotten about us

        # Note: this try/except is to catch errors from Codernity since
        # this function is called during reset to factory and just calling
        # db.exists() is apparently not enough to guarantee the db exists.
        # Since we're getting rid of codernity soon, I'm going to leave in this
        # hack and we'll fix it when we get rid of Codernity.
        # TODO: undo this hack when we switch away from codernity!
        try:
            self.do_status_update()
            self._update_reflector_machine_config()
        except Exception:
            return

    def reflector_request(self, params, path, verb, success_callback=None, encoding='json', error_callback=None):
        if not self._server.is_online():
            return

        if self._config['kaiten']['reflector_enabled'] is False:
            return

        token_map = self._server.auth_store.get_makerbot_token_map()
        tokens = list(token_map)
        if not tokens: return
        token = random.choice(tokens)
        
        def token_error_callback(**kwargs):
            # Closure so we can invalidate the token if we get a 403
            resp_code = kwargs.get('response_code')
            try:
                error_msg = json.loads(kwargs['error_body'])['message']
            except Exception:
                error_msg = None
            self._log.error("REFLECTOR: http error %r (%r)",
                            resp_code, error_msg)
            if resp_code == 401 or resp_code == 403:
                # This token must be invalid or expired so let's remove it
                # from our store.  Generally TV tokens last forever, but a
                # bad one in our store would mess authing up.
                self._log.error("REFLECTOR: removing invalid thingiverse token")
                self._server.auth_store.deauthorize(token_map[token])
            if error_callback: error_callback(**kwargs)

        # Security hotfix -- Do not load the reflector url from the config!
        # Whatever URL is stored here gets sent auth tokens for all users
        # authorized to this machine, and any authorized user can edit the
        # config to point to any URL they want.
        host = kaiten.constants.reflector_url_default
        https_enabled = True

        req = self._server.http_request(
            host, path, verb, params=params, https=https_enabled, token=token,
            success_callback=success_callback,
            error_callback=token_error_callback,
            encoding=encoding, read_error_body=True)
            
        self._pending_requests.append(req)

    def _update_reflector_machine_config(self):
        self._log.info("REFLECTOR - update machine config");
        machine_config = self._machine_manager.get_machine_config();
        machine_config["z_adjusted_offset"] = self._config["kaiten"]["z_adjusted_offset"]
        self.reflector_request(machine_config, "/printers/"+kaiten.usb.get_serial()+"/machine_config", "PUT")
    
    def send_frame_reflector(self, frame):
        def error_callback(**kwargs):
            responseCode = kwargs.get("response_code", None)
            self._log.error("REFLECTOR: error sending camera frame - Response Code: {0}".format(responseCode))
            tryAgain = False
            if responseCode == 400:
                self._log.error("REFLECTOR: Corrupt image")
                tryAgain = True
            if responseCode == 504:
                self._log.error("REFLECTOR: Server Timeout")
                tryAgain = True

            #try again if timeout our corrupt image and we haven't exceeded retry attempts
            if tryAgain and self._frame_retry_attempts > 0:
                self._server.send_camera_one_shot_callback(self.send_frame_reflector)
                self._frame_retry_attempts -= 1

        self.reflector_request(frame, "/printers/"+kaiten.usb.get_serial()+"/image",
                               "PUT", encoding=None, error_callback=error_callback)

    def do_status_update(self):
        tokens = list(self._server.auth_store.get_makerbot_token_map())
        status_params = {
                "name": self._config["kaiten"]["machine_name"],
                "type": self._config["kaiten"]["machine_type"],
                "tokens": tokens,
                "status": self._server.get_system_information()}
        self.reflector_request(status_params, "/printers/"+self._serial, "PUT",
                               success_callback=self._next_success_response)

    def __next__(self):
        # prune our pending requests
        self._pending_requests = [r for r in self._pending_requests
                                  if not r.complete()]
        if self._pending_requests:
            # rate limit so we don't create a bunch of requests that are failing
            # and taking forever to do so, thus running out of file descriptors
            return
        self._poll_counter += 1
        #send a camera frame every frame_send_multiple polls
        if(self._poll_counter%self._frame_send_multiple == 0):
            self._server.send_camera_one_shot_callback(self.send_frame_reflector)
        if(self._poll_counter%self._frame_retry_multiple == 0):
            #limit the bot to 20 retry attempts every 10 minutes
            self._frame_retry_attempts = kaiten.constants.reflector_frame_retry_period

        self.do_status_update()

    def _next_success_response(self, response):
        """
        Process a response from the directory server.
        Either has a Call Offer or can be ignored.

        @param response: JSON object containing HTTPS response
        """
        try:
            if self._first_call:
                self._update_reflector_machine_config()
                self._first_call = False
            data = json.loads(response)
        except ValueError:
            # Couldn't parse json
            self._log.error("REFLECTOR: couldn't parse directory poll")
            return

        if 'call' in data:
            relay = data["call"]["relay"]
            code = data["call"]["printer_code"]
            call_id = data["call"]["id"]
            username = data["call"]["username"]
            token = data["call"]["access_token"]
            self._handle_call(relay, code, call_id, username, token)

        if 'commands' in data:
            for data in data["commands"]:
                self._reflector_queue_jsonrpc(data)

        return

    def _handle_call(self, relay, code, call_id, username, token):
        """
        This sets up a JSONRPC connection to a client via the reflector

        @param relay: Address of the relay server to connect to (IP:PORT)
        @param code: A temporary token for authenticating this connection
        """
        if self._current_call_id == call_id:
            # Don't handle the same call twice
            self._log.error("REFLECTOR: received duplicate call id")
            return
        else:
            self._current_call_id = call_id
        # Establish a connection
        self._log.info("REFLECTOR: establishing connection: {0}, {1}".format(
            username, relay))
        # Initial auth level is 2 because we are already authenticated
        # via token.
        initial_priv = 2
        client = self._server.connect_remote(relay, initial_priv)
        self._server.auth_store.set_account(client, username)

        # Limit the amount of camera data we send out
        client.data_rate_limiter = kaiten.server.DataRateLimiter(
            kaiten.constants.reflector_camera_rate)

        # Send this notification to the relay server to activate the stream
        method = "auth_packet"
        params = {
            "call_id": call_id,
            "printer_code": code,
            "printer_id": self._serial
        }
        self._server.notify_client(client, method, params)

class ReflectorExecutor:
    """
    This class exists as a Contract executed by the Server, so that the
    firmware updates check can be periodically polled.
    """

    def __init__(self, reflector, server, config):
        """
        @param server: Kaiten's Server instance
        """
        self._log = kaiten.log.getlogger(self)
        self._reflector = reflector;
        self._server = server
        self.reload_config(config)

        self.command_queue = Queue.Queue(maxsize=20)
        # The default mode - check every 500ms
        self._contract_duration = datetime.timedelta(milliseconds=500)
        self._reflector_connection = DummyConnection(self._jsonrpc_command_callback)
        self._reflector_jsonrpc = self._server.jsonrpc_initiate(self._reflector_connection)

    def _invoke_jsonrpc_command(self, jsonrpc_command):
        #ensure we have unicode jsonrpc_request, if not, make it unicode
        command_id = jsonrpc_command["command_id"]
        username = jsonrpc_command["user"]["username"]
        # Command invokation is not currently separate from json parsing so
        # for now we have to re-encode this as json bytes
        jsonrpc_request = json.dumps(jsonrpc_command["command"]).encode("utf-8")

        self._reflector_connection.set_request(jsonrpc_request, command_id)
        client = kaiten.client.Client(username, 'http', 'reflector_http')
        self._reflector_jsonrpc.set_client(client)
        self._reflector_jsonrpc.feed(self._reflector_connection.read())

    def _jsonrpc_command_callback(self, command_id, data):
        #parsing the data into a string
        data = json.loads(data.decode('utf-8'))
        self._reflector.reflector_request(data,
            "/printers/"+kaiten.usb.get_serial()+"/commands/"+command_id, "PUT")

    def reload_config(self, config):
        self._config = config['kaiten']

    def contract_duration(self):
        return self._contract_duration

    def expected_run_time(self):
        return datetime.timedelta(seconds=kaiten.constants.normal_generator_time)

    def queue_command(self, jsonrpc_command):
        if not self.command_queue.full():
            self.command_queue.put(jsonrpc_command)
        else:
            error = '{"error": {"message": "Reflector command queue is full, try again shortly."}}'
            self._jsonrpc_command_callback(jsonrpc_command["command_id"], error.encode("utf-8"))

    def __next__(self):
        """ Main generator method

        If jsonrpc command(s) in queue, will execute one and return
        """
        if not self.command_queue.empty():
            jsonrpc_command = self.command_queue.get()
            try:
                self._invoke_jsonrpc_command(jsonrpc_command)
            except Exception:
                # The jsonrpc reader captures all errors related to badly
                # formatted commands.  We only end up here if the command or
                # some of the ancillary data (ie username) is missing.  The
                # command could theoretically contain a TV token or other
                # sensitive information so we redact it from the log.
                if 'command' in jsonrpc_command:
                    jsonrpc_command['command'] = 'REDACTED'
                self._log.error("Badly formatted command packet: %r",
                                jsonrpc_command)


class DummyConnection(object):
    """
    This is a dummy connection that holds a jsonrpc call that can be read and
    posts the write data to the provided callback

    @param jsonrpc_request: A unicode formatted jsonrpc request
    @param callback: a function that will accept response data
    """
    def __init__(self, callback):
        self._log = kaiten.log.getlogger(self)
        self._jsonrpc_request = ""
        self._command_id = 0
        self._callback = callback

    def read(self):
        """ Returns the jsonrpc request given on initialization """
        # Returns the jsonrpc request given
        return self._jsonrpc_request

    def write(self, *data):
        """
        Posts the data to the reflector server command id url (/printers/:printerid/:jsonrpccommandid)
        """
        self._callback(self._command_id, data[0])
        yield 1

    def fileno(self):
        """
        Returns the file descriptor to support select sets
        """
        #This is not relevant to http connections
        #so a random number higher than any possible real fileno is placed here
        return 123456

    def peer_name(self):
        return 'HTTP'

    def set_request(self, request, command_id):
        self._jsonrpc_request = request
        self._command_id = command_id

