"""
All of the different kaiten decorators are defined in here.

Decorator order is important.  Decorators are interpreted in a bottom up order,
and executed in a top down order (think FILO, starting closest to the function
declaration).  This becomes an issue when we want to set things like function
attributes and have either an outside function evaluate them or an inner decorator
evaluate them.  The outside functions will be evaluating the most outside decorator,
while the inside decorators will be evaluating the actual function its wrapping.

Due to this wrapping behavior, we  MUST apply all decorator-evaluated attributes
as close to the inside function as possible.  Additionally, each wrapping function
that is part of a decorator stack MUST use the propagate_attributes function to
apply all set attributes to the wrapping decorator.

This really isnt as complicated as I made it out to be :(

Full speed ahead!
"""
import datetime
from functools import wraps

# Because of the way decorators work, we can actually run into circular
# import errors by importing things at the top level.  So don't add
# anything here unless it very obviously does not loop back here via
# imports.
import kaiten.enum
import kaiten.error

FunctionAttributes = kaiten.enum.enum("FunctionAttributes",
    "jsonrpc",
    "jsonrpc_immediate",
    "priv_level",
    "require_secure",
    "require_tether",
    "pass_client",
    "pass_callback",
    "enforce_types",
    "process_method",
    "available_during",
    "send_analytics")

def _ensure_priv_level(func):
    """
    Set the privilege level to the default value if it has
    not already been set.  (Not a decorator!)
    """
    if not hasattr(func, FunctionAttributes.priv_level):
        setattr(func, FunctionAttributes.priv_level, 2)

def jsonrpc(func):
    _ensure_priv_level(func)
    setattr(func, FunctionAttributes.jsonrpc, True)
    return func

def jsonrpc_immediate(func):
    setattr(func, FunctionAttributes.jsonrpc_immediate, True)
    return func

def send_analytics(func):
    setattr(func, FunctionAttributes.send_analytics, True)
    return func

def process_method(available_steps):
    """
    Makes a process method callable via the process_method() jsonrpc method
    The process method is only available during available_steps
    """
    def decorator(func):
        setattr(func, FunctionAttributes.process_method, True)
        setattr(func, FunctionAttributes.available_during, available_steps)
        return func
    return decorator

def lower_priv(func):
    _ensure_priv_level(func)
    priv_level = getattr(func, FunctionAttributes.priv_level)
    setattr(func, FunctionAttributes.priv_level, priv_level - 1)
    return func

def raise_priv(func):
    _ensure_priv_level(func)
    priv_level = getattr(func, FunctionAttributes.priv_level)
    setattr(func, FunctionAttributes.priv_level, priv_level + 1)
    return func

def require_secure(func):
    setattr(func, FunctionAttributes.require_secure, True)
    return func

def require_tether(func):
    setattr(func, FunctionAttributes.require_tether, True)
    return func

def pass_client(func):
    setattr(func, FunctionAttributes.pass_client, True)
    return func

def pass_callback(func):
    setattr(func, FunctionAttributes.pass_callback, True)
    return func

def enforce_types(func):
    setattr(func, FunctionAttributes.enforce_types, True)
    return func

def contractify(*args, **kwargs):
    """
    Make a contract generator out of a json rpc method.  This function
    takes at least one argument 'interval' which is used set the
    contract_duration in seconds. It will also accept a argument
    'expected_run_time' that describes the max of how long we expect the
    function to block. The function this decorator is applied to should behave
    exactly like a normal jsonrpc method, but can also yield so that it does
    not block for too long.
    """
    contract_duration = datetime.timedelta(seconds=kwargs['interval'])
    expected_run_time = datetime.timedelta(seconds=kwargs.get('expected_run_time',
                                            kaiten.constants.normal_generator_time))
    def outer_decorator(func):
        @wraps(func)
        def decorator(*args, callback=None, **kwargs):
            import kaiten.jsonrpc
            self = args[0]
            generator = func(*args, **kwargs)
            class CallbackWrapper(object):
                def __next__(dummy):
                    try:
                        next(generator)
                    except StopIteration as e:
                        if callback:
                            callback(e.value)
                        raise StopIteration
                    except kaiten.jsonrpc.JsonRpcException as e:
                        if callback:
                            callback(error=kaiten.jsonrpc.exc_to_error(e))
                        raise StopIteration
                    except Exception as e:
                        self._log.info("Exception in contract method",
                                       exc_info=True)
                        if callback:
                            callback(error={'code': -32603,
                                            'message': 'internal error'})
                        raise StopIteration
                def contract_duration(dummy):
                    return contract_duration
                def expected_run_time(dummy):
                    return expected_run_time
            contract_generator = CallbackWrapper()
            self._server.add_contract_generator(contract_generator)
            return contract_generator
        setattr(decorator, FunctionAttributes.pass_callback, True)
        return decorator
    return outer_decorator

def register_process(func):
    """
    Registers a process with the machine manager.  We do a fair amount of checking
    to determine if we can actually start running this process.  We rely on
    several decorators to add attributes to various functions (i.e. can_run_during_suspend,
    etc).  Depending on those evaluations, we can determine if we should run this
    function or not.

    We need to check the actual process dicts instead of state so we can determine
    if we can run in parallel/while suspended.

    This decorator adds the kwarg `enqueue` to the signature of the wrapped method.
    If enqueue is True, if there is a current process running the new process
    will be enqueued to run after the current process ends.
    """
    @wraps(func)
    def decorator(self, *args, **kwargs):
        enqueue = kwargs.pop('enqueue', False)
        process = func(self, *args, **kwargs)
        self._log.info(process)
        import kaiten.processes
        if isinstance(process, kaiten.processes.Process):
            if self._current_process is not None:
                if self._current_process.anything_preempts:
                    #We get to evict other processes if there's exactly one and
                    #it is preemptible by anything
                    self._force_evict_process(self._current_process)
                    self._process_queue.append(process)
                elif enqueue:
                    self._process_queue.append(process)
                else:
                    raise kaiten.error.ProcessAlreadyRunningException
            else:
                self.register_process(process)
            return process.get_info_dict()
    return decorator
