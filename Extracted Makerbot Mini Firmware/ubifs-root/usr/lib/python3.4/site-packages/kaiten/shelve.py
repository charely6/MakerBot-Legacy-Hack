import collections
import dbm.dumb
import json
import os

class JsonShelf(collections.MutableMapping):
    """
    Similar to shelve.Shelf, but uses JSON for values, syncs the
    backing database on every write, and treats corrupted values
    as missing entries.  It is hard coded to use dbm.dumb, and
    hacks in some extra robustness to this fairly shitty library.
    """
    def __init__(self, path):
        self._path = path
        self._open_db()

    def _maybe_open_db(self):
        # Enforce use of dbm.dumb
        self._db = dbm.dumb.open(self._path, 'c')

    def _open_db(self):
        # dbm.dumb doesn't really handle a corrupted directory file.
        # In fact it blindly eval's lines out of the file if it
        # exists, so we can't really guarantee that this will work.
        try:
            self._maybe_open_db()
            return
        except Exception:
            os.unlink(self._path + '.dir')

        # If the directory is corrupt there is likely a valid backup
        # of it that dbm.dumb creates but inexplicably never uses.
        try:
            os.rename(self._path + '.bak', self._path + '.dir')
        except OSError:
            pass
        else:
            try:
                self._maybe_open_db()
                return
            except Exception:
                os.unlink(self._path + '.dir')

        # Give up and create a new database
        self._maybe_open_db()

    def __delitem__(self, key):
        del self._db[key.encode('utf-8')]
        # Deleting an item always syncs

    def __setitem__(self, key, value):
        self._db[key.encode('utf-8')] = json.dumps(value).encode('utf-8')
        # Setting an item does not sync
        self._db.sync()

    def __getitem__(self, key):
        try:
            return json.loads(self._db[key.encode('utf-8')].decode('utf-8'))
        except Exception:
            raise KeyError(key)

    def __iter__(self):
        for key_bytes in self._db.keys():
            try:
                key = key_bytes.decode('utf-8')
            except UnicodeDecodeError:
                continue
            if key in self: yield key

    def __len__(self):
        # Try not to use this...
        return len(list(0 for k in self))
