"""This activity handles Z-homing.

Since Z-homing is approximately 1000x more complicated than other types
of homing, this gets a special activity"""

import datetime
import math
import os
import json
import kaiten.enum
import kaiten.error
import kaiten.timeseries

from kaiten.activities import Activity

class ZHomeActivity(Activity):

    def __init__(self, machine_manager, pymach, config, *,
                 preheat=False, home_position=None, do_fine_home=True, park=True):
        super().__init__(machine_manager, pymach, config)

        self._preheat = preheat
        self._do_fine_home = do_fine_home
        self._cleanup_home_z = False
        self._moved_from_lowered = False
        self._axis = 'z'
        self._park = park

        self.events = kaiten.enum.enum("events",
            "position_found",
            "starting_fine_home")

        # static config values
        self._config = config
        self._home_settings = self._config["home"]
        self._nozzle_clearance = self._home_settings['nozzle_clearance']
        self._bronx_fs = 215.0
        self._speed = self._home_settings["rate_mm_per_s"].get('z')
        self._retract_distance = self._home_settings["retract_distance_mm"]
        self._restart_distance = self._home_settings["restart_distance_mm"]
        self._retract_speed = self._home_settings["retract_speed_mm_per_s"]
        self._seat_distance = self._home_settings["seat_distance_mm"]
        self._seat_speed = self._home_settings["seat_speed_mm_per_s"]

        self._filament_states = kaiten.enum.enum("filament_states",
            "loaded",
            "retracted",
            "seated",
            "unloaded")
        self._filament_state = None

        self._home_position = home_position or [
            self._home_settings["z_reference_point"]["x"],
            self._home_settings["z_reference_point"]["y"]]

    def cancel(self, error_code=None):
        yield from self._pymach.abort()

    def run(self):
        self.failed = True
        yield from self._pymach.toggle_acceleration_lookahead(False)
        if self._home_settings['type']['z'] == 'switch':
            z_position = yield from self._home_using_switch()
        else:
            z_position = yield from self._home_using_hes()
        self.failed = False
        yield from self._update_position(z_position)

    def _home_using_switch(self):
        """
        This works really well and is < 10 lines. What a great solution.
        """
        pos = [self._home_settings['safe_z_home_position']['x'],
               self._home_settings['safe_z_home_position']['y']]
        yield from self._xymove(pos)
        fine_speed = self._home_settings["rate_mm_per_s_fine"].get('z')
        yield from self._pymach.home_axis('z', self._speed)
        yield from self._ensure_move_axis('z', 2, self._speed, True)
        yield from self._pymach.home_axis('z', fine_speed, blocking_home=True)
        yield
        return 0

    def _home_using_hes(self):
        self._cleanup_home_z = True
        if self._preheat:
            # TODO: handle multiple toolheads
            yield from self._heat_to_temperature([180], wait=True)
        self._pymach.set_toolhead_idle_update_period(0, 0.01)
        yield from self._init_filament()
        yield from self._coarse_home_z()
        if self._do_fine_home:
            yield from self._prep_for_fine_home()
            z_position = yield from self._find_fine_z_position()
        else:
            z_position = 0
        if self._park:
            yield from self._move_to_park()
        return z_position

    def _cleanup(self):
        if self.failed:
            self._log.info("HOME: z-home cleaning failure")
            yield from self._pymach.set_position(2, 0)
        if self._cleanup_home_z:
            self._log.debug("HOME: z-home cleaning up")
            if self._preheat:
                yield from self._pymach.cool()
            if self._moved_from_lowered:
                yield from self._ensure_move_axis(2, 10, 10, True)
            yield from self._cleanup_filament()
            self._pymach.set_toolhead_idle_update_period(0, 0.5)
            yield from self._pymach.change_hes_sample_rate(0, self._bronx_fs)
            self._log.debug("HOME: z-home complete")

    def _init_filament(self):
        """
        If filament switch says there is filament, we assume it is loaded.
        Processes _should_ always start/end with filament fully loaded or unloaded.
        """
        if self._pymach.get_filament_presence(0):
            self._log.info("HOME: z-homing with filament present")
            self._filament_state = self._filament_states.loaded
        else:
            self._log.info("HOME: z-homing without filament present")
            self._filament_state = self._filament_states.unloaded
        if self._filament_state == self._filament_states.loaded:
            yield from self._ensure_move_axis(3,
                -self._retract_distance,
                self._retract_speed, True)
            yield from self._sleep(3)
            self._filament_state = self._filament_states.retracted

    def _cleanup_filament(self):
        """
        If filament is present, get it back to the loaded state
        """
        if self._filament_state == self._filament_states.retracted:
            yield from self._ensure_move_axis(3,
                self._restart_distance,
                self._retract_speed, True)
            self._filament_state = self._filament_states.loaded
        elif self._filament_state == self._filament_states.seated:
            yield from self._ensure_move_axis(3,
                self._restart_distance - self._seat_distance,
                self._retract_speed, True)
            self._filament_state = self._filament_states.loaded
        # set a-axis position, since we may have restarted a different
        # distance than retract to account for slippage
        yield from self._pymach.set_position(3, 0)

    def _seat_nozzle(self):
        """
        Push some filament down to try to seat the nozzle.
        If filament is already in the seated position, retract a little first.
        """
        if self._filament_state == self._filament_states.seated:
            yield from self._ensure_move_axis(3,
                -self._seat_distance,
                self._retract_speed, True)
            yield from self._sleep(3)
            self._filament_state = self._filament_states.retracted
        if self._filament_state == self._filament_states.retracted:
            yield from self._ensure_move_axis(3,
                self._seat_distance,
                self._seat_speed, True)
            yield from self._sleep(4)
            self._filament_state = self._filament_states.seated

    def _move_to_park(self):
        yield from self._ensure_move_axis('z', self._nozzle_clearance, self._speed, True)
        yield from self._safe_xypark()
        yield from self._ensure_move_axis('z', -self._nozzle_clearance, self._speed, True)

    def _move_to_reference_point(self):
        yield from self._ensure_move_axis('z', self._nozzle_clearance, self._speed, True)
        if self._parked():
            yield from self._unpark()
        yield from self._xymove(self._home_position)
        yield from self._ensure_move_axis('z', -self._nozzle_clearance, self._speed, True)

    def _init_hes(self):
        yield from self._pymach.configure_hes(0,
            self._home_settings["mag_sense"]["exponent"],
            self._home_settings["mag_sense"]["threshold"])
        while not self._pymach.toolhead_acknowledged_hes(0):
            yield

    def _build_plate_check(self):
        # find the approx z height of the build_plate_check_location
        # this also effectively does a coarse home
        max_offset = self._home_settings["build_plate_check_location"]["max_offset"]

        # check the z-carriage position
        yield from self._ensure_move_axis('z', self._nozzle_clearance, self._speed, True)
        yield from self._xymove(
            [self._home_settings["build_plate_check_location"]["x"],
            self._home_settings["build_plate_check_location"]["y"]])

        yield from self._seat_nozzle()
        yield from self._init_hes()

        self._moved_from_lowered = True
        yield from self._pymach.home_axis('z', self._speed)
        cur_pos = yield from self._pymach.get_axes_position()
        z_reference = cur_pos[2]

        # coarse home and find the approx z height of the homing position
        yield from self._move_to_reference_point()
        yield from self._seat_nozzle()
        yield from self._init_hes()
        yield from self._pymach.find_knob_z(z_reference - max_offset, self._speed)
        new_pos = yield from self._pymach.get_axes_position()
        z_home = new_pos[2]
        yield from self._pymach.set_position(2, 0)

        # check if they are less than build_plate_check_location max offset
        self._log.info("Z reference {0}, Z coarse home {1}"
                       .format(z_reference, z_home))
        fudge_factor = 0.1
        if (z_reference - z_home) >= (max_offset - fudge_factor):
            yield kaiten.error.no_build_plate

    def _coarse_home_z(self):
        # check if we should do a build plate presence check
        if "build_plate_check" in self._home_settings and \
            self._home_settings["build_plate_check"]:
            yield from self._build_plate_check()
        else:
            yield from self._move_to_reference_point()
            yield from self._seat_nozzle()
            yield from self._init_hes()
            self._moved_from_lowered = True
            yield from self._pymach.home_axis('z', self._speed)

        self._fire_event(self.events.position_found)

    def _update_position(self, z_position):
        # Adjust by the calibration-routine offset
        z_position -= self._config["home"]['z_reference_point']['offset']
        # Adjust by the optional user-specified offset (default is 0)
        z_position -= self._config['kaiten']['z_adjusted_offset']
        # This is used by bots that require calibration, which overrides
        # z_referece_point offset
        z_position -= self._config["home"]['extra_z_offset']

        # set new z axis position
        yield from self._set_z_home_position(z_position)
        self._pymach.set_position_reference('z')

    def _set_z_home_position(self, point):
        # set the z-axis home position to be given point
        current_point = yield from self._pymach.get_axes_position()
        z_pos = current_point[2]
        delta = z_pos - point
        self._log.info("Found Z: start {} cur {} d {}".format(point, z_pos, delta))
        yield from self._pymach.set_position(
            2,
            delta)

    def _prep_for_fine_home(self):
        # put us in a good position for timeseries
        yield from self._ensure_move_axis('z',
            self._home_settings["timeseries_start_position_z"],
            self._speed, False)
        yield from self._seat_nozzle()

    def _find_fine_z_position(self):
        # config
        max_retries = self._home_settings['timeseries_retries']
        move_up_distance = self._home_settings['timeseries_home_distance']
        home_speed = self._home_settings['timeseries_home_speed']
        desired_sample_rate = self._home_settings['timeseries_sample_rate']
        z_accel = self._config["acceleration"]["rate_mm_per_s_sq"]["z"]

        # get our initial z position before moving up
        position = yield from self._pymach.get_axes_position()
        z_ref = position[2]

        # setup HES sample rate
        sample_rate = yield from self._pymach.change_hes_sample_rate(0, desired_sample_rate)
        self._log.info("Moving up {0} mm @ {1} mm/s while sampling at {2} samples/second".format(
            move_up_distance, home_speed, sample_rate))

        # capture waveforms until we get an acceptable fit
        retries = 0
        while True:
            if retries == max_retries:
                yield kaiten.error.bad_hes_waveforms
                return
            elif retries > 0:
                # BW-2557 avoid homing errors
                yield from self._seat_nozzle()
                yield from self._coarse_home_z()
                yield from self._prep_for_fine_home()
                yield from self._seat_nozzle()
                # should this be here again?
                new_pos = yield from self._pymach.get_axes_position()
                z_ref = new_pos[2]
            self._log.info("timeseries attempt: {0}".format(retries + 1))

            # capture a HES log while moving up, slowly
            yield from self._pymach.toggle_toolhead_syncing(True)
            yield from self._pymach.begin_hes_log(0, 256, False)
            yield from self._pymach.move_axis(2, -move_up_distance, home_speed, relative=True)
            yield from self._pymach.enable_toolhead_idle()
            yield from self._pru_delay_loop()
            yield from self._pymach.end_hes_log(0)
            yield from self._pymach.toggle_toolhead_syncing(False)
            yield from self._ensure_move_axis(2, move_up_distance, 3.0, relative=True)

            # get waveform
            waveform = yield from self._grab_hes_log(256, 0)
            self._log.info("captured HES waveform: %s" % waveform)
            try:
                start = waveform.index(0xabcd) # 0xabcd is inserted into log to mark start point
                waveform = waveform[0:start]
            except ValueError:
                # could not find 0xabcd value, probably overflowed the log
                retries += 1
                continue
            waveform.reverse()

            # find inflection point
            try:
                z_delta = kaiten.timeseries.find_contact_point_mm(
                    waveform, home_speed, sample_rate,
                    max_seated_value=self._home_settings["timeseries_max_seated_value"],
                    min_range=self._home_settings["timeseries_min_range"],
                    threshold=self._home_settings["timeseries_threshold"],
                    window=self._home_settings["timeseries_window"])
                break
            except kaiten.timeseries.HesWaveformException:
                retries += 1
                continue

        # send ascii encoded waveform to google analytics
        waveform_ascii = kaiten.timeseries.encode_waveform(waveform)
        self._machine_manager._server.mixpanel_event("hes_waveform",
            waveform_ascii_encoded=waveform_ascii, retries=retries)

        # calculate z-offset due to acceleration
        z_accel_offset = pow(home_speed, 2) / (2.0 * z_accel)
        # sum it all up
        z_position = z_ref - z_delta + z_accel_offset
        self._log.info("z_ref: %s, z_delta: %s, z_pos: %s" % (z_ref, z_delta, z_position))
        return z_position


