"""This activity handles loading filament.

This activity assumes that the bot is in the proper heated state.
"""

import kaiten.error
from kaiten.activities import Activity
import kaiten.util
import datetime

class LoadFilamentActivity(Activity):

    def __init__(self, machine_manager, pymach, config, *,
        tool_index=0):
        super().__init__(machine_manager, pymach, config)
        self._tool_index = tool_index
        self._mm = self._config["filament"]["load_distance"] # movement distance
        self._movement_speed = self._config["filament"]["load_speed"]
        self._saw_filament = False
        self._saw_filament_start = False
        self._updated_toolhead_errors = False
        self._last_filament_seen = None
        self._no_filament_timeout = datetime.timedelta(seconds=0.5)
        self._machine_manager._current_process.cancellable_toolhead_errors.discard(
            kaiten.error.no_filament)
        self._mixpanel_event_name = "load_filament"
        self._axis = self._machine_manager.axis_from_index(self._tool_index)
        self._assist = self._machine_manager.assist_from_index(self._tool_index)
        if self._assist:
            self._assisted_load_distance_one = self._config["filament"]["assisted_load_distance_one"]
            self._assisted_load_speed_one = self._config["filament"]["assisted_load_speed_one"]
            self._assisted_load_distance_two = self._config["filament"]["assisted_load_distance_two"]
            self._assisted_load_speed_two = self._config["filament"]["assisted_load_speed_two"]
            self._assisted_load_distance_incremental = self._config["filament"]["assisted_load_distance_incremental"]
            self._assisted_load_speed_incremental = self._config["filament"]["assisted_load_speed_incremental"]

    def run(self):
        properties = {"part_of_process":
                      self._machine_manager._current_process.__class__.__name__}
        self._machine_manager._server.mixpanel_event(
            self._mixpanel_event_name, **properties)

        self._machine_manager._server.play_buzzer("notify")
        yield from self._pymach.change_tool(self._tool_index)
        yield from self._do_move()

    def _move_incremental(self, axes):
        """ Move an axis a short distance, useful for awaiting filament pres"""
        yield from self._pymach.move_axes(axes,
            [self._assisted_load_distance_incremental]*len(axes),
            self._assisted_load_speed_incremental, [True]*len(axes))

    def _move_assist_one(self):
        """ Move our assist axis a long move to get it close to the tool"""
        yield from self._pymach.move_axis(self._assist,
            self._assisted_load_distance_one,
            self._assisted_load_speed_one, True)

    def _move_assist_two(self):
        """ Final move before extrusion to ensure the filament is in the tool"""
        axes = [self._axis, self._assist]
        yield from self._pymach.move_axes(axes,
            [self._assisted_load_distance_two]*len(axes),
            self._assisted_load_speed_two, [True]*len(axes))


    def _do_load_to_assist(self):
        """ Load from assist till we detect filament"""
        while not self._pymach.get_presence(self._assist):
            yield from self._move_incremental([self._assist])
            yield from self._pru_delay_loop()
        yield

    def _do_load_to_tool(self):
        """ Load from the ADS up to the tool"""
        yield from self._move_assist_one()
        yield from self._pru_delay_loop()
        while not self._pymach.get_presence(self._axis):
            yield from self._move_incremental([self._axis, self._assist])
            yield from self._pru_delay_loop()
        yield from self._move_assist_two()
        yield from self._pru_delay_loop()

    def _do_move(self):
        # If we have an assist axis make sure that our filament is at the tool
        # before doing our long purge move
        if self._assist:
            yield from self._pymach.assist_enable(True)
            yield from self._do_load_to_assist()
            yield from self._do_load_to_tool()
        # one long move will overflow the step command to bronx and go the opposite direction
        self._saw_filament_start = self._pymach.get_filament_presence(self._tool_index)
        yield from self._pymach.move_axis(self._axis, self._mm, self._movement_speed, True)
        yield from self._pymach.move_axis(self._axis, self._mm, self._movement_speed, True)
        yield from self._pymach.move_axis(self._axis, self._mm, self._movement_speed, True)
        while not self._pymach.move_buffer_empty():
            # BW-2538 - in case short piece of filament is loaded
            # The debounce logic is from BW-2738 and BW-2737. There's a debounce
            # the Bronx already but it's intended to debounce issues caused by
            # the switch or filament path. This debounce is intended to debounce
            # issues caused by shaky human hands.
            if not self._saw_filament \
               and self._pymach.get_filament_presence(self._tool_index):
                self._saw_filament = True
            
            # We have seen filament in the past and now, for the first time, we
            # see that there isn't any filament
            if self._saw_filament \
               and None is self._last_filament_seen \
               and not self._pymach.get_filament_presence(self._tool_index):
                self._last_filament_seen = datetime.datetime.utcnow()

            # We have seen filament before, but we also saw no filament - reset
            # the debounce timer
            if self._saw_filament \
               and None is not self._last_filament_seen \
               and self._pymach.get_filament_presence(self._tool_index):
                self._last_filament_seen = datetime.datetime.utcnow()

            # We have seen filament before, and we saw a no filament, and havent
            # seen filament since: this is really an error, raise it
            # We only do this if we saw filament at the start of moving
            # because if the user is loading filament he/she may accidentally trigger this
            if self._saw_filament_start \
               and self._saw_filament \
               and None is not self._last_filament_seen \
               and not self._pymach.get_filament_presence(self._tool_index) \
               and (datetime.datetime.utcnow()-self._last_filament_seen) > self._no_filament_timeout:
                self._machine_manager._current_process.ignorable_toolhead_errors.discard(
                    kaiten.error.no_filament)
                yield kaiten.error.no_filament
            yield

    def _cleanup(self):
        self._machine_manager._server.play_buzzer("print_done")
        if self._assist:
            yield from self._pymach.assist_enable(False)
        yield
