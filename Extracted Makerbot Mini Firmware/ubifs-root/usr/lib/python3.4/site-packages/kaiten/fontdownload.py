"""
Simple Contractor that checks if we need to download fonts.
"""

import os
import datetime
import json
import shutil
import hashlib


import kaiten.constants
import kaiten.log
import kaiten.usb
import kaiten.util
import kaiten.processes
"""
This class exists as a Contract executed by the Server, so that the
font updates check can be periodically polled.
"""
class FontDownload(object):
    # so the font files that we use have the sc lang code for chinese
    # but the translation files use zh, so instead of trying to resync all the files
    # in the wild its safer to just leave them as they are and contain all the logic
    # for the difference here. since the UI only uses the zh code and the sc only
    # matters while we're downloading, and only to maintain the right filename
    cjk_langs = ['sc', 'kr', 'jp']
    ui_cjk_langs = ['zh', 'ko', 'ja']
    error_wait_time = datetime.timedelta(minutes=3)

    def __init__(self, server, config):
        """
        @param server: Kaiten's Server instance
        """
        self._log = kaiten.log.getlogger(self)
        self._server = server
        self._config = config

        self._steps = kaiten.enum.enum("font_download_steps",
            "waiting", # process hasn't started yet
            "checking_for_fonts", # see if the font's are already there
            "checking_for_downloads", # retrive list.json from the server
            "retrieving_font_list", # waiting for list.json result
            "downloading_fonts",  # download any missing/out-of-date files
            "verifying_download", # make sure the downloaded files are vaild
            "error_state", # we hit an error
            "finished") # finished
        self._step = self._steps.waiting
        # This attribute is set to a FileDownload instance iff we are
        # actively downloading a font file.
        # should be a list of font files left to download
        self.font_downloads = None
        self.font_list = None
        self.current_download = None

        self.fonts_to_check = []
        # we delegate out blocking things to other contracts so its ok
        # to have a short time here
        self._contract_duration = datetime.timedelta(seconds=10)

    def expected_run_time(self):
        return datetime.timedelta(seconds=kaiten.constants.normal_generator_time)

    def contract_duration(self):
        return self._contract_duration

    def __next__(self):
        """ Main generator method
        """
        if self._step == self._steps.waiting:
           # do this to tell if the process has been started
           self._step = self._steps.checking_for_fonts
        if self._step == self._steps.checking_for_fonts:
            already_done = self._font_files_exist()
            if already_done:
                # Don't bother to do anything then
                self._step = self._steps.finished
            else:
                self._step = self._steps.checking_for_downloads
        elif self._step == self._steps.checking_for_downloads:
            if self._server.is_online():
                self._check()
        elif self._step == self._steps.retrieving_font_list:
            # just chill
            return
        elif self._step == self._steps.downloading_fonts:
            if self.current_download:
                self._log.info("Current Font file download progress %d",
                               self.current_download.progress())
                if self.current_download.complete:
                    self._do_next_download()
                elif self.current_download.error:
                    # Just remove the failed download here, so that after
                    # one more fast iteration we can retry the download.
                    self.current_download = None
            elif self._server.is_online():
                self._start_font_download()
        elif self._step == self._steps.verifying_download:
            # just chill
            return
        elif self._step == self._steps.error_state:
            # we wait for an hour if we experince an error, so when this is
            # called we need to set it back to the normal contract_duration
            self._contract_duration = datetime.timedelta(seconds=10)
            self._server.reschedule_contract_generator(self)
            self._step = self._steps.error_state
            self._step = self._steps.checking_for_fonts
        elif self._step == self._steps.finished:
            self._log.info("Font download complete")
            self._server.notify_client('lcd', 'font_notification',
                                        {'available_languages': FontDownload.ui_cjk_langs})
            raise StopIteration


    def _font_files_exist(self):
        """ returns true if there all fonts are present
        """
        base = 'NotoSansCJK'
        langs = FontDownload.cjk_langs
        styles = ['-Black', '-Bold', '-Medium', '-Regular']
        extention = '.otf'
        for l in langs:
            for s in styles:
                filename = base + l + s + extention
                if not os.path.exists(os.path.join(
                                      kaiten.constants.font_dir,
                                      filename)):
                    self._log.info("we don't have at least %s", filename)
                    return False
        return True

    def _start_font_download(self):
        """
        Try to download fonts from our server

        This performs all necessary steps to prepare to download and will bail
        if we have a print running (deleting large files blocks very
        badly on our filesystem).

        This function writes the files to a location in /var/fonts
        with a .tmp extension before we rename the file to have the right
        filename
        """
        # We have to bail on prints, but really we might as well bail
        # on anything other than setupproesss.  (SetupProcess does
        # run a test print, but printers running the FRE will have had the font
        # loaded at the factory
        curr_proc = self._server._machine_manager.get_current_process()
        allowed = [
            kaiten.processes.SetupProcess,
        ]
        if curr_proc and not any(isinstance(curr_proc, p) for p in allowed):
            return
        self._do_next_download()

    def _do_next_download(self):
        """ grab a download off the self.font_downloads list and set
        self.current_download to that
        """
        url = "https://{0}{1}{2}".format(
            self._config['kaiten']['font_update']['font_server_url'],
            self._config['kaiten']['font_update']['font_download_path'],
            self.font_downloads[0]['filename'])

        if not os.path.exists(kaiten.constants.font_dir):
            os.mkdir(kaiten.constants.font_dir)
        
        self.current_download = kaiten.util.FileDownload(
              self._server, url,
              os.path.join(
                kaiten.constants.font_dir,
                self.font_downloads[0]['filename']+".tmp"))
        self.current_download.set_success_callback(self._download_success)
        self.current_download.set_error_callback(self._download_error)
        self.current_download.start()

    def compute_needed_files(self):
        """ make sure we didn't dont re-download anything
        """
        self.font_downloads = []
        fonts_to_check = []
        for font in self.font_list["fonts"]:
            path = os.path.join(kaiten.constants.font_dir, font['filename'])
            if not os.path.exists(path):
                self.font_downloads.append(font)

        if len(self.font_downloads) > 0:
            self._step = self._steps.downloading_fonts
        else:
            self._log.error("we messed up in font download")
            self._step = self._steps.error_state

    def verify_files(self):
        self._step = self._steps.verifying_download
        self._log.info("verfiying files: " + str(self.fonts_to_check))
        _hashcheck = kaiten.util.HashChecker(
                        hashlib.md5,
                        self.fonts_to_check,
                        self._verify_finished)
        self._server.add_contract_generator(_hashcheck)

    def _verify_finished(self, filenames):
        """ this function is called when the checksum process is complete
        the filenames returned in this function are the absolute paths to the
        files that didn't match the supplied checksums
        """
        # filenames returned are absolute locations to the file on the bot
        if len(filenames) > 0:
            for f in filenames:
                os.unlink(f)
            self._log.info("re-downloading these fonts: " + str(filenames))
            self._step = self._steps.checking_for_downloads
            self.fonts_to_check = []
        else:
            self.font_downloads = None
            self._step = self._steps.finished

    def _download_success(self):
        """
        Invoked when we successfully download a font file
        """
        final_path = os.path.join(kaiten.constants.font_dir,
                self.font_downloads[0]['filename'])
        os.rename(final_path+".tmp", final_path)
        self.fonts_to_check.append({"filename": final_path,
                                    "checksum":self.font_downloads[0]['md5']})
        self.current_download = None
        if len(self.font_downloads) == 1:
            # completed all downloads
            self.font_downloads = []
            self.verify_files()
        else:
            self.font_downloads.pop(0)
            self._do_next_download()

    def _download_error(self):
        self._log.info("encounterd an error downloading font")
        self.current_download = None
        self._contract_duration = FontDownload.error_wait_time
        self._server.reschedule_contract_generator(self)
        self._step = self._steps.error_state

    def net_change_callback(self, state, old_state):
        self.log.info("network state change: " + state)
        if state['state'] == 'offline' and self.current_download:
            # well dangit we just lost connection mid download, clean up
            # after ourselves
            self.current_download.close()
            self.current_download = None
            self.font_downloads = None
            self._contract_duration = FontDownload.error_wait_time
            self._step = self.steps.error_state

    def _check(self):
        """
        Unconditionally grab the list of available font files
        and .
        """
        self._step = self._steps.retrieving_font_list
        config = self._server._config['kaiten']
        request = self._server.http_request(
            self._config['kaiten']['font_update']['font_server_url'],
            self._config['kaiten']['font_update']['font_files_list'],
            "GET", params={},
            success_callback=self._check_success_callback,
            error_callback=self._check_error_callback,
            timeout=30)
    
    def _check_success_callback(self, response):
        try:
            self.check_success=True
            self.font_list = json.loads(response)
            self.compute_needed_files()
        except (ValueError, TypeError) as e:
            self._log.error("Error loading font list json file: %s",str(e))
            self._step = self._steps.error_state

    def _check_error_callback(self, response_code=None):
        self._log.info("encounterd an error getting list.json")
        self._contract_duration = FontDownload.error_wait_time
        self._server.reschedule_contract_generator(self)
        self._step = self._steps.error_state
