"""
Simple Contractor that checks for firmware updates and notifies clients
only when new firmware is available to avoid unnecessary traffic.
"""

import os
import datetime
import json

import kaiten.constants
import kaiten.log
import kaiten.usb
import kaiten.util

class FirmwareUpdates:
    """
    This class exists as a Contract executed by the Server, so that the
    firmware updates check can be periodically polled.
    """

    def __init__(self, server, config):
        """
        @param server: Kaiten's Server instance
        """
        self._log = kaiten.log.getlogger(self)
        self._server = server
        self.reload_config(config)
        self._should_download = False

        # This attribute is set to a FileDownload instance iff we are
        # actively downloading a firmware file.
        self.firmware_download = None

        # These attributes are _always_ set to refer to the newest
        # firmware version as soon as we find out that a newer version
        # exists.  They should never be unset once set until kaiten
        # reboots, but may be updated if we find an even newer version.
        self._firmware_version = None
        self._firmware_filename = None

        # The default mode - check every 12 hours if there's an update
        self._contract_duration = datetime.timedelta(hours=12)

        # This should be set if we should trigger a firmware check
        # when we next go online.  Typically this is false, and we just
        # check for updates every 12 hours.  But if we weren't online
        # the last time our 12 hour timer expired, we set this flag.
        self._needs_check = True

        # Backend for a property to check to see if there's firmware avaiable
        # rather than relying on a notification.
        self._update_available = False

    def expected_run_time(self):
        return datetime.timedelta(seconds=kaiten.constants.normal_generator_time)

    def reload_config(self, config):
        self._config = config['kaiten']['firmware_update']

    def contract_duration(self):
        return self._contract_duration

    @property
    def update_available(self):
        return self._update_available

    def __next__(self):
        """ Main generator method

        Has two modes:
        - If a firmware is currently being downloaded, check if it's done and
          notify interested parties if it is; otherwise log progress. Contract
          time here should probably not be 12 hours.
        - Check if an update is available - here, the contract should be 12
          hours because why check more frequently than that.
        """
        if self.firmware_download:
            if not self.firmware_download.complete:
                self._log.info("Firmware download progress %d",
                               self.firmware_download.progress())
            elif self.firmware_download.error:
                # Just remove the failed download here, so that after
                # one more fast iteration we can retry the download.
                self.firmware_download = None
            # We use success_callback to react immediately to completion
        elif self._should_download:
            self._start_firmware_download()
        elif self._server.is_online():
            self._check()
        else:
            self._needs_check = True

    def _download_notify(self):
        """
        Send a notification about the active/completed firmware download
        """
        self._firmware_updates_info_notify(
            update_available=True, version=self._firmware_version,
            is_online=True)

    def get_firmware_path(self):
        return kaiten.util.get_firmware_path(self._firmware_filename)

    def _firmware_file_exists(self):
        return os.path.exists(self.get_firmware_path())

    def _cleanse_download_folder(self):
        """
        Removes any stale firmware files laying around in the firmware download folder
        """
        download_folder = os.path.join(kaiten.constants.home_dir, "firmware")
        for firmware_file in os.listdir(download_folder):
            file_path = os.path.join(download_folder, firmware_file)
            try:
                os.unlink(file_path)
            except Exception as e:
                self._log.info("Unable to delete %s", file_path)

    def _firmware_updates_info_notify(self, update_available:bool=False,
                                      is_online:bool=True,
                                      version:str=None,
                                      error:int=None,
                                      release_date:str="", release_notes:str=""):
        """
        Send a notification about the firmware updates information to all clients
        """
        self._update_available = update_available
        results = {
            "version": version,
            "update_available" : update_available,
            "is_online": is_online,
            "error": error,
            "release_date": release_date,
            "release_notes": release_notes
        }
        self._server.notify_clients('firware_updates_info_change', results)


    def _start_firmware_download(self):
        """
        Try to download firmware from our server

        This performs all necessary steps to prepare to download
        (such as deleting any existing firmware files) and will bail
        if we have a print running (deleting large files blocks very
        badly on our filesystem).

        This function writes the file to a generic location in
        /home/firmware before we rename the file to have the magic
        filename that associates it with being a valid firmware
        release.
        """
        # We have to bail on prints, but really we might as well bail
        # on anything that does not update firmware.  (SetupProcess does
        # run a test print, but the main reason we have to bail is to
        # avoid blocking while we delete old firmware files, which don't
        # exist when running the FRE and probably wouldn't block during
        # the test print anyway even if they did.)
        curr_proc = self._server._machine_manager.get_current_process()
        allowed = [
            kaiten.processes.FirmwareBurningProcess,
            kaiten.processes.SetupProcess,
        ]
        if curr_proc and not any(isinstance(curr_proc, p) for p in allowed):
            return

        self._cleanse_download_folder()

        firmware_url = "https://{0}{1}{2}".format(
            self._config['firmware_server_url'],
            self._config['firmware_download_path'],
            self._firmware_filename)

        self._temp_firmware_path = kaiten.util.get_firmware_path("firmware.zip")

        self.firmware_download = kaiten.util.FileDownload(
            self._server, firmware_url, self._temp_firmware_path)
        self.firmware_download.set_success_callback(self._download_success)

        self.firmware_download.start()

    def _download_success(self):
        """
        Invoked when we successfully download a firmware file
        """
        self._log.info("Firmware download complete")
        os.rename(self._temp_firmware_path, self.get_firmware_path())
        self._download_notify()

        # Go back to polling for even newer versions.  If we want to
        # install this version, FirmwareBurningProcess will take over.
        self._should_download = False
        self.firmware_download = None
        self._contract_duration = datetime.timedelta(hours=12)
        self._server.reschedule_contract_generator(self)

    def net_change_callback(self, state, old_state):
        if state['state'] != 'offline' and old_state['state'] == 'offline':
            if self._needs_check:
                self._needs_check = False
                # Wait 12 hours from now to check again
                self._server.reschedule_contract_generator(self)
                self._check()
        elif state['state'] == 'offline' and self.firmware_download:
            # well dangit we just lost connection mid download, clean up
            # after ourselves
            self._log.info("blowing away download")
            self.firmware_download.close()
            self.firmware_download = None
            self._cleanse_download_folder()


    @staticmethod
    def _get_latest_firmware(firmware_list, current_firmware):
        """ Find the latest firmware in firmware_list + current

        Doesn't use state, just assumptions about how the list is structured.
        The list should be the raw list we get back from the remote server and
        the current firmware should be a kaiten.util.Version object.
        """
        pid = kaiten.usb.get_pid()
        # Compare versions against current version
        latest_firmware = current_firmware
        results = {}
        for firmware in firmware_list:
            manifest = firmware['manifest']
            supported_pids = [x['pid'] for x in manifest['supported_machines']]
            if pid not in supported_pids: continue
            version_number = manifest['version']
            firmware_candidate = kaiten.util.Version.factory(version_number)
            if firmware_candidate > latest_firmware:
                results['version'] = str(firmware_candidate)
                results['filename'] = firmware['path']
                results['update_available'] = True
                results['release_date'] = manifest.get('release_date',"")
                results['release_notes'] = manifest.get('release_notes',"")
                latest_firmware = firmware_candidate
        return results, latest_firmware

    def _check_firmware_list(self, firmware_list):
        """
        If firmware_list has a newer firmware, start downloading it.

        We want to start downloading anything that is newer than the
        version we are running, unless we have already successfully
        downloaded the newest version.
        """

        current_firmware = kaiten.util.get_fw_version()
        (results, latest_firmware) = self._get_latest_firmware(firmware_list,
                                                               current_firmware)
        # Stringify release notes found on server if necessary
        if 'update_available' in results.keys() and results['update_available'] \
           and not isinstance(results['release_notes'], str):
            if isinstance(results['release_notes'], list):
                results['release_notes'] = "\n".join(results['release_notes'])
            else:
                self._log.warning("Release notes - expected list of strings"\
                               " received: {0}".format(results['release_notes']))
                results['release_notes'] = str(results['release_notes'])
        self._log.info("got latest firmware {0}, current {1}, returning {2}"\
                       .format(latest_firmware, current_firmware, results))

        if 'filename' in results:
            self._firmware_filename = results['filename']
            self._firmware_version = results['version']
            # Notify now so the user can start the update if they want while we
            # download
            self._firmware_updates_info_notify(update_available=True,
                                               version=results['version'])
            if self._firmware_file_exists():
                # We already downloaded this firmware!
                self._log.info("Latest firmware %s already exists",
                               latest_firmware)
            else:
                self._log.info("Downloading latest firmware %s",
                               latest_firmware)

                # We should keep trying to download this until we get it,
                # so mark that and shorten our contract
                self._should_download = True
                self._contract_duration = datetime.timedelta(minutes=1)
                self._server.reschedule_contract_generator(self)

                # Try to start a download
                self._start_firmware_download()
        else:
            # Already current on firmware
            self._firmware_updates_info_notify(update_available=False)

    def check(self, only_notify=False):
        """
        Check if an updated firmware version is available.  This method
        generally does what we want if a user asks for the latest
        firmware -- if we are currently processing a new firmware file
        then we just return that one as "the latest", and otherwise we
        actually check to see what the latest firmware is.

        No information about whether a firmware update is pending is
        actually returned.  Instead we send out a notification to all
        clients about whether updates are available.

        If only_notify is true and we don't have an update ready, we send
        a notification that we do not have an update ready instead of
        checking again.
        """
        if self.firmware_download:
            # If someone manually checks for firmware updates while 
            # we happen to be downloading one, go ahead and admit it
            # We don't need to do anything special to figure out if a
            # client called this because when we're downloading the
            # generator is repurposed to log updates about the download
            # progress
            self._download_notify()
        elif self._firmware_filename and self._firmware_file_exists():
            self._download_notify()
        elif not self._server.is_online():
            self._firmware_updates_info_notify(
                update_available=False, is_online=False)
        elif only_notify:
            self._firmware_updates_info_notify(update_available=False)
        else:
            self._check()

    def _check(self):
        """
        Unconditionally grab the list of available firmware versions
        and pass it (json decoded) to _check_firmware_list.
        """
        self._log.info("Checking firmware updates")
        config = self._server._config['kaiten']
        request = self._server.http_request(
            self._config['firmware_server_url'],
            self._config['firmware_versions_list'],
            "GET", params={},
            success_callback=self._check_success_callback,
            error_callback=self._check_error_callback)

    def _check_success_callback(self, response):
        try:
            firmware_list = json.loads(response)
        except (ValueError, TypeError):
            self._log.error("Error loading firmware list json file")
            error = kaiten.error.firmware_update_check_error
            self._firmware_updates_info_notify(update_available=False,
                                              is_online=True,
                                              error=error)
        else:
            self._check_firmware_list(firmware_list)

    def _check_error_callback(self, response_code=None):
        self._log.error("Error retrieving firmware list, response code %s",
                        response_code)
        error = kaiten.error.firmware_update_check_error
        self._firmware_updates_info_notify(update_available=False,
                                           error=error)
        # There is a decent chance that this errored out because we
        # aren't really online, so we should still check again when
        # we come back online.  This might get a bit spammy though if
        # we are always erroring out and the connection is going up
        # and down a lot...
        self._needs_check = True
