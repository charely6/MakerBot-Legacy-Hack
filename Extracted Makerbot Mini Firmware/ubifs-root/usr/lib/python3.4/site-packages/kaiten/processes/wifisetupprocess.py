from kaiten.processes.process import Process
import kaiten.decorator
import kaiten.enum
import kaiten.error
import kaiten.jsonrpc

class WifiSetupProcess(Process):

    _wifi_steps = kaiten.enum.enum("wifi_steps",
                               "loading",
                               "tethering",
                               "awaiting_client",
                               "client_connected",
                               "name_machine",
                               "configure",
                               "connecting",
                               "connect_error",
                               "connected")

    """A Kaiten process to guide clients through setting up wifi via tether."""
    def __init__(self, machine_manager, pymach, config, dbus):
        super().__init__(machine_manager, pymach, config, 'WifiSetupProcess')
        self._known_aps = None
        self._connect_to = None
        self._continued = None
        self._dbus_handle = dbus
        self._connect_failed = None
        self._keep_tether_on_cancel = False
        self.ignore_all_toolhead_errors()
        self.cancellable_toolhead_errors = set()
        self._initialized = False
        self._connection_target = ''

        # A map of jsonrpcexception error codes to machine errors
        self._connect_error_map = {
            51: kaiten.error.wifi_password_required,
            52: kaiten.error.wifi_password_invalid,
            53: kaiten.error.wifi_ssid_required,
            54: kaiten.error.wifi_no_such_ssid
        }
        self._dbus_handle.set_reconnector_enabled(False)

    def _network_state(self):
        return self._machine_manager._server.network_state()

    def cancel(self, error_dict=None, keep_tether=False):
        self._keep_tether_on_cancel = keep_tether
        super().cancel(error_dict)

    def _do_initialize(self):
        """ Wait until DBus is up, then do a scan """
        self._machine_manager.push_light_state('busy')
        while not self._dbus_handle._initialized:
            yield
        self._step_change(self._wifi_steps.loading)
        # ConnMan gets seriously confused if ethernet is plugged in and you try
        # to tether, so let's make sure it's not
        yield from self._require_no_ethernet()
        self._step_change(self._wifi_steps.tethering)
        if not self._initialized:
            if self._network_state()['state'] == 'wifi':
                # We can't really run this process while connected to wifi,
                # and really we get weird, hard to track down errors if
                # connman is not in a pristine state.  So we just
                # completely reset connman here.
                yield from self._do_wifi_reset()
            self._log.info("Doing initial scan...")
            yield from self._do_scan()
            self._log.info("Enabling tether...")
            yield from self._dbus_handle.ensure_tether(True)
            self._initialized = True
        self._machine_manager.pop_light_state('busy')
        self._log.info("Initialization complete")

    def _require_no_ethernet(self):
        """
        Yield an error code if an ethernet cable is currently plugged in to the
        machine, since connman has a lot of problems actually doing the bridge
        part of tethering.
        """
        while True:
            state = self._network_state()
            if state.get('service_hash', '') == 'eth':
                old = self._machine_manager._error_id_counter
                self._machine_manager._error_id_counter += 1
                self._step_change(self._wifi_steps.connect_error,
                                  {'code': kaiten.error.wifi_ethernet_connected,
                                   'source': {},
                                   'error_id': old})
                yield from self._wait_for_continue()
                self._step_change(self._wifi_steps.loading)
            else:
                break
        yield

    def _handle_scan(self, tries=1, until=None):
        """ Scan for base stations.

        This method only handles the actual scan; it should only be called after
        calling ensure_tether(False).

        @param tries Int, default 1. Number of times to try the scan. Multiple
                     tries will accumulate unique base stations, in case a
                     base station wasn't picked up the first time
        @param until String, default None. Should be a connman service path if
                     specified. If this service path is found, _handle_scan will
                     bail out of the retry loop early.
        """
        self._known_aps = []
        for attempt in range(tries):
            self._log.info("doing scan {}".format(attempt))
            scanning_aps = None
            def scan_callback(result=None, error=None):
                nonlocal scanning_aps
                if result is not None:
                    scanning_aps = result
                if error is not None:
                    self._log.error("scan callback got error: {}".format(error))
                    scanning_aps = error
                if result is None and error is None:
                    self._log.warning("scan callback Stuck in hell")
            self._dbus_handle.wifi_scan(True, callback=scan_callback)
            while None is scanning_aps:
                yield
            if type(scanning_aps) is list:
                known_paths = [ap['path'] for ap in self._known_aps]
                for ap in scanning_aps:
                    if ap['path'] not in known_paths:
                        self._known_aps.append(ap)
                        known_paths.append(ap['path'])
                self._log.info("Scan found {} aps, total {}"\
                               .format(len(known_paths), len(self._known_aps)))
                if until in known_paths:
                    break
            else:
                self._log.error("Error scanning APs: {}".format(scanning_aps))
                yield kaiten.error.wifi_general_error
        self._log.info("Done scaning")

    def _ensure_non_empty_scan(self, scans=2, until=None, scan_retries=1):
        """ Do a scan, passing arguments on to _handle_scan. If handle_scan
        returns an empty list, try again.

        @param scans int Number of scans to aggregate.
        @param until string Service path to bail out early if detected
        @param scan_retries Number of times to restart connman and retry if
               the scan is empty
        """
        while scan_retries >= 0:
            yield from self._dbus_handle.ensure_tether(False)
            yield from self._handle_scan(scans, until)
            if not self._known_aps:
                self._log.error("Scan returned empty result, retrying")
                yield from self._dbus_handle.stop_connman()
                yield from self._dbus_handle.start_connman()
                scan_retries -= 1
            else:
                break

    def _do_scan(self):
        """ Scan for APS, get a list, stick them in the info dict.

        This method also handles step changes and tether setup.
        """
        yield from self._ensure_non_empty_scan(scans=4)

    def _wait_for_configure(self):
        """ Trap in the _configure step until a process method is called. """
        yield from self._dbus_handle.ensure_tether(True)
        self._connect_to = None
        self._step_change(self._wifi_steps.configure)
        while None is self._connect_to:
            yield

    def _do_wifi_reset(self):
        """ Reset connman, wait for it to come back, then reenable wifi

        This is used in the case where we ran wifisetupprocess while
        connected to a wifi network, so connman doesn't break.
        """
        state = 'wait'
        def reset_callback(result=None, error=None):
            nonlocal state
            state = 'error' if error else 'done'
        self._dbus_handle.wifi_reset(callback=reset_callback)
        while state == 'wait':
            yield
        if state == 'error':
            yield kaiten.error.wifi_general_error
        # wifi_enable might fail because connman is not fully up yet,
        # but once invoked, dbus should keep trying to enable wifi
        self._dbus_handle.wifi_enable()
        while self._network_state()['wifi'] != 'enabled':
            yield

    def _connect(self, connect_to):
        """ Handle the connect flow.

        This state should be invoked by the connect() process method.

        @param connect_to dict. Will be used as kwargs to
                                kaiten.dbus.wifi_connect()

        This method handles the fairly long and annoying connect flow,
        coming out of tethering mode and attempting to connect to a
        specified wireless network. Though there's only one step, there
        are a couple distinct states that it goes through:
        - Ending the tether (with ensure_tether)
        - Forcing ConnMan to scan for base stations, since it's forgotten
          all the services it knew about while tethering
        - Disconnecting from any previously-connected wifi network so we
          don't automatically reconnect to it and confuse everything
        - Attempting to connect to the specified network
        - Forgetting the old wifi network if applicable
        - Going into the correct terminal step

        After this method is done, the process should be in the connect_error
        or connected steps.
        """

        if connect_to['path'] not in [ap['path']
                                      for ap in self._known_aps]\
                                          and not connect_to['name']:
            self._log.error("Bad service path {} requested"\
                            .format(connect_to['path']))
            yield kaiten.error.wifi_general_error
        if connect_to['name']:
            self._connection_target = connect_to['name']
        else:
            self._connection_target = [network['name']
                                       for network in self._known_aps
                                       if network['path'] == connect_to['path']][0]
        self._step_change(self._wifi_steps.connecting)
        yield from self._dbus_handle.ensure_tether(False)
        yield from self._ensure_non_empty_scan(3, until=connect_to['path'])
        self._connected_ok = None
        while None is self._connected_ok:
            def wifi_callback(result=None, error=None):
                if result:
                    self._connected_ok = True
                if error:
                    self._log.error("Connect error: {}".format(error))
                    self._connected_ok = error
                if not result and not error:
                    self._log.warning("Connect callback trapped in hell!")
            connect_to['callback']=wifi_callback
            self._dbus_handle.wifi_connect(**connect_to)
            while None is self._connected_ok:
                if self._network_state()['state'] == 'wifi':
                    self._connected_ok = True
                yield
            if self._connected_ok != True:
                self._log.error("Could not connect to wifi")
                ssid_name = connect_to['name']
                if not ssid_name:
                    for ap in self._known_aps:
                        if ap['path'] == connect_to['path']:
                            ssid_name = ap['name']
                error = self._connect_error_map.get(self._connected_ok['code'],
                                                    900)
                self._log.error("Error connecting to wifi: {}"\
                                .format(self._connected_ok))
                if error == 900:
                    self._connected_ok = False
                else:
                    yield from self._trap_in_connect_failed(error,
                                                            {'ssid': ssid_name})

    def _wait_for_continue(self):
        while None is self._continued:
            yield
        self._continued = None

    def get_info_dict(self):
        """ Normal info dict plus known access points."""
        info = super().get_info_dict()
        info['aps'] = self._known_aps
        info['connection_target'] = self._connection_target
        return info

    @kaiten.decorator.process_method(['configure'])
    def connect(self, service_path:str, password:str=None, name:str=None):
        """
        Initiate the connection process to a wireless AP.

        The AP must be specfied by connman path, meaning that it
        must have shown up in a previous call to wifi_scan.  If
        wifi_scan reported that a password is required, then the
        password field will be used to connect.  Otherwise the
        password field will be ignored.

        This method will cause the process to stop broadcasting an AP and
        attempt to connect to the specified network. If connection succeeds,
        the machine will stay connected to that network; if it fails, it will
        reestablish the AP.

        This method will cause the process step to change to 'connecting'.
        If the subsequent connection attempt succeeds, the step will change to
        'connected'; if it fails, the step will change to 'connect_error'.

        @param path: Connman path of a wifi AP returned by wifi_scan
        @param password: Password for secured wifi networks
        @param name: Network name for hidden networks
        """
        self._connect_to = {'path': service_path,
                            'password': password,
                            'name': name}


    @kaiten.decorator.process_method(['connect_error',
                                      'connected',
                                      'awaiting_client',
                                      'client_connected'])
    def continue_process(self):
        """ Continue the process from its current step. """
        self._continued = True

    @kaiten.decorator.process_method(['configure'])
    def restart_configuration(self):
        """ Restart the WiFi configuration process. """
        self.tasklets.close()
        self._initialized = False
        def configure_from_restart(self):
            self._log.info("restart config: run initialize")
            yield from self._do_initialize()
            self._log.info("restart config: do connect flow")
            yield from self._from_connect_flow()
        self.tasklets = configure_from_restart(self)

    def _trap_in_connect_failed(self, error_code, error_details):
        """ Trap here until a user passes us out of the state. """
        old = self._machine_manager._error_id_counter
        self._machine_manager._error_id_counter += 1
        self._step_change(self._wifi_steps.connect_error, {'code': error_code,
                                                           'source': error_details,
                                                           'error_id': old})
        yield from self._dbus_handle.ensure_tether(True)
        yield from self._wait_for_continue()
        self.continue_from_connect()
        yield

    @kaiten.decorator.process_method(['name_machine'])
    def change_machine_name(self, machine_name:str):
        """ Change the machine name and continue the process.
        @param machine_name str Name of the machine"""
        self._machine_manager._server.change_machine_name(machine_name)
        self._continued = True

    def continue_from_connect(self):
        """This may be used by other processes *cough8 setupprocess *cough*
        to reset the internal state to a well defined point: when the machine is
        tethered, with the same known AP list as the first time it went through
        and the process is ready to attempt to connect to an AP (e.g. is in the
        configure step).
        If the process is iterated from this point, it will continue and end as
        normal. """
        self.tasklets = self._from_connect_flow()

    def _from_connect_flow(self):
        yield from self._do_connect_flow()
        self.complete = True
        yield from self.end()
        yield from self.cleanup()

    def _do_run(self):
        # This was set in _do_initialize
        self._step_change(self._wifi_steps.awaiting_client)
        yield from self._wait_for_continue()
        yield from self._do_name_flow()
        yield from self._do_connect_flow()
        yield from self._dbus_handle.ensure_tether(False)
        self._step_change(self._wifi_steps.connected)
        yield from self._wait_for_continue()

    def _do_name_flow(self):
        self._log.info("Doing name flow, awaiting connection")
        yield from self._dbus_handle.ensure_tether(True)
        self._step_change(self._wifi_steps.client_connected)
        yield from self._wait_for_continue()
        self._log.info("awaiting name")
        self._step_change(self._wifi_steps.name_machine)
        yield from self._wait_for_continue()

    def _do_connect_flow(self):
        self._log.info("awaiting configure")
        yield from self._wait_for_configure()
        yield from self._connect(self._connect_to)

    def _do_cleanup(self):
        self._machine_manager.pop_light_state('priority_busy')
        if not self._keep_tether_on_cancel:
            yield from self._dbus_handle.ensure_tether(False)
        self._dbus_handle.set_reconnector_enabled(True)
