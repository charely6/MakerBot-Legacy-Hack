import sys
import datetime
import errno
import os
import json

import kaiten.constants
import kaiten.decorator
import kaiten.error
import kaiten.log
import kaiten.util
if kaiten.constants.mock:
    import kaiten.mock

MODULE_DIR = '/sys/module/g_3dprinter/parameters'

def get_vid():
    # Just return the MakerBot VID
    return 0x23C1

def get_pid(_pid=[]):
    if not _pid: _pid.append(_get_pid())
    return _pid[0]

def _get_pid():
    if kaiten.constants.mock:
        return kaiten.mock.get_pid()
    try:
        pid_path = os.path.join(MODULE_DIR, 'idProduct')
        with open(pid_path, 'r') as f:
            return int(f.read())
    except Exception as e:
        return 0

def get_serial(_serial=[]):
    if not _serial: _serial.append(_get_serial())
    return _serial[0]

def _get_serial():
    if kaiten.constants.mock:
        return kaiten.mock.get_serial()
    try:
        serial_path = os.path.join(MODULE_DIR, 'iSerialNumber')
        with open(serial_path, 'r') as f:
            return f.read().strip()
    except Exception as e:
        return 'FIXTHISFIXTHISFIXTHIS'

class USBListener(object):
    """
    This is what is installed in the IOPollGenerator when the usb is
    "disconnected".  The purpose of this is to wait until there is something
    to read, then install an actual USBConnection object, at which point the
    usb is "connected".

    This is a little bit of a hack so that it can be registered and removed
    from the IOPollGenerator without really being an IOGenerator
    """
    def __init__(self, server, path):
        self._server = server
        self._path = path
        self._filed = os.open(self._path, os.O_RDWR | os.O_NONBLOCK)
        # Needed to register with IOPollGenerator
        self.connection = self

    def fileno(self):
        return self._filed

    def is_reader(self):
        return True

    def is_writer(self):
        return False

    def expected_run_time(self):
        #this generator seems to run between 1.2 and 1.7 seconds every time
        return datetime.timedelta(seconds=2)

    def __next__(self):
        # If this is called, we have received something...
        usb_connection = USBConnection(self._path, self._filed)
        self._server.connect_usb(usb_connection)

class USBConnection(object):
    """
    This is installed by USBListener once we are "connected".  It is passed the
    open file descriptor directly from the USBListener.
    """

    def __init__(self, path, filed):
        self._log = kaiten.log.getlogger(self)
        self._path = path
        self._filed = filed
        # This is currently the most a usb read can possibly return
        self._buff_size = 81920
        # Allocate a single buffer to read in to and keep it in memory
        # for the life of the connection.  Reads return a memory view on
        # some portion of the buffer.
        self._buffer = bytearray(self._buff_size)
        self._view = memoryview(self._buffer)
        self._stop = False
        self._hold = False # Coroutine equivalent of threading.condition

    def read(self):
        """ Not a generator because that would be stupid. """
        # Return a memory view on our read buffer (unless we get an EOF)
        n = os.readv(self._filed, [self._buffer])
        if None is n:
            return None
        elif not n:
            return b''
        else:
            subview = self._view[:n]
            return subview

    def write(self, *data):
        """
        Writes data to the socket, where data consists of zero or more byte
        arrays.  For perfomance reasons you should actually use this instead
        of concatenating several byte arrays into one.  This function is a
        python iterator; the caller must iterate completely over this function
        to ensure all data is written.
        """
        while self._hold:
            yield 0
        for datum in data:
            i = 0
            while i < len(datum):
                if self._stop: return
                try:
                    data_written = os.write(self._filed, datum[i:])
                except IOError as e:
                    if e.args[0] in (errno.EWOULDBLOCK, errno.EINTR):
                        # NB: EWOULDBLOCK == EAGAIN == 11
                        raise kaiten.error.ConnectionWriteException
                    else:
                        raise
                else:
                    i += data_written
                    self._hold = (i < len(datum))
                    yield data_written
                    self._hold = False

    def stop(self):
        """ Stops this object.  Any pending writes will be stopped. """
        self._stop = True

    def close(self):
        """
        Closes the file descriptor.  Sets the fild to None as well.
        """
        os.close(self._filed)
        self._filed = None

    def fileno(self):
        """
        Returns the file descriptor to support select sets
        """
        return self._filed

    def peer_name(self):
        return 'USB'

class USBTimeoutGenerator(object):
    """
    This contract generator is installed when usb is "connected", but it
    is not run unless no action has been taken on the usb's client queue
    for one full timeout period.
    """
    def __init__(self, server, queue, generator):
        self._server = server
        self._queue = queue
        self._generator = generator
        self._timeout = datetime.timedelta(0, 5)

    def contract_duration(self):
        return self._timeout

    def expected_run_time(self):
        return datetime.timedelta(seconds=kaiten.constants.normal_generator_time)

    def __next__(self):
        if len(self._queue) > 0:
            # We have at least one item on the queue that has been waiting
            # to be sent for at least the timeout period
            self._server.disconnect_usb(self._generator)
            raise StopIteration

class UsbMethods(object):
    """
    JSONRPC methods which should only be accessible over USB go here
    """
    def __init__(self, server):
        self._log = kaiten.log.getlogger(self)
        self._server = server

    @kaiten.decorator.jsonrpc
    def update_mac_address(self, mac_address:str, pid:str=None,
                           product_name:str=None):
        """
        Update the MAC addres of the machine over USB.

        Also optionally update the pid and product name

        @INTERNAL

        @param mac_address: MAC address we want to set the bot's to
        @param pid: The PID that should be set
        @param product_name: Product name to go along with the new MAC
        """
        if product_name:
            with open('/var/product_name', 'w') as f:
                f.write(product_name)
        else:
            product_name = kaiten.util.get_product_name()
        if '/usr/scripts' not in sys.path:
            sys.path.append('/usr/scripts')
        import UBootEnv
        with self._server._machine_manager.disable_toolhead_spi():
            env = UBootEnv.UBootEnv()
            env.read_env()

            if pid:
                self._log.info("setting pid to {0}".format('0x'+pid))
                env['pid'] = '0x' + pid
            else:
                self._log.info("setting pid to {0}".format(env['pid'][2:]))
                pid = env['pid'][2:]
            if product_name:
                self._log.info("setting product name to {0}".format(product_name))
                env['product_name'] = product_name
            iserial = '23C1' + pid.upper() + mac_address.replace(':','').upper()
            self._log.info("setting mac to {0} and iserial to {1}"
                           .format(mac_address, iserial))
            env['macaddr'] = mac_address
            env['iserial'] = iserial
            env.write_env()

    @kaiten.decorator.jsonrpc
    def set_keys(self, **kwargs:dict):
        """
        Set SSL and SSH keys/certs.

        @INTERNAL
        """
        key_paths = {
            'ssl_key':   '/var/ssl/server.key',
            'ssl_cert':  '/var/ssl/server.crt',
            'ssh_key':   '/var/ssh/ssh_host_key',
            'ssh_rsa':   '/var/ssh/ssh_host_rsa_key',
            'ssh_dsa':   '/var/ssh/ssh_host_dsa_key',
            'ssh_ecdsa': '/var/ssh/ssh_host_ecdsa_key',
        }
        for key in kwargs:
            if key not in key_paths: continue
            key_path = key_paths[key]
            key_dir = os.path.dirname(key_path)
            os.makedirs(key_dir, exist_ok=True)
            with open(key_path, 'w') as f:
                f.write(kwargs[key])
                f.flush()
                os.fsync(f.fileno())
            if key.startswith('ssh'):
                import stat
                os.chmod(key_path, stat.S_IRUSR | stat.S_IWUSR)

    @kaiten.decorator.jsonrpc
    def record_serial_dict(self, serial_dict:dict):
        """
        Record a give serial dict into a file on the filesystem.

        @INTERNAL

        @param serial_dict: Dict to be containg serial values for the bot
        """
        filepath = '/var/machine_settings/serial.json'
        kaiten.util.write_json_file(filepath, serial_dict)

    @kaiten.decorator.jsonrpc
    def get_unique_identifiers(self)->dict:
        """ Return all the machine's unique identifiers.

        @return dict of {'ethernet_mac': str,
                         'wifi_mac': str,
                         'serial_number':str,
                         'iserial':str}
        """
        ethernet_mac = kaiten.util.get_mac_address()
        iserial = kaiten.usb.get_serial()
        serial = kaiten.util.get_serial_dict().get('bot_serial', '')
        # Ape the calculation that occurs in /etc/init.d/S35wireless
        wifi_mac = ''
        try:
            parts = ethernet_mac.split(':')
            to_replace = int(parts[3][0], 16)
            d0, d1 = parts[3][0], parts[3][1]
            new = 15-to_replace
            d0 = '%x' % new
            parts[3] = d0+d1
            wifi_mac = ':'.join(parts)
        except IndexError:
            # The mac address was empty, which is unlikely but who knows
            pass
        return {'serial': serial,
                'usb_serial': iserial,
                'ethernet_mac': ethernet_mac,
                'wifi_mac': wifi_mac}

