import datetime
import ipaddress
import json
import os
import socket
import struct

import kaiten.log
import kaiten.generators

# Why is this not in socket.py???
IP_RECVORIGDSTADDR = 20

class UDPMulticastServer(kaiten.generators.IOGenerator):
    def __init__(self, ip, netmask, info_dict_callback):
        """
        ip and netmask can be updated after initialization using
        update_ip(), if they change.
        The info_dict_callback should return a dict of information
        about the machine to be sent out in the broadcast.
        """
        self._log = kaiten.log.getlogger(self)
        # This callback should return a dictionary of information to send out
        self._info_dict_callback = info_dict_callback
        self._set_machine_dict()
        self._set_bcast_ips(ip, netmask)


        # Create the socket
        connection = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        connection.setblocking(0)

        # Setup retrieval of the "sent to" address
        connection.setsockopt(socket.IPPROTO_IP, IP_RECVORIGDSTADDR, 1)

        # Bind to the server address
        server_address = ('', 12307)
        connection.bind(server_address)

        # IOGenerator initialization
        super().__init__(self, connection, True, False)

        # Create a separate reply socket
        self._send_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self._send_sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        self._send_sock.setblocking(0)

        self._stop = False
        self._rate_limit = datetime.timedelta(milliseconds=1000)
        # TODO: we would actually like for the initial send to be sent
        # from a separate contract generator, and potentially be repeated
        # several times.
        self._send_info()

    def stop(self):
        self.connection.close()
        self._send_sock.close()
        self._stop = True

    def _send_info(self):
        self._send_sock.sendto(self._machine_info, ('<broadcast>', 12308))
        self._next_send = datetime.datetime.utcnow() + self._rate_limit

    def _set_machine_dict(self):
        """
        Update the machine dict when something has changed
        """
        self._machine_dict = self._info_dict_callback()
        self._machine_info = json.dumps(self._machine_dict).encode('UTF-8')

    def reload_config(self, config):
        self._set_machine_dict()

    def update_ip(self, ip, netmask):
        self._set_machine_dict()
        self._set_bcast_ips(ip, netmask)

    def _set_bcast_ips(self, ip, netmask):
        self._bcast_ips = [ipaddress.ip_address('255.255.255.255')]
        try:
            subnet = ipaddress.ip_network(ip + '/' + netmask, False)
            self._bcast_ips.append(subnet.broadcast_address)
        except Exception:
            pass

    def _eval_incoming_packet(self, packet):
        """
        Determine if we should respond to the given packet
        """
        if datetime.datetime.utcnow() < self._next_send:
            return False
        try:
            j_packet = json.loads(packet.decode('UTF-8'))
        except ValueError as e:
            return False
        else:
            return j_packet.get('command') == 'broadcast'

    def _get_dst_ip(self, ancdata):
        """ Parse the destination IP address out of the ancillary data """
        # God this is ugly
        def is_dst_addr(msg):
            return msg[0] == socket.IPPROTO_IP and msg[1] == IP_RECVORIGDSTADDR
        dst_bytes = [m[2] for m in ancdata if is_dst_addr(m)][0]
        return ipaddress.ip_address(dst_bytes[4:8])

    def _check_ancdata(self, ancdata):
        """ Check if we should respond to this based on ancillary data """
        ip = self._get_dst_ip(ancdata)
        return ip in self._bcast_ips

    def expected_run_time(self):
        return datetime.timedelta(seconds=kaiten.constants.normal_generator_time)

    def __next__(self):
        if not self._stop:
            try:
                data, ancdata, flags, addr = self.connection.recvmsg(1024, 32)
                if not self._check_ancdata(ancdata):
                    return
            except Exception as e:
                pass
            else:
                if self._eval_incoming_packet(data):
                    self._send_info()

