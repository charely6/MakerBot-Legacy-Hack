import builtins
import functools
import io
import kaiten

class Debug(object):
    def __init__(self, server):
        self._server = server
        self._globals = {}
        self._printed = []

    def _set_globals(self):
        self._globals.update({
            '__builtins__': builtins,
            'print': self._print,
            'kaiten': kaiten,
            'self': self._server,
            'gen_bt': self._gen_bt,
            'log_calls': self._log_calls,
        })

    def _do_eval(self, expr):
        """
        Actually perform the evaluation.  Any exception raised here
        will be caught and sent back to the client as a string.
        """
        try:
            code = compile(expr, 'debug', 'eval')
        except SyntaxError:
            code = compile(expr, 'debug', 'exec')
        result = eval(code, self._globals)
        if result is None:
            return []
        else:
            return [ascii(result)]

    @kaiten.decorator.raise_priv
    @kaiten.decorator.jsonrpc
    def debug(self, expr:str) -> list:
        """
        Evaluate the given expression.

        The expression is evaluated from within the context of kaiten's
        server object, which can be accessed with the variable 'self'.
        This is only intended for use by the onboard repl.

        @INTERNAL
        @param expr: The expression to evaluate
        @return: A list of strings to be printed.
        """
        self._set_globals()
        try:
            result = self._do_eval(expr)
        except Exception:
            import traceback
            result = [traceback.format_exc()]
        printed = self._printed
        self._printed = []
        return printed + result

    def _print(self, *args, **kwargs):
        """
        Accessible via the debug repl as print(), this overrides the
        built in print method to print to the debug repl prompt via
        self._printed.  We do not override when file is set.
        """
        output = io.StringIO()
        kwargs.setdefault('file', output)
        builtins.print(*args, **kwargs)
        output_str = output.getvalue()
        if not output_str: return
        elif output_str.endswith('\n'):
            output_str = output_str[:-1]
        self._printed.append(output_str)

    def _gen_bt(self, gen):
        """
        Accessible via the debug repl as gen_bt(), this prints out a
        stack trace through a suspended generator to track the chain
        of yield from calls all the way back to a final yield (or
        until we yield from something that is not a generator)
        """
        import inspect
        import dis
        import gc
        import traceback
        while inspect.isgenerator(gen):
            # Print out a single stack entry for this generator
            self._printed.extend(traceback.format_stack(gen.gi_frame))
            # Check if we are on a "yield from" opcode
            opcode = gen.gi_code.co_code[gen.gi_frame.f_lasti+1]
            if opcode != dis.opmap['YIELD_FROM']: break
            # The yield from opcode yields from the top of the value
            # stack, and the frame object gc traverser always traverses
            # the value stack last, from bottom to top...
            gen = gc.get_referents(gen.gi_frame)[-1]

    def _log_calls(self, obj, attr, condition=None):
        """
        Accessible via the debug repl as log_calls(), this logs all
        calls to obj.attr, where obj can be a module, class, or
        instance.  Note that for instances, only calls through that
        instance will be logged.  This will not work on instances of
        built in types.  Returns an object with a list attribute,
        which lists (args, kwargs, result, exc) tuples.  The returned
        object can also stop() logging calls and close() the list.

        You can also pass in a condition function that will get executed
        with the same (*args, **kwargs) as obj.attr.  The return value
        will determine whether to actually log the call, which can help
        filter down a very spammy call.  If the condition raises but
        obj.attr does not, the final exc log entry will be what was
        raised by condition.

        Attaching multiple logs to the same (obj,attr) pair is a very bad
        idea, since unless they are removed in exactly the reverse of the
        order they were added they will get stuck in place with no good
        way to remove them.
        """
        old_attr = getattr(obj, attr)
        if not hasattr(old_attr, '__call__'):
            raise AttributeError('%r.%s is not callable' % (obj, attr))

        # We want to handle instances differently, but only if the attribute
        # belongs to the class of the instance (ie a method) and not the
        # instance itself (ie a callback)
        is_instance = not (isinstance(obj, type) or type(obj) is type(kaiten))
        if is_instance and attr in (getattr(obj, '__slots__', 0) or vars(obj)):
            is_instance = False
        if is_instance:
            old_attr = getattr(type(obj), attr)

        # The hook that gets installed is the same for both cases
        call_list = []
        @functools.wraps(old_attr)
        def hook(*args, **kwargs):
            exc = None
            try:
                do_log = not condition or condition(*args, **kwargs)
            except Exception as e:
                do_log = False
                exc = e
            try:
                result = old_attr(*args, **kwargs)
            except Exception as e:
                if do_log: call_list.append((args, kwargs, None, e))
            else:
                if do_log: call_list.append((args, kwargs, result, exc))
                return result

        # For method calls we insert a new class in our mro.  Otherwise
        # we just replace the attribute in question.
        if is_instance:
            old_class = obj.__class__
            def cleanup_action(): obj.__class__ = old_class
            class new_class(old_class): pass
            setattr(new_class, attr, hook)
            for class_attr in ('__module__', '__qualname__', '__doc__'):
                setattr(new_class, class_attr, getattr(old_class, class_attr))
            obj.__class__ = new_class
        else:
            def cleanup_action(): setattr(obj, attr, old_attr)
            setattr(obj, attr, hook)

        return ListRetriever(call_list, cleanup_action)

class ListRetriever(object):
    """
    Allow access to a shared list which accumulates objects and a
    callback which stops and cleans up the objects doing the
    accumulating.  Cleanup will occur automatically if this handle
    is lost.
    """

    def __init__(self, list, cleanup_action=None):
        self.list = list
        self._cleanup_action = cleanup_action

    def stop(self):
        if self._cleanup_action:
            self._cleanup_action()
            self._cleanup_action = None

    def close(self):
        self.stop()
        self.list[:] = []

    def __del__(self):
        self.close()

