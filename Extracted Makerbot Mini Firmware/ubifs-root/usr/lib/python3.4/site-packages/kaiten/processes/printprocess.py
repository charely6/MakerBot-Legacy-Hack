import ctypes
import datetime
import json
import os
import zipfile

import mbcoreutils.tool_mappings

import kaiten.activities
import kaiten.constants
import kaiten.decorator
import kaiten.enum
import kaiten.error
import kaiten.thingiverse
import kaiten.usb
import kaiten.util

from kaiten.processes.process import Process

import tinything.tinything

class PrintProcess(Process):

    def __init__(self, machine_manager, pymach,
            libparser, filepath, config, client,
            ensure_build_plate_clear=None,
            transfer_wait=False):
        """
        PrintProcess Implementation
        """
        super(PrintProcess, self).__init__(machine_manager, pymach, config)
        self._client = client
        self._method = client.method
        if client.account:
            self.username = client.account.username
        else:
            self.username = client.name
        self._config = config
        self.methods_of_print = kaiten.enum.enum("method_of_print",
            "flash_drive",
            "onboard_storage",
            "usb",
            "network",)
        self._print_module = libparser
        # We don't initialize the filepath here
        # in case it needs to be downloaded, copied, etc.
        # Instead, keep the filepath in filename and send it in info dict.
        self.filepath = None
        self.filename = filepath
        self._slice_config = None
        self._input_filepath = filepath
        self._can_print_again = False
        self._bad_print_file = False
        self._idle_enabled = True
        self._ensure_build_plate_clear = ensure_build_plate_clear
        self._expend_buffer_state = True
        self._suspended_moved_z = False
        self._z_homed = False
        self._set_contract_duration(5)
        self._cached_generator = None
        self._progress = 0
        self.elapsed_time = datetime.timedelta(0)
        self._previous_time = None
        self._current_time = None
        self._build_plate_cleared = False
        self._error_step_acknowledged = None
        self._failed_step_acknowledged = None
        self._completed_step_acknowledged = None
        self._completion_when_actually_done = 0
        self._print_steps = kaiten.enum.enum("print_steps",
            "initializing",
            "initial_heating",
            "final_heating",
            "cooling",
            "homing",
            "position_found",
            "preheating_resuming",
            "calibrating",
            "printing",
            "end_sequence",
            "cancelling",
            "suspending",
            "suspended",
            "unsuspending",
            "preheating_loading",
            "preheating_unloading",
            "loading_filament",
            "unloading_filament",
            "stopping_filament",
            "cleaning_up",
            "clear_build_plate",
            "error_step",
            "loading_print_tool",
            "waiting_for_file",
            "transfer",
            "failed",
            "completed",
            "handling_recoverable_filament_jam")
        self._preemptible_steps = {self._print_steps.failed,
                                   self._print_steps.completed}
        self._printing_steps = {self._print_steps.printing,
                                self._print_steps.preheating_resuming}
        self._filament_steps = {self._print_steps.preheating_loading,
                                self._print_steps.preheating_unloading,
                                self._print_steps.loading_filament,
                                self._print_steps.unloading_filament}
        self._unsuspend_steps = {self._print_steps.stopping_filament,
                                 self._print_steps.unsuspending}
        self._suspended_steps = {self._print_steps.suspending,
                                 self._print_steps.suspended,
                                 self._print_steps.handling_recoverable_filament_jam}
        self._terminal_steps = {self._print_steps.end_sequence,
                                self._print_steps.cancelling,
                                self._print_steps.cleaning_up}
        self._terminal_hold_steps = {self._print_steps.failed,
                                     self._print_steps.completed}
        self._load_tool_steps = {self._print_steps.loading_print_tool}
        self._handled_steps = self._preemptible_steps\
                              | self._printing_steps\
                              | self._filament_steps\
                              | self._unsuspend_steps\
                              | self._suspended_steps\
                              | self._terminal_steps\
                              | self._terminal_hold_steps\
                              | self._load_tool_steps
        self.step = self._print_steps.initializing

        # we populate everything that requires unzipping the print file
        # during initialization
        self._meta_data = {}
        self._meta_data_info = {}
        self._time_estimation = None
        self._extruder_temperatures = []
        self._extrusion_percent = 0
        self._total_filament = 0
        self._thing_id = None

        # We need to keep track of start sequence completion to mark when the
        # printer understands its own location
        self._did_start_sequence = False
        self._gantry_homed = False
        self._cleanup_run = False
        # Local instance of cloud print history object
        self._print_history_object = None
        self._print_history_states = kaiten.enum.enum("print_history_states",
            "printing",
            "suspended",
            "failed",
            "cancelled",
            "completed")
        self._update_toolhead_errors()
        # I hate this, and myself
        self._parser_suspend_history = []
        # State for suspends
        self._pre_suspend_temperatures = None
        self._pre_suspend_fan_state = None
        self._iterating_print_generator = True
        self._transfer_wait = transfer_wait
        self._progress_from_transfer = False
        self._transfer_begun = False
        if self._transfer_wait:
            # Waiting for a transfer is implemented by transfer callbacks
            # Do not set step to waiting_for_file here to avoid
            # fast switching between screens on printerpanel
            self._machine_manager._server.add_transfer_callback(
                filepath, self.transfer_progress)
        # Used for analytics
        self._error_history = {
            "is_suspended" : False,
            "suspended_from_error" : False,
            "last_suspend_error" : None,
        }
        self._began_toolpath = False
        self._do_terminal_autounload = None
        self._cease_autounload = None
        self._cancel_sound = True
        self._allowed_jams = 0
        self._last_jam = datetime.datetime.utcnow()
        self._tool_usage_cache = {}

    def _create_event_log_message(self, msg, event_type, error_dict=None):
        """
        PrintProcess Implementation
        """
        log_string = super()._create_event_log_message(msg, event_type, error_dict)

        log_string =\
            log_string.rstrip() + "\nElapsed Print Time: {0} hours".format(
            kaiten.util.seconds_to_hours(self.elapsed_time.total_seconds()))

        return log_string

    def _trap_in_error_step(self, error_code:int, error_details:dict=None):
        with self._machine_manager.light_context("error"):
            original_step = self.step
            self._machine_manager._server.play_buzzer("error")
            old = self._machine_manager._error_id_counter
            self._machine_manager._error_id_counter += 1
            self._step_change(self._print_steps.error_step,
                              {'code' : error_code,
                               'source': error_details,
                               'error_id': old})
            # Request input from any client
            self._log.info("In error step for error {0}".format(error_code))
            # Wait for either the process method to let us past,
            # or some client to cancel
            while None is self._error_step_acknowledged:
                yield
            self._error_step_acknowledged = None
            self._step_change(original_step)

    def _initialize_print_metadata(self):
        """
        Sets all process state variables that are based on
        .makerbot metadata
        TODO: This can be cleaned up quite a bit
        """
        archive = tinything.tinything.TinyThing(self.filepath)
        if not archive.unzip_metadata():
            self._can_print_again = False
            self._bad_print_file = True
            yield kaiten.error.bad_print_file
        tools = self._machine_manager.configured_tools
        pid = kaiten.usb.get_pid()
        tool_ids = [t.id for t in tools]
        self._log.info("Check match for {}, {}".format(tool_ids, pid))
        error = archive.does_metadata_match(tool_ids, pid)
        error_translation = {
            tinything.tinything.errors['ok']:
                kaiten.error.ok,
            tinything.tinything.errors['tool_mismatch']:
                kaiten.error.print_extruder_mismatch,
            tinything.tinything.errors['bot_type_mismatch']:
                kaiten.error.print_machine_mismatch,
            tinything.tinything.errors['version_mismatch']:
                kaiten.error.print_version_mismatch
        }
        self._meta_data = archive.get_metadata()
        # Keep around the slice profile for analytics purposes
        self._slice_config = archive.get_slice_profile()
        self._log.info("metadata {0}".format(self._meta_data))
        del archive
        # Tool mismatches may be overridden if the user thinks they're smarter
        # than us and wants to enter the ~DANGER ZONE~. So we step change to
        # an error handling step and spin while we wait for a process method
        # to tell us how to proceed.
        if error == tinything.tinything.errors['tool_mismatch']:
            nice_file_types = [mbcoreutils.tool_mappings.type_to_type_name[tt]
                               for tt in self._meta_data['tool_type']]
            nice_cur_types = [t.type_pretty_name
                              for t in tools]
            self._log.info("Error tool mismatch, file type {} current type {}"
                           .format(nice_file_types, nice_cur_types))
            # TODO: When it’s public that we’re developing a dual printer, allow
            # that this is really a list to leak
            yield from self._trap_in_error_step(
                kaiten.error.print_extruder_mismatch,
                {'file_tool': nice_file_types[0],
                 'current_tool': nice_cur_types[0]})

        elif error != tinything.tinything.errors['ok']:
            self._log.error(".makerbot does not match machine config! Error: "
                            .format(repr(error)))
            self._can_print_again = False
            yield error_translation[error]



        if not self._meta_data['uses_raft']\
           and self._config['extra_slicer_settings']['plate_variability'] > 0.8:
            yield from self._trap_in_error_step(kaiten.error.print_raft_disabled)

        self._time_estimation = self._meta_data["duration_s"]
        self._total_filament = sum(self._meta_data['extrusion_mass_g'])

        # Pull in some metadata keys to put in process info dict
        metadata_keys = ["extrusion_mass_g",
                         "extrusion_distance_mm"]
        for key in metadata_keys:
            if key in self._meta_data:
                self._meta_data_info[key] = self._meta_data[key]
        self._extruder_temperatures = self._meta_data['extruder_temperature']
        self._chamber_temperature = self._meta_data['chamber_temperature']
        for idx, temp in enumerate(self._extruder_temperatures):
            self._environment["EXTRUDER_{}_TEMPERATURE".format(idx)]\
                = self._extruder_temperatures[idx]
        self._environment["CHAMBER_TEMPERATURE"] = self._chamber_temperature
        self._log.info("environment {0}".format(self._environment))

        # set thing ID if its included in the metadata
        self._thing_id = self._meta_data["thing_id"]
        analytics_info = self._print_analytics_info()
        analytics_info.update({
            'slice_id': self._meta_data.get('uuid', ''),
            'thing_id': self._meta_data.get('thing_id', ''),
            'file_size': self._meta_data.get('file_size', 0),
            'duration_s': self._meta_data.get('duration_s', 0.0),
            'extrusion_mass_g': self._meta_data["extrusion_mass_g"],
            'bounding_box': {
                'x': {'min': self._meta_data.get('bounding_box_x_min', 0),
                      'max': self._meta_data.get('bounding_box_x_max', 0)},
                'y': {'min': self._meta_data.get('bounding_box_y_min', 0),
                      'max': self._meta_data.get('bounding_box_y_max', 0)},
                'z': {'min': self._meta_data.get('bounding_box_z_min', 0),
                      'max': self._meta_data.get('bounding_box_z_max', 0)}},
            'extruder_temperature': self._meta_data['extruder_temperature'],
        })
        flat_slice_config = {}
        def flatten(to_flatten, flattened, stack=''):
            for key in to_flatten:
                if type(to_flatten[key]) is dict:
                    flatten(to_flatten[key], flattened, stack+key+'/')
                elif type(to_flatten[key]) is list:
                    for idx, elem in enumerate(to_flatten[key]):
                        if type(elem) is dict:
                            flatten(elem, flattened, stack+key+'/'+str(idx)+'/')
                        else:
                            flattened[key+'/'+str(idx)] = elem
                else:
                    flattened[stack+key] = to_flatten[key]
        flatten(self._slice_config, flat_slice_config)
        self._log.info("flattened slice config: {}".format(flat_slice_config))
        analytics_info.update(flat_slice_config)
        self._machine_manager._server\
                             .mixpanel_event('print_info', self._client,
                                             **analytics_info)
        yield kaiten.error.ok

    def _print_analytics_info(self):
        return {'step': self.step,
                'progress': self._progress,
                'elapsed_time': int(self.elapsed_time.total_seconds()),
                'process_id': self._process_id}

    def _should_clear_build_plate(self):
        """
        If the LCD initiated this print or the bot is a tinkerbell, we don't
        ask to clear the build plate; otherwise we default to the config's value
        """
        if self._ensure_build_plate_clear is not None:
            return self._ensure_build_plate_clear
        elif self._method in ('printerpanel', 'usb'):
            return False
        else:
            return self._config["kaiten"]["clear_build_plate"]

    def _should_wait_on_completed(self):
        """
        Return whether a successful print should chante to a 'completed' state
        and wait for a cancel or acknowledge from the client.
        """
        return self._config["kaiten"]["wait_on_completed"]

    def _initialize_file(self):
        """
        PrintProcess Implementation
        """
        self._log.debug("Initializing %s", self.filepath)
        self._toolpath_file = self.filepath
        yield from self._initialize_print_metadata()
        self._pymach.load_print_meta_settings(bytes(json.dumps(self._meta_data),
                                                    'UTF-8'))
        self._log.debug("Done Initializing %s", self.filepath)
        return kaiten.error.ok

    def _initialize_parser(self):
        """
        PrintProcess Implementation
        This is a generator so that subclasses can override it with
        code that actually makes sense as a generator.  This should
        be postponed for as long as possible in the print process
        since it might wait for completion of a slow file transfer.
        In order to accomplish this, it is invoked from start.json
        as 'wait_for_file'.
        """
        yield from self._wait_for_transfer()
        yield from self._initialize_file()
        self._create_print_history()
        self._machine_parser_interface = self._pymach.create_parser_interface()
        axis_count = 3 + self._machine_manager.extruder_count()
        self._jtparser\
            = self._print_module.CreateJTParser(self._machine_parser_interface,
                                                ctypes.c_char_p(bytes(self.filepath, "UTF-8")),
                                                ctypes.c_size_t(axis_count),
                                                ctypes.c_int(-1))
        yield

    def _set_filepath(self):
        """
        Set self.filepath to an appropriate path in current_print_dir.
        This path may or may not exist until _ensure_filepath is invoked.
        """
        filepath = self._input_filepath
        current_print_dir = kaiten.constants.current_print_dir
        filepath = os.path.normpath(os.path.abspath(filepath))
        dirname, basename = os.path.split(filepath)
        current_print_dir_filepath = os.path.join(current_print_dir, basename)
        if os.path.samefile(dirname, current_print_dir):
            # The file is already exactly where we want it to be
            pass
        elif filepath.startswith(os.path.join(kaiten.constants.home_dir, 'things')):
            # Printing from internal storage, so we can just symlink it
            os.symlink(filepath, current_print_dir_filepath)
        else:
            # USB storage or other unstable location, we have to copy
            # to a local spot
            yield from kaiten.util.copy(filepath, current_print_dir_filepath)
        # Now that we've ensured we have a valid copy to print again from,
        # set this flag to True unless we are waiting for file and
        # it's still transfering
        if not self._transfer_wait:
            self._can_print_again = True
        self.filepath = current_print_dir_filepath

    def _cleanup_filepath(self):
        """
        If we actually have a valid print file, move it to last_print_dir
        """
        if not self._can_print_again:
            # If this is false we didn't finish copying or transferring the print file,
            # so we don't have something that we can print again from.
            if self.filepath is not None and \
               (os.path.exists(self.filepath) or os.path.islink(self.filepath)):
                self._log.info("Removing filepath {0}".format(self.filepath))
                os.remove(self.filepath)
            if self.filename is not None and \
               os.path.exists(self.filename) and \
               (self._transfer_wait or self._bad_print_file):
                self._log.info("Deleting incomplete or corrupt {0}".format(self.filename))
                os.remove(self.filename)
        else:
            last_print_dir = kaiten.constants.last_print_dir
            basename = os.path.basename(self.filepath)
            try:
                os.rename(self.filepath, os.path.join(last_print_dir, basename))
            except OSError as ose:
                self._log.warning("Could not rename {0}: {1}. May not exist."\
                                  .format(self.filepath, repr(ose)))

    def transfer_progress(self, progress, done):
        """
        Track transfer progress but do not change steps in here that way
        progress updates can happen in the background while in a state
        (e.g. track progress while asking for user to clear buildplate)
        """
        if not self._transfer_wait:
            raise StopIteration
        self._transfer_begun = True
        if progress != self._progress and self._progress_from_transfer:
            self._log.debug("Transfer {0}".format(progress))
            self._progress = progress
            # This process isn't actually iterating during transfer, so
            # machine_manager is not iterating in sync with this progress
            # function.  So we need to directly update our progress.
            self._machine_manager._update_process_info()
        if done:
            self._transfer_wait = False
            self._can_print_again = True
            self._progress_from_transfer = False
            self._machine_manager._server.notify_client('lcd', 'print_file_valid',
                                                        {'filepath': self.filepath})

    def _wait_for_transfer(self):
        """
        Wait for file transfer
        """
        if self._transfer_wait:
            self._log.info("Waiting for transfer of %s", self.filepath)
            self._cancellable = True
            self._progress_from_transfer = True
            while self._transfer_wait:
                # Let printerpanel show clear_build_plate dialog
                # and track transfer progress in the background;
                # No progress bar if 0% progress, else report progress.
                if not self._transfer_begun:
                    self._step_change(self._print_steps.waiting_for_file)
                else:
                    self._step_change(self._print_steps.transfer)
                yield

    def _do_initialize(self):
        """
        PrintProcess Implementation
        """
        # HACK to make fre print reload config after zcal
        self._config = self._machine_manager._server.get_config()
        with self._machine_manager.light_context("print"):
            self._log_event(80*'-' +
                "\nPrint Started from {0}".format(self._method),
                "print_started")
            self._machine_manager._server\
                                 .mixpanel_event("print_started",
                                                 self._client,
                                                 **self._print_analytics_info())
            # Initialize pre_suspend_temperatures so there's no exceptions if start
            # script doesn't heat
            self._pre_suspend_temperatures = self._pymach.get_temperature_settings()
            # BW-1292 - Disable printing if the iserial is not set
            iserial = kaiten.usb.get_serial()
            if len(iserial) != 20 or iserial[0:4] != '23C1' or \
              iserial[8:14] != '3C7059':
                self._log.error("Not allowed to print without mac/iserial set")
                yield kaiten.error.no_mac_address_set
            if self._config['home']['z_calibration_type'] == 'endstop':
                yield from self._verify_calibrated()
            yield from self._set_filepath()
            yield from self._do_clear_build_plate()
            self._log.info("Beginning print of {0} from client {1} via method {2}".format(
                self.filepath,
                self._client.get_log_name(),
                self._method))
            yield from self._pymach.clear_all_z_pause()

    def _set_requires_heating(self, requires_heating:bool):
        """
        PrintProcess implementation

        This override is required so that the hold watchdog error doesn't
        immediately cancel the print. This is because it can occasionally
        happen if the parser gets too loaded down and doesn't return control
        to Kaiten quick enough.
        """
        super()._set_requires_heating(requires_heating)
        if requires_heating:
            self.cancellable_toolhead_errors\
                .discard(kaiten.error.heater_hold_watchdog_triggered)

    def _update_toolhead_errors(self):
        """
        Updates ignorable_toolhead_errors and cancellable_toolhead_errors
        based on the current step.
        """

        # Define our 5 cases


        if self.step in self._printing_steps:
            # If we are printing, we generally want to suspend
            # not cancel, except for these errors listed below
            self.cancellable_toolhead_errors = {
                kaiten.error.thermocouple_data_unchanging,
                kaiten.error.tool_fan_short,
                kaiten.error.tool_short,
                kaiten.error.heater_short,
                kaiten.error.carriage_not_connected,
                kaiten.error.chamber_not_connected,
                kaiten.error.chamber_heater_disconnected,
                kaiten.error.chamber_heater_failure,
                kaiten.error.chamber_fan_failure,
                kaiten.error.chamber_thermistor_disconnected,
                kaiten.error.chamber_temperature_overrun,
                kaiten.error.watchdog_triggered,
                kaiten.error.unusual_stall_condition
            }
            self.ignorable_toolhead_errors = set()
            self._set_requires_heating(True)

        elif self.step in self._unsuspend_steps:
            # Unsuspending is like printing but we don't care about jams
            self.cancellable_toolhead_errors = {
                kaiten.error.thermocouple_data_unchanging,
                kaiten.error.heater_rise_watchdog_triggered,
                kaiten.error.heater_temperature_sag_triggered,
                kaiten.error.heater_temperature_overrun_triggered,
                kaiten.error.tool_fan_open,
                kaiten.error.tool_fan_short,
                kaiten.error.tool_short,
                kaiten.error.heater_short,
                kaiten.error.carriage_not_connected,
                kaiten.error.chamber_not_connected,
                kaiten.error.chamber_heater_disconnected,
                kaiten.error.chamber_heater_failure,
                kaiten.error.chamber_fan_failure,
                kaiten.error.chamber_thermistor_disconnected,
                kaiten.error.chamber_temperature_overrun,
                kaiten.error.watchdog_triggered
            }
            self.ignorable_toolhead_errors = {
                kaiten.error.filament_slip
            }
            self._set_requires_heating(True)
        elif self.step in self._filament_steps:
            # If we get most errors during filament, we
            # want to stop loading filament, and then go back
            # to suspended.
            self.ignorable_toolhead_errors = {
                kaiten.error.no_filament,
                kaiten.error.filament_slip
            }
            self.cancellable_toolhead_errors = set()
            self._set_requires_heating(True)
        elif self.step in self._load_tool_steps:
            self.ignorable_toolhead_errors = (
                kaiten.error.toolhead_errors - {kaiten.error.print_tool_connect_failed}
                )
            self.cancellable_toolhead_errors = set()
        elif self.step in self._suspended_steps:
            # We're suspended, or suspending, so just throw
            # up warnings for most errors
            self.ignorable_toolhead_errors = {
                kaiten.error.no_filament,
                kaiten.error.filament_slip,
                kaiten.error.door_interlock_triggered
            }
            self.cancellable_toolhead_errors = set()
            self._set_requires_heating(False)
        elif self.step in self._terminal_steps:
            # We're ending anyway, so don't cancel
            self.ignorable_toolhead_errors = {
                kaiten.error.unusual_stall_condition,
                kaiten.error.no_filament,
                kaiten.error.filament_slip,
                kaiten.error.door_interlock_triggered
            }
            self.cancellable_toolhead_errors = set()
            self._set_requires_heating(True)
        elif self.step in self._terminal_hold_steps:
            # We are done with actually printing and are just sitting there
            # waiting for user input, so don't complain if, for instance,
            # someone removes the tool or the filament.
            self.ignore_all_toolhead_errors()
            self.cancellable_toolhead_errors = set()
            self._set_requires_heating(False)
            self._log.info("In terminal hold step, errors ignored")
        else:
            # When we are starting up, we won't suspend,
            # so we need to cancel instead.
            # We will cancel on all but a few innocuous errors
            self.ignorable_toolhead_errors = {
                kaiten.error.filament_slip
            }
            self.cancellable_toolhead_errors = (
                kaiten.error.toolhead_errors - self.ignorable_toolhead_errors)
            self._set_requires_heating(True)

    def _handle_step_alias(self, step):
        """"
        Handle steps of different names in a similar way
        Useful for having internal steps (for use with process_method decor)
        while having a sibling step used for client notifications
        """

        #"pre_toolpath" is an internal step used for process_method blocking
        #to the outside world it is the same as "printing"
        if step == self._print_steps.pre_toolpath:
            new_step = self._print_steps.printing

    def _step_change(self, step, error_dict=None):
        """
        Override Implementation
        """
        if step != self.step:
            super()._step_change(step, error_dict)
            if step in self._preemptible_steps:
                self.anything_preempts = True
            else:
                self.anything_preempts = False
            self._update_toolhead_errors()

    def _cloud_enabled(self):
        """
        Checks to see if we have activated cloud on this bot
        """
        if "enable_cloud" in self._config["kaiten"]:
            return self._config["kaiten"]["enable_cloud"]
        else:
            return False

    def _format_error_message(self, error_code):
        # TODO: use code gen for this, instead of this awful hack
        if error_code == kaiten.error.no_filament:
            return "out of filament"
        elif error_code == kaiten.error.filament_slip:
            return "filament jam"
        else:
            return "an error occurred"

    def _create_print_history(self):
        """
        Create print history object if:
         - we are online
         - the connection has an associated thingiverse token
         - the .makerbot file has a thing_id and uuid
         - print history updates are set to true in config
         - cloud has been enabled
        """
        thing_id_key = "thing_id"
        uuid_key = "uuid"

        mb_token = None
        if self._client.account:
            mb_tokens = self._client.account.makerbot_tokens
            if mb_tokens:
                mb_token = mb_tokens[0]
        if self._machine_manager._server.is_online() and mb_token and \
          thing_id_key in self._meta_data and \
          uuid_key in self._meta_data and \
          self._cloud_enabled():
            self._print_history_object = kaiten.thingiverse.Print(
                mb_token,
                self._machine_manager._server,
                self._config)
            print_object_params = {
                "name" : os.path.splitext(os.path.basename(self.filepath))[0],
                "thing_id" : self._meta_data[thing_id_key],
                "uuid" : self._meta_data[uuid_key],
                "printer_id" : self._config["kaiten"]["tv_printer_id"],
                "printer_uuid" : kaiten.usb.get_serial(),
                "printing_time" : 0,
                "state" : self._print_history_states.printing,
                "error_code" : 0,
                "error_message" : ""
            }
            try:
                self._print_history_object.create(print_object_params)
            except kaiten.error.ThingiverseException as e:
                self._log.error("Print history create failed!")
            except Exception as e:
                self._log.error("Print history create failed for unknown reason")
            else:
                self._log.debug("Created print history object")
        else:
            self._log.debug("Skipping print history updates, online: {0}, token: {1}, metadata: {2}, enabled: {3}".format(
                self._machine_manager._server.is_online(),
                mb_token is not None,
                thing_id_key in self._meta_data and uuid_key in self._meta_data,
                self._cloud_enabled()))

    def _update_print_history(self, state, error_code = None):
        """
        Updates the print history object
        """
        if self._print_history_object and \
          self._machine_manager._server.is_online():
            update_params = {
                "printing_time" : self.elapsed_time.total_seconds(),
                "state" : state
            }
            if error_code is None:
                update_params["error_code"] = 0
                update_params["error_message"] = ""
            else:
                update_params["error_code"] = error_code
                update_params["error_message"] = self._format_error_message(error_code)
            try:
                self._print_history_object.update(update_params)
            except kaiten.error.ThingiverseException as e:
                self._log.error("Print history update failed")
            except Exception as e:
                self._log.error("Print history update failed for unknown reason")
            else:
                self._log.debug("Updates print history object with id {0}".format(self._print_history_object.id()))

    def _verify_calibrated(self):
        """
        Yields an error if this bot requires per extruder calibration and
        the extruder currently attached has not been calibrated.
        """
        # Use the machine config lookup to reduce code duplication
        for idx in range(len(self._machine_manager.configured_tools)):
            extruder_config = self._machine_manager.get_extruder_config(idx)
            if not extruder_config['calibrated']:
                yield kaiten.error.tool_not_calibrated

    def _do_run(self):
        """
        PrintProcess Implementation
        """
        with self._machine_manager.light_context("print"):
            self._set_contract_duration(5)
            self._log.debug("Beginning start sequence: move 1")
            self._pymach.toggle_filament_jam(False)
            yield from self._ensure_tool_attached()
            yield from self._do_start_sequence()
            self._update_progress(0)
            self._step_change(self._print_steps.printing)
            self._set_contract_duration(100)
            yield from self._setup_jam_detection()
            self._machine_manager._server.play_buzzer("start_print")
            # Reset progress before we switch to printing, so progress from the start sequence isn't left over
            self._update_progress(0)
            self._log.info("Beginning print sequence")
            yield from self._print()
            self._step_change(self._print_steps.end_sequence)
            self._set_contract_duration(5)
            self._update_print_history(self._print_history_states.completed)

            # Do auto-unload if applicable
            if self._config['kaiten']['auto_unload'].lower()\
               in ["successful prints", "all prints"]:
                self._do_terminal_autounload = True

            self._machine_manager._server.play_buzzer("print_done")

    def _do_clear_build_plate(self):
        """
        Ask user to clear build plate if necessary and avoid asking
        again in the lifetime of the print process.
        """
        if self._should_clear_build_plate():
            with self._machine_manager.light_context("acknowledge"):
                self._step_change(self._print_steps.clear_build_plate)
                self._machine_manager._server.play_buzzer("notify")
                # Request input from any client
                while not self._build_plate_cleared:
                    yield
            # Avoids asking user to clear build plate again
            self._ensure_build_plate_clear = False

    def _do_end(self):
        """
        PrintProcess Implementation
        """
        yield kaiten.error.ok

    def _update_tool_usage(self):
        """Update the usage stats stored on the tool eeprom and retrieve them.

        This method will:
        - Update the tool EEPROM if necessary
        - Command the machine driver to update the tool EEPROM's usage stats with
          the retraction count it has accumulated over the course of the print
        - Recover the EEPROM if necessary
        - Retrieve the usage stats from the currently connected tool and put them
          in self._tool_usage_cache for later use
        """
        tool_uid = self._pymach.get_tool_uid(0)
        tool_id = self._pymach.get_tool_id(0)
        # Must make UID a string because otherwise the key sorting fails
        # when trying to dump it to file
        self._tool_usage_cache = {'uid' : str(tool_uid),
                                  'class_id' : tool_id}
        self._log.info("Updating tool usage stats...")
        yield from self._pymach.update_tool_usage_stats(0)
        for code in self._await_eeprom_transaction_finished(10, tool_uid):
            if code == kaiten.error.eeprom_update_failed:
                self._log.error("Tool usage stats update failed.")
            yield code

        usage = yield from self._pymach.get_tool_usage_stats(0, 1)
        self._tool_usage_cache.update(usage)

    def _terminal_autounload(self):
        self._log.info("Doing unload, preheating")
        yield from self._pymach.load_temperature_settings([self._config['temperature']])
        yield from self._pymach.heat()
        self._step_change(self._print_steps.preheating_unloading)
        yield from self._pymach.wait_for_heaters_at_least_target(5, [True]*self._config['toolhead_count'])
        self._log.info("Done preheating for terminal unload")
        self._step_change(self._print_steps.unloading_filament)
        yield from self._create_and_run_activity(
            kaiten.activities.UnloadFilamentActivity,
            from_suspend=True,
            as_autounload=True)

    def _do_cleanup(self):
        """
        PrintProcess Implementation

        This always runs at the end of the process.
        """
        # Avoid infinite recursion when cancelling in end step
        if not self._cleanup_run:
            # We call disable_z_pause here to account for cancels
            self._pymach.toggle_filament_jam(False)
            self._pymach.disable_z_pause()
            yield from self._pymach.toggle_fan(0, False)
            if self._z_homed:
                z_pos = self._config['axis_length']['z']
                current_z_pos = self._pymach.get_move_buffer_position()[2]
                if self._config["kaiten"]["machine_type"] == "moose":
                    if current_z_pos < z_pos - 40:
                        z_pos = current_z_pos + 40
                elif current_z_pos > z_pos:
                    # If the machine thinks we are lower than axis_length
                    # let's go with that, since we don't want to move up
                    z_pos = current_z_pos
                yield from self._ensure_move_axis(2, z_pos,
                                                  self._config['max_speed_mm_per_second']['z'],
                                                  False)
            if self._gantry_homed:
                yield from self._xypark()
            # Because autounload takes a while, we need to be able to cancel
            # doing it. Because we want to be able to allow autounload while
            # cancelling, we can't use the normal cancel mechanics to do it.
            # So we'll overload cancel() to check for this step and set this
            # instance variable.
            self._cease_autounload = False
            if self._do_terminal_autounload:
                for task in self._terminal_autounload():
                    if self._cease_autounload:
                        self._log.info("Cease autounload")
                        break
                    yield task

            self._step_change(self.steps.cleaning_up)
            try:
                yield self._print_module.DestroyJTParser(self._jtparser)
            except AttributeError as e:
                self._log.debug("%s; No jt parser to destroy")
            try:
                self._pymach.destroy_parser_interface(self._machine_parser_interface)
            except AttributeError as e:
                self._log.debug("%s: no machine parser interface to destroy")
            while not self._pymach.move_buffer_empty(ignore_toolhead=True):
                yield
            yield from self._pymach.abort()
            yield from self._pymach.cool()
            if self._config['kaiten']['store_tool_usage']:
                yield from self._update_tool_usage()
            self._end_time = datetime.datetime.utcnow()
            from pprint import pformat
            self._event_log.info("Print Info\n" +\
                pformat(self._get_minimal_print_information(), indent=4))
            if self.complete:
                self._log_event("Print Completed", "print_completed")
                analytics_info = self._print_analytics_info()
                # This will help us analyze our print progress metrics
                analytics_info['real_progress']\
                    = self._completion_when_actually_done
                self._machine_manager\
                    ._server.mixpanel_event("print_completed",
                                            self._client,
                                            **analytics_info)
            self._cleanup_filepath()
            self._cleanup_run = True
            yield from self._trap_in_end_step()

    def cancel(self, error_dict=None):
        """ Printprocess implementation

        Check if we're executing an autounload while being cancelled, and set
        a variable to notify the autounload to stop if so.
        If not executing an autounload, call the parent method.
        """
        # cease_autounload is initialized to None and set to False when
        # executing an autounload
        if self._cease_autounload == False:
            self._log.info("we're autounloading let's stop")
            self._cease_autounload = True
        else:
            self._log.info("normal cancel")
            super().cancel(error_dict)

    def _get_start_sequence_percent(self):
        """
        We want to keep track of heater percent based on the final temperature
        we are heating to, not what our current target is.
        """
        # Clamp that to 100
        return min(self._pymach.get_heater_progress_percent(), 100)

    def _home_z(self):
        # z home and do a lot of step changes
        self._step_change(self._print_steps.homing)
        z_home_activity = self._create_activity(
            kaiten.activities.ZHomeActivity,
            preheat=False)
        z_home_activity.set_event_handler(
            z_home_activity.events.position_found,
            lambda: self._step_change(self._print_steps.position_found))
        z_home_activity.set_event_handler(
            z_home_activity.events.starting_fine_home,
            lambda: self._step_change(self._print_steps.calibrating))
        yield from self._run_activity(z_home_activity)
        self._z_homed = True

    def _home_gantry(self):
        yield from self._create_and_run_activity(
            kaiten.activities.GantryHomeActivity,
            self._environment)
        self._gantry_homed = True

    def _heat(self, *args, **kwargs):
        """
        Heats the actual heaters.  We do some additional computation to determine
        if we are actually cooling, or heating.
        """
        current_temp = self._pymach.get_temperature(0)
        target_temp = self._pymach.get_temperature_settings()
        self._pre_suspend_temperatures = target_temp
        if target_temp[0] < current_temp:
            self._step_change(self._print_steps.cooling)
        elif self._z_homed:
            self._step_change(self._print_steps.final_heating)
        else:
            if self._z_homed:
                self._step_change(self._print_steps.final_heating)
            else:
                self._step_change(self._print_steps.initial_heating)
        yield from self._pymach.heat(*args, **kwargs)

    def _execute_seq_command(self, func_name, *params, **kwparams):
        self._log.info("Sequence: {}({}, {})".format(func_name, params, kwparams))
        try:
            override_mapping = {
                "wait_for_file": self._initialize_parser,
                "home_z": self._home_z,
                "home_gantry": self._home_gantry,
                "wait_for_heaters_at_target": self._pymach.wait_for_heaters_at_target,
                "heat": self._heat,
            }
            if func_name in override_mapping:
                yield from override_mapping[func_name](*params, **kwparams)
            else:
                if func_name == 'load_temperature_settings':
                    self._log.debug("start says temperatures {0}"\
                                    .format(params[0]))
                    for idx, setting in enumerate(params[0]):
                        if setting == "HOLD_TEMP":
                            params[0][idx] = self._pymach.get_temperature(idx)
                            self._log.debug("overriding temp for head {0}".format(idx))
                yield from self._call_pymach(func_name, *params, **kwparams)
        except Exception as e:
            self._log.exception("Uncaught {} in sequence: "
                                "executing command: "
                                "{}({},{})".format(repr(e),
                                                   func_name, params, kwparams))
            raise

    def _do_sequence(self, filename):
        
        yield from kaiten.util.process_sequence(filename,
                                                self._config,
                                                self._environment,
                                                self._execute_seq_command)

    def _do_start_sequence(self):
        """
        PrintProcess Implementation
        """
        # I'll (dgs3) be the first to admit this is potentially broken if somebody's
        # start sequence doesn't have heating in it...but common.
        homing_progress_steps = [self._print_steps.homing,
                                 self._print_steps.calibrating,
                                 self._print_steps.position_found]
        file_progress_steps = [self._print_steps.transfer,
                               self._print_steps.waiting_for_file]
        try:
            for task in self._do_sequence(kaiten.constants.start_script):
                if self.step in file_progress_steps:
                    # Progress comes from the transfer_progress callback
                    pass
                elif self.step in homing_progress_steps\
                     and self._config["home"].get("pin_progress_during_z_home",
                                                  True):
                    # awful hack to accomodate start sequence schenanigans
                    # lets find a more flexible way to do this
                    self._update_progress(77)
                else:
                    self._update_progress(self._get_start_sequence_percent())
                yield task
        except Exception as e:
            self._log.error("Error in start sequence: %s", str(e))
            raise
        else:
            self._did_start_sequence = True

    def _do_cancel(self, error_dict=None):
        """
        PrintProcess Implementation
        """
        if error_dict is None:
            # create a label that disambiguates where we are in the print
            # and containts suspend error history information
            # Because we're sending this label to domo and GA, which don't have
            # very good string/handling parsing available, we have to make these
            # fields fixed width.
            label = "{0}-{1:0>3}-{2}-{3}-{4!s:0>4}-{5:0>6}".format(
                "print" if self._did_start_sequence else "start",
                int(self._progress),
                1 if self._error_history['is_suspended'] else 0,
                1 if self._error_history['suspended_from_error'] else 0,
                self._error_history['last_suspend_error'],
                min(int(self.elapsed_time.total_seconds()), 999999))
            self._log_event("Print Cancelled", "print_cancelled")
            self._machine_manager._server\
                                 .mixpanel_event("print_cancelled",
                                                 self._client,
                                                 **self._print_analytics_info())
            self._update_print_history(self._print_history_states.cancelled)
        else:
            self._log_event("Print Failed", "print_failed", error_dict)

            analytics_info = self._print_analytics_info()
            analytics_info['error_code'] = error_dict['code']
            analytics_info['error_id'] =  error_dict['error_id']
            self._machine_manager._server.mixpanel_event("print_failed",
                                                         self._client,
                                                         **analytics_info)

            self._update_print_history(self._print_history_states.failed, error_dict["code"])
            # If we canceled because of an error, we should trap in a failed step

        #Using notifiy sound to let the user know when they are cancelling, perhaps we should have a cancel sound?
        if self._cancel_sound:
            self._machine_manager._server.play_buzzer("error")
        self._pymach.set_print_context(False, b"")
        self._step_change(self._print_steps.cancelling)
        if self._transfer_wait:
            # We have an active transfer going, but cancelling the process
            # means that transfer is going to stop - we should notify
            # the server.
            self._machine_manager._server\
                                 .clear_transfer_callbacks(self._input_filepath)
            self._client.jsonrpc.cancel_transfer(self._input_filepath)
            self._log.info("Printprocess cancelled during file transfer, "
                           "ending transfer to {0}"\
                           .format(self._input_filepath))
        if self._did_start_sequence:
            self._set_contract_duration(1)
            yield from self._pymach.quick_pause(True)
            result = False
            while result == False:
                result = self._pymach.pru_is_paused()
                yield result
            yield from self._pymach.clear_all_buffers()
            yield from self._pymach.quick_pause(False)
            yield from self._pymach.disable_z_pause()
            yield from self._expend_buffer(True)
            yield from self._pymach.toggle_toolhead_syncing(False)
            yield from self._pymach.toggle_filament_jam(False)
            self._pymach.toggle_extrusion_percent_update(False)
            position = yield from self._pymach.get_axes_position()
            yield from self._pymach.set_move_buffer_position(position)
            self._log.debug("cancelled at position: {0}".format(position))
            yield from self._pymach.toggle_fan(0, False)
            yield from self._pymach.cool()
        else:
            self._log.info("Start sequence never finished, not mopving")
        # Do auto-unload if applicable
        if self._config['kaiten']['auto_unload'].lower()  == "all prints" and\
           (not error_dict or error_dict.get("code", None) not in \
            [kaiten.error.no_filament,
             kaiten.error.no_tool_connected]):
            self._do_terminal_autounload = True
        self._log.debug("Done cancelling.")


    def _trap_in_end_step(self):
        # adds backwards compatibility; client can cancel out of end step
        self._cancellable = True
        if self.failed:
            yield from self._trap_in_failed_step()
        elif self.complete:
            yield from self._trap_in_completed_step()

    def _trap_in_failed_step(self):
        """
        Wait for user to acknowledge a failed print
        """

        with self._machine_manager.light_context("error"):
            self._step_change(self._print_steps.failed)
            while None is self._failed_step_acknowledged:
                yield
            self._error_step_acknowledge = None

    def _trap_in_completed_step(self):
        """
        Wait for user to acknowledge a successful completed print
        """

        if self._should_wait_on_completed():
            self._step_change(self._print_steps.completed)
            while None is self._completed_step_acknowledged:
                yield

    def _expend_buffer(self, state):
        self._expend_buffer_state = state
        yield from self._pymach.toggle_expend_buffer(state)

    def _get_print_progress(self):
        """ Return an estimation of print progress based on one of a 
        couple different measures. The reason for this is that our two
        measures of progress - elapsed time and extruded filament -
        flow at different rates and are inaccurate in different ways.
        If the print is small, most filament is extruded in the raft and in
        the floors and ceilings - very little in the infill and shells. This
        makes extrusion based progress jump to a high number at the beginning,
        seemingly stall in the middle, and then jump to almost done right at
        the end. In this situation, time estimation behaves better.
        However, in a long print time estimation has its own problems. When the
        time estimation is produced in the slicer, a fudge factor is applied to
        account for Bronx clock skew. For long prints, differences between the
        fudge factor and the true skew produce inaccurate time estimations. Also,
        any buffer stalling increases the elapsed time. So for long prints,
        filament is better. So this function estimates progress with:
        - Time elapsed vs time estimated if the time estimated is < 600s.
        - Extrusion percentage otherwise.
        """
        self._extrusion_percent = self._pymach.get_extrusion_distance_percent()
        if self._time_estimation\
           and self._time_estimation < kaiten.constants.max_time_for_progress:
            return int(self.elapsed_time.total_seconds()
                       / self._time_estimation * 100.0)
        else:
            return int(self._extrusion_percent)

    def _update_progress(self, progress):
        """
        PrintProcess Implementation
        """
        if self.step != 'waiting_for_file':
            # Cap progress between 0 and 99 inclusive because it is fed to clients
            self._progress = max(min(progress, 99), 0)

    def _setup_jam_detection(self):
        yield from self._pymach.load_filament_jam_settings(0, self._config["steps_per_mm"]["a"])
        yield from self._pymach.toggle_filament_jam(True)

    def _print(self):
        """
        PrintProcess Implementation
        """
        result = 0
        self._pymach.reset_extrusion_distance()
        self._pymach.toggle_extrusion_percent_update(True)
        yield from self._pymach.enable_z_pause()
        # ensure the start sequence is completely finished before toggling toolhead syncing on
        yield from self._pru_delay_loop()
        #expend buffer true for single commands, but not for printing
        yield from self._expend_buffer(False)
        yield from self._pymach.toggle_toolhead_syncing(True)
        self._log.info("Awaiting toolhead sync confirmation...")
        confcount = 0
        while not self._pymach.sync_state_confirmed(0):
            confcount+=1
            yield
        self._idle_enabled = False
        self._log.info("Got toolhead sync confirmation after {0} cycles"\
                       .format(confcount))
        self._log.info("Beginning JT parse")
        self._pymach.set_print_context(True, self.filename.encode('UTF-8'))
        result = self._print_module.ParseNext(self._jtparser)
        self._began_toolpath = True
        #Change to "printing" step once we have parsed a toolpath move
        #makes it easier to handle things like suspend

        while result != kaiten.error.json_toolpath_nothing_parsed:
            result = self._print_module.ParseNext(self._jtparser)
            self._update_progress(self._get_print_progress())
            yield result
        #put buffer back into single command state
        yield from self._expend_buffer(True)
        # we need to track the expend buffer state in case we suspend during the expend buffer stage
        self._log.info("Exhausting acceleration buffer")
        while not self._pymach.acceleration_buffer_empty():
            self._update_progress(self._get_print_progress())
            yield kaiten.error.ok
        yield from self._pymach.enable_toolhead_idle()
        self._idle_enabled = True
        self._log.info("Exhausting move buffer, disabling stall error")
        self.ignorable_toolhead_errors.add(
            kaiten.error.unusual_stall_condition)
        while not self._pymach.move_buffer_empty():
            self._update_progress(self._get_print_progress())
            yield kaiten.error.ok
        self._completion_when_actually_done = self._get_print_progress()
        # don't use _update_progress because that caps progress at 99
        self._progress = 100
        self._pymach.set_print_context(False, b"")
        yield from self._pymach.disable_z_pause()
        yield from self._pymach.toggle_toolhead_syncing(False)
        self._pymach.reset_extrusion_distance()

    def get_filament_extruded(self):
        """
        PrintProcess Implementation
        Gets filament extruded in kg
        """
        return self._extrusion_percent * 0.01 * self._total_filament

    def get_start_time(self, time):
        """
        PrintProcess Implementation
        The birdwing platform _cannot_ keep accurate time.  There is currently
        no battery for the machine, so each time we power cycle the machine
        we need to readjust the time.  We therefor need a reliable method of
        vetting out good times from bad times.
        """
        threshold = datetime.datetime(2013, 1, 1) # year, month, day
        if time < threshold:
            return None
        else:
            return self._get_time_string(time)

    def get_type(self):
        """Used to determine what type of object this is
        """
        return "printprocess"

    def get_info_dict(self):
        """
        PrintProcess Implementation
        """
        if self._previous_time is None:
            self._previous_time = datetime.datetime.utcnow()
        self._current_time = datetime.datetime.utcnow()
        # Only increment elapsed time only while printing
        if self.step == self._print_steps.printing:
            self.elapsed_time += (self._current_time - self._previous_time)
        self._previous_time = self._current_time
        info = super(PrintProcess, self).get_info_dict()
        info.update({
            'progress': int(self._progress),
            'filepath': self.filepath,
            'filename': self.filename,
            # 'method_of_print': self.methods_of_print.network, #TODO: figure out method of print
            'start_time': self.get_start_time(self.start_time),
            'filament_extruded': int(self.get_filament_extruded()),
            'elapsed_time': int(self.elapsed_time.total_seconds()),
            'print_temperatures': dict(enumerate(self._extruder_temperatures)),
            'can_print_again': self._can_print_again,
            'thing_id': self._thing_id
        })
        info.update(self._meta_data_info)
        if self._time_estimation:
            info["time_estimation"] = self._time_estimation
            # Get the max with 0 so we dont look dumb and give out negative numbers
            info["time_remaining"] = max(0, int(self._time_estimation - self.elapsed_time.total_seconds()))
        return info

    @staticmethod
    def _get_time_string(the_time):
        """
        PrintProcess Implementation
        """
        return "%i:%i:%i %i/%i/%i" % (the_time.hour,
            the_time.minute, the_time.second, the_time.month,
            the_time.day, the_time.year)

    def _get_minimal_print_information(self):
        """
        PrintProcess Implementation
        """
        min_print_info = {}
        print_info = self._get_print_information()
        min_print_info["filename"] = print_info["filename"]
        min_print_info["firmware_version"] = print_info["firmware_version"]
        min_print_info["print time (hours)"] =\
            kaiten.util.seconds_to_hours(print_info["total_seconds"])
        #Pared down tool_info
        min_print_info["tool_info"] = {
            "name": print_info["tool_info"]["name"],
            "extrusion_distance_mm": print_info["tool_info"].get("extrusion_distance_mm", -1),
            "extrusion_time_s": print_info["tool_info"].get("extrusion_time_s", -1),
            "refurb_count": print_info["tool_info"].get("refurb_count", -1),
            "uid": print_info["tool_info"].get("uid", -1)
        }
        return min_print_info

    def _get_print_information(self):
        """
        PrintProcess Implementation
        """
        print_info = {}
        print_info["start_time"] =  self._get_time_string(self.start_time)
        print_info["filename"] = self.filepath
        # print_info["thingiverse_id"] = None
        print_info["method_of_print"] = self._method
        print_info["client_name"] = self._client.name
        print_info["end_time"] = self._get_time_string(self._end_time)
        print_info["completed"] = self.complete
        print_info["total_seconds"] = self.elapsed_time.total_seconds()
        tool_stats = self.get_tool_usage_stats()
        tool_stats["name"] =\
            mbcoreutils.tool_mappings.Tool.from_id(tool_stats.get("class_id", 'unknown')).name
        print_info["tool_info"] = tool_stats
        print_info["firmware_version"] = str(kaiten.util.get_fw_version())
        return print_info

    def _set_contract_duration(self, time_ms):
        """
        PrintProcess Implementation
        """
        self._contract_duration = datetime.timedelta(0, 0, 0, time_ms)


    def contract_duration(self):
        """
        PrintProcess Implementation
        """
        return self._contract_duration

    def expected_run_time(self):
        return datetime.timedelta(seconds=30)

    def handle_acknowledge(self):
        """
        PrintProcess Implementation
        """
        return True

    def handle_error(self, error_dict):
        """
        PrintProcess Implementation
        """
        self._log.info("in handle_error of printprocess - {}, step {}"\
                       .format(error_dict, self.step))
        ret = True

        # Whether we should actually emit an analytics packet
        swallow_analytics = False
        if self.step == self._print_steps.printing:
            if error_dict["code"] == kaiten.error.no_filament:
                # Hacky hack to use a different error code in this context
                error_dict["code"]\
                    = kaiten.error.out_of_filament
                self.unload_filament(error_dict=error_dict)
                self._machine_manager.push_error_light_state()
            elif (error_dict['code']
                  == kaiten.error.filament_slip)\
                 and self._allowable_jam():
                self._allow_jam()
                swallow_analytics = True
                self.suspend_and_resume(None)
            else:
                self._machine_manager.push_error_light_state()
                self.suspend(error_dict)
        elif self.step in [self._print_steps.unsuspending,
                           self._print_steps.preheating_resuming]:
            self._machine_manager.push_error_light_state()
            self.suspend(error_dict)
        elif self.step in [self._print_steps.preheating_loading,
                           self._print_steps.preheating_unloading,
                           self._print_steps.unloading_filament]:
            self.stop_filament(error_dict)
        elif self.step in [self._print_steps.loading_filament]:
            self._auto_unload_filament(error_dict)
            ret = False
        else:
            ret = False
        if ret and not swallow_analytics:
            # We have to handle our own analytics update as well as our own step
            # change
            analytics_info = self._print_analytics_info()
            analytics_info["error_code"] =  error_dict['code']
            analytics_info["error_id"] =  error_dict['error_id']
            self._machine_manager._server.mixpanel_event("print_error",
                                                         self._client,
                                                         **analytics_info)
        return ret

    def _allowable_jam(self):
        """ Determine whether this jam is allowable.
        """
        now = datetime.datetime.utcnow()
        duration = datetime.timedelta(minutes=kaiten.constants.allowable_jam_timing_min)
        # If we have jams remaining to retry, or it's been long enough
        # since the last one, we can allow this.
        return self._allowed_jams < kaiten.constants.allowable_jams\
            or (now - self._last_jam >= duration)
            

    def _allow_jam(self):
        """ Inform the internal state of printprocess that a jam has been
        allowed. """
        if not self._allowable_jam():
            raise ValueError("Attempted to allow a jam which isn't allowable")

        duration = datetime.timedelta(minutes=kaiten.constants.allowable_jam_timing_min)
        now = datetime.datetime.utcnow()
        if now - self._last_jam > duration:
            # It's been more than 2 minutes since the last jam, we can reset
            self._allowed_jams = 0

        self._allowed_jams += 1
        self._log.info("Allowed jam, restarting. Last jam at {}, {} jams"
                       " without 2 minutes between"
                       .format(self._last_jam, self._allowed_jams))
        self._event_log.info("Allowed Jam {}\n".format(self._allowed_jams))
        analytics_info = self._print_analytics_info()
        analytics_info["retry_number"] = self._allowed_jams
        self._machine_manager._server.mixpanel_event("print_retried_slip",
                                                     self._client,
                                                     **analytics_info)
        self._last_jam = now


    def _do_suspend(self, error_dict=None, do_step_change=True):
        """
        PrintProcess Implementation
        """
        self._error_history['is_suspended'] = True

        if do_step_change:
            # Step change
            self._step_change(self._print_steps.suspending, error_dict)

        self._suspend_retract_distance = self._config["suspend"]["retract_distance"]
        self._suspend_restart_distance = self._config["suspend"]["restart_distance"]
        if error_dict is not None and 'code' in error_dict:
            self._error_history['suspended_from_error'] = True
            self._error_history['last_suspend_error'] = error_dict['code']
            self._update_print_history(self._print_history_states.suspended, error_dict["code"])
            if error_dict["code"] == kaiten.error.out_of_filament:
                self._suspend_retract_distance = 0
                self._suspend_restart_distance = 0
        else:
            self._update_print_history(self._print_history_states.suspended)

        self._set_contract_duration(1)
        # libmachine suspend clears calls a quick pause, clears the move buffers in the pru and toolhead, then un-pauses
        # it is up to the kaiten process to do the suspend operations and refill the move buffers on resume
        yield from self._pymach.quick_pause(True)
        result = False
        while result == False:
            result = self._pymach.pru_is_paused()
            yield result

        # _pre_suspend_fan_state will be None before suspend and after a full resumption (no errors during resume)
        if self._pre_suspend_fan_state is None:
            # TODO: better toolhead parsing
            self._pre_suspend_fan_state = self._machine_manager.toolhead_status[0]['filament_fan_running']

        # TODO: Find a less hacky way of doing this... see the next time
        # this variable comes up for more!
        suspend_command_index = self._pymach.get_current_command_index()
        self._parser_suspend_history.append(suspend_command_index)
        self._log.info("Suspended at command index: {0}".format(suspend_command_index))
        self._load_filament_during_suspend = False
        yield from self._pymach.clear_all_buffers()
        yield from self._pymach.quick_pause(False)
        yield from self._pymach.disable_z_pause()
        # do NOT update the stored buffer expend state here, we want to keep it
        yield from self._pymach.toggle_expend_buffer(True)
        yield from self._pymach.toggle_toolhead_syncing(False)
        yield from self._pymach.toggle_filament_jam(False)
        self._pymach.toggle_extrusion_percent_update(False)
        self._pre_suspend_position\
            = yield from self._pymach.get_axes_position()
        yield from self._pymach\
                       .set_move_buffer_position(self._pre_suspend_position)
        if suspend_command_index != -1:
            error = self._print_module.Suspend(self._jtparser,
                                               suspend_command_index)
            if error == kaiten.error.suspend_no_valid_last_move:
                self._log.warning("Parser command index {0} was invalid!"\
                                  .format(suspend_command_index))
            elif error != kaiten.error.ok:
                self._log.error("Error in parser suspend: {0}".format(error))
                yield error
            else:
                self._log.info("Suspended with index, position {0}"\
                               .format(self._pre_suspend_position))
        else:
            self._pre_suspend_position = self._pymach.get_move_buffer_position()
            self._log.info("Suspended without index, position {0}"\
                           .format(self._pre_suspend_position))

        if self._suspended_moved_z:
            z_position = 0
        else:
            z_position = min([self._pre_suspend_position[2]+50,
                          self._config['axis_length']['z']])
        self._log.debug("z park position {0}".format(z_position))
        yield from self._pymach.move_axis(2, z_position, self._config['max_speed_mm_per_second']['z'], relative=self._suspended_moved_z)
        yield from self._safe_xypark()
        yield from self._pymach.move_axis(3,
                                          - self._suspend_retract_distance,
                                          5,
                                          relative=True)
        pos = yield from self._pymach.get_axes_position()
        self._log.debug("moved away during suspend, current pos {0} axes {1}"\
                       .format(self._pymach.get_move_buffer_position(),
                               pos))
        yield from self._pymach.toggle_fan(0, False)
        self._log_event("Print Suspended", "suspended", error_dict)
        self._suspended_moved_z = True
        self._set_contract_duration(500)

    def _do_unsuspend(self):
        """
        PrintProcess Implementation
        """
        self._machine_manager.clear_toolhead_error_memory()
        # reset heater watchdog before we switch to a state where it is cancellable
        yield # Catch any toolhead errors here
        self._update_print_history(self._print_history_states.printing)
        # Reset print temperature
        if any(filter(lambda temp: temp != 0, self._pre_suspend_temperatures)):
            self._progress = self._pymach.get_heater_progress_percent()
            self._step_change(self._print_steps.preheating_resuming)
            yield from self._heat_to_temperature(self._pre_suspend_temperatures)
            timeout = self._get_heater_timeout(map(lambda t: t!=0, self._pre_suspend_temperatures))
            for error_code in self._pymach.wait_for_heaters_at_least_target(timeout,
                                                                            [True]*self._config['toolhead_count']):
                self._progress = self._pymach.get_heater_progress_percent()
                yield error_code
        self._update_progress(self._get_print_progress())
        self._step_change(self._print_steps.unsuspending)
        yield from self._pymach.move([self._config["park_prep"]["x"],
                                      self._config["park_prep"]["y"],
                                      0, 0],
                                     100,
                                     [False, False, True, True])
        self._set_contract_duration(1)
        yield from self._pru_delay_loop()
        yield from self._pymach.toggle_expend_buffer(False)
        yield from self._pymach.toggle_toolhead_syncing(True)
        self._log.info("Awaiting toolhead sync confirmation...")
        confcount = 0
        while not self._pymach.sync_state_confirmed(0):
            confcount+=1
            yield
        self._log.info("Got toolhead sync confirmation after {0} cycles"\
                       .format(confcount))
        # Before suspending, idle was enabled. Suspending clears idle because
        # it clears the buffer, which means that we have to explicitly
        # reenable it.
        if self._idle_enabled:
            self._log.info("Reenabling idle after suspend")
            yield from self._pymach.enable_toolhead_idle()

        if hasattr(self, "_pre_suspend_position"):
            # If you didn't load filament while you were suspended, we have to
            # move filament back into the hot-end. To do that, we can just set our
            # positions to wherever we suspended from - after all, we'll reverse
            # the moves we made when suspending, that way. However, if we DID load
            # filament, there's filament already in the hot end and we tell the
            # machine to consider its A axis to already be in the right place.
            yield from self._pymach.move([self._pre_suspend_position[0],
                                          self._pre_suspend_position[1],
                                          self._pre_suspend_position[2],
                                          0],
                                         150,
                                         relative=[False, False, False, True])
            self._log.info("Queued move to toolpath")
            if self._load_filament_during_suspend:
                self._log.info("loaded filament, not restoring it")
            else:
                yield from self._pymach.move_axis(3,
                                                  self._pre_suspend_position[3]-2,
                                                  10,
                                                  relative=False)
                yield from self._pymach.move_axis(3,
                                                  2,
                                                  20,
                                                  relative=True)
                self._log.info("Queued filament restore")
            self._suspended_moved_z = False
            yield from self._pymach.enable_z_pause()

        yield from self._pymach.toggle_filament_jam(True)

        # ensure that the prep moves are done before turning toolhead sync back on
        #yield from self._pru_delay_loop()

        # toggle toolhead fan to pre suspend state before transitioning
        # to the print step and executing moves in the parser
        if self._pre_suspend_fan_state is not None:
            yield from self._pymach.toggle_fan(0, self._pre_suspend_fan_state)

        self._machine_manager.clear_toolhead_error_memory()
        self._step_change(self._print_steps.printing)
        self._update_progress(self._get_print_progress())
        # This new way of determing whether to call Parser::Resume is based
        # on the possibility of getting early suspends before resume is called.
        # If you suspended and got a valid index; then resumed, and got an error
        # _before_ you called Parser::Resume, you'd forget you ever had commands
        # in the parser suspend buffer. Then when you resume after the early
        # suspend, you don't call Resume, and all those commands are lost, like
        # tears in rain.
        # Instead, keep a record of all suspends, that you erase when you finally
        # get through Resume and know you're safe. If you're trying to resume,
        # and at any point you had a valid parser index, and you haven't managed
        # to get it out yet, call Parser::Resume even if you didn't get an index
        # last time you suspended.
        if any(map(lambda v: v!= -1, self._parser_suspend_history)):
            self._parser_suspend_history = []
            self._log.info("Spooling parser...")
            result = 0
            # Now we put the buffer back in the state it started
            while result != kaiten.error.resume_complete:
                result = self._print_module.Resume(self._jtparser)
                self._update_progress(self._get_print_progress())
                yield result
            self._log.info("Parser spooled, continuing")
        else:
            self._log.info("No parser suspend in history, not spooling")
            if not self._began_toolpath:
                self._log.info("Suspended before tp execution, setting pos")
                yield from self._pymach.set_position(3, 0)
        yield from self._pymach.toggle_expend_buffer(self._expend_buffer_state)
        self._pymach.toggle_extrusion_percent_update(True)
        self._set_contract_duration(100)
        # Reset the fan state here so that if we suspend again later we will
        # cache the state at that time
        self._pre_suspend_fan_state = None

    def _set_tasklets(self, generator):
        # This is a safe way to set self.tasklets
        # It ensures that if we are running the primary genetator of this process
        # then it gets cached.
        if self._iterating_print_generator:
            self._cached_generator = self.tasklets
        self._iterating_print_generator = False
        self.tasklets = generator

    def _restore_print_generator(self):
        self.tasklets = self._cached_generator
        self._iterating_print_generator = True

    @kaiten.decorator.process_method(["printing"])
    def suspend(self, error_dict=None):
        """
        Starts to put the machine in suspend mode.  The current generator is
        first cached (so it can be resumed at a later point), then the
        "_suspend" generator is set as the primary generator.
        """
        self._set_tasklets(self._suspend(error_dict))

    def suspend_and_resume(self, error_dict):
        """
        A generator that will take the machine through suspending and then
        immediately resuming without user interaction. This is meant for
        resolving transient errors, like some jams, that will probably
        fix themselves if the extruder is cleared and then flushed.
        """
        self._set_tasklets(self._suspend_and_resume_generator(error_dict))

    def _suspend_and_resume_generator(self, error_dict):
        """
        The actual generator used by suspend_and_resume
        """
        self._step_change(self._print_steps.handling_recoverable_filament_jam,
                          error_dict)
        yield from self._suspend(error_dict, loop=False, do_step_change=False)
        self._update_progress(self._get_print_progress())
        self._step_change(self._print_steps.unsuspending)
        yield from self._do_resume(None)

    def _suspend(self, error_dict, loop=True, do_step_change=True):
        """
        Suspending implementation
        """
        self._log.debug("Suspending")
        yield from self._do_suspend(error_dict, do_step_change)
        self._log.debug("Finishing Suspending")
        # This move_into_suspend has to happen in the last iteration
        if loop and self.step != self._print_steps.unsuspending:
            self._step_change(self._print_steps.suspended)
            yield from self._suspended_generator()

    def _suspended_generator(self):
        """
        Superclass Implementation
        This is the suspended generator.  It yields OK forever.
        """
        with self._machine_manager.light_context("ready"):
            while True:
                yield kaiten.error.ok

    @kaiten.decorator.process_method(["suspending", "suspended"])
    def resume(self):
        """
        Starts to unsuspend the machine.  The unsuspend generator is set as the
        primary generator.  After completion, the cached generator is reset
        as the primary generator.
        """
        self._log.info("Unsuspending process")
        if self.step == self._print_steps.suspending:
            suspend_taskets = self.tasklets
        else:
            suspend_taskets = None
        self._update_progress(self._get_print_progress())
        self._step_change(self._print_steps.unsuspending)
        self._set_tasklets(self._do_resume(suspend_taskets))

    def _do_resume(self, suspend_tasklets=None):
        if suspend_tasklets:
            # We resumed while we were still suspending, so we have to
            # finish suspending first
            yield from suspend_tasklets
        self._machine_manager.clear_error_light_states()
        self._log.debug("Unsuspending")
        #self._machine_manager.clear_toolhead_error_memory()
        # Clear toolhead error memory so that we recognize if there is still
        # an issue when a print resumes
        yield from self._do_unsuspend()
        self._log.debug("Finished Unsuspending")
        self._error_history['is_suspended'] = False
        self._machine_manager.clear_toolhead_error_memory()
        self._step_change(self._print_steps.printing)
        self._restore_print_generator()
        self._log_event("Print Resumed", "unsuspended")
        # IHATETHIS: We dont want the generator to end just yet.  It we were
        # to end, we would throw a StopIterationError and the machine_manager
        # would end our process.  So we yield one final time
        yield kaiten.error.ok

    @kaiten.decorator.process_method(["suspended"])
    def load_print_tool(self, tool_index=0):
        self._set_tasklets(self._do_load_print_tool())

    @kaiten.decorator.process_method(["printing", "suspended"])
    def load_filament(self, tool_index=0):
        # TODO: adapt to multiple toolheads
        self._set_tasklets(self._do_filament(unload=False))

    @kaiten.decorator.process_method(["printing", "suspended"])
    def unload_filament(self, tool_index=0, error_dict=None):
        # TODO: adapt to multiple toolheads
        self._set_tasklets(self._do_filament(unload=True, error_dict=error_dict))

    @kaiten.decorator.process_method(["loading_filament", "preheating_unloading", "preheating_loading"])
    def stop_filament(self, error_dict=None):
        if self._cease_autounload == False:
            # We're doing an autounload and should stop that
            self._cease_autounload = True
        else:
            # This is a normal suspended unload situation
            self._log.info("Stopping filament load")
            self._step_change(self._print_steps.stopping_filament, error_dict)
            self._set_tasklets(self._do_stop_filament())

    def _do_load_print_tool(self):
        with self._machine_manager.light_context("ready"):
            self._cancellable = False
            self._step_change(self._print_steps.loading_print_tool)
            result = yield from self._pymach.connect_tool(0, abort_toolhead_only=True)
            self._step_change(self._print_steps.suspended)
            self._cancellable = True
            yield from self._suspended_generator()

    def _auto_unload_filament(self, error_dict=None):
        self._log.info("Autounloading filament!")
        self._set_tasklets(self._do_auto_unload_filament(error_dict))

    def _do_auto_unload_filament(self, error_dict=None):
        # This is shamelessly copied from loadfilamentprocess and i #hate it
        self.ignorable_toolhead_errors.add(kaiten.error.no_filament)
        yield from self._pymach.motor_abort(True)
        self._log.info("Cancelling filament load for auto unload")
        yield from self._current_activity.cancel()
        yield from self._current_activity.cleanup_generator
        self._set_contract_duration(100)
        self._current_activity = None
        self._step_change(self._print_steps.unloading_filament, error_dict)
        yield from self._create_and_run_activity(
            kaiten.activities.UnloadFilamentActivity,
            tool_index=0,
            from_suspend=False,
            as_autounload=True)
        yield from self._do_filament_cleanup()
        self._step_change(self._print_steps.suspended)
        self._log.info("Done autounloading filament, going back to suspend")
        yield from self._suspended_generator()

    def _do_filament(self, unload=False, error_dict=None):
        if self.step != self._print_steps.suspended:
            yield from self._suspend(error_dict, loop=False)
        with self._machine_manager.light_context("print"):
            if unload:
                self._step_change(self._print_steps.preheating_unloading)
            else:
                self._step_change(self._print_steps.preheating_loading)
            self.overrides_heater_watchdog = True
            self._cancellable = False
            # TODO: handle multiple extruders more elegantly
            temperature = self._extruder_temperatures[0]
            yield from self._pymach.load_temperature_settings([temperature])
            yield from self._pymach.heat()
            waits = [True]
            for i in range(self._config['toolhead_count']-1):
                waits.append(False)
            yield from self._pymach.wait_for_heaters_at_least_target(5,
                                                                     waits)
            #We set this bool if the filament will be in an unknown state,
            #so that when we resume we don't extrude the suspend_restart_distance
            if unload:
                self._step_change(self._print_steps.unloading_filament)
                if not self._load_filament_during_suspend and\
                   ((not error_dict) or\
                   (error_dict["code"] != kaiten.error.out_of_filament)):
                    # If we're unloading just from the suspend screen, and
                    # haven't touched the filament yet, prime the nozzle before
                    # unloading so we don't mess up the end of the filament and
                    # clog.
                    yield from self._ensure_move_axis(3,
                                                      self._suspend_restart_distance,
                                                      self._config['filament']['load_speed'],
                                                      relative=True)
                self._load_filament_during_suspend = True                               
                yield from self._create_and_run_activity(
                    kaiten.activities.UnloadFilamentActivity,
                    from_suspend=True)
            else:
                self._step_change(self._print_steps.loading_filament)
                self._set_contract_duration(1)
                self._load_filament_during_suspend = True
                yield from self._create_and_run_activity(
                    kaiten.activities.LoadFilamentActivity)
                self._set_contract_duration(100)

            self._step_change(self._print_steps.suspended)
            yield from self._do_filament_cleanup()
        yield from self._suspended_generator()

    def get_tool_usage_stats(self):
        """ Return the cached tool usage stats from the preceding print.

        This method should only be called once a print has completed, and should
        probably only be called by the user statistics manager. It will return
        statistics it has cached from the current tool after a print.
        """
        return self._tool_usage_cache

    @kaiten.decorator.process_method(["clear_build_plate"])
    def build_plate_cleared(self):
        """
        Want to set clear_build_plate from any client
        """
        self._log.info("Setting clear build plate state ")
        # Set the bool to True- tells bot not to wait on LCD user input
        self._build_plate_cleared = True

    @kaiten.decorator.process_method(["error_step"])
    def acknowledge_error(self):
        self._error_step_acknowledged = 'ignore'

    @kaiten.decorator.process_method(["failed"])
    def acknowledge_failure(self):
        self._failed_step_acknowledged = True

    @kaiten.decorator.process_method(["completed"])
    def acknowledge_completed(self):
        self._completed_step_acknowledged = True

    def _do_filament_cleanup(self):
        self.overrides_heater_watchdog = False
        self._cancellable = True
        yield

    def _do_stop_filament(self):
        if self._current_activity:
            self._log.info("Cancelling filament activity")
            yield from self._current_activity.cancel()
            yield from self._current_activity.cleanup_generator
            self._current_activity = None
        yield from self._do_filament_cleanup()
        yield from self._pymach.motor_abort(False)
        self._step_change(self._print_steps.suspended)
        yield from self._suspended_generator()
