import os
import sys
import json
import math

"""
Tools for generating hex files and C defines for yonkers EEPROM maps.

Use this module to generate valid Intel Hex (http://en.wikipedia.org/wiki/Intel_hex) files describing the contents of a Yonkers EEPROM, or the C defines required to talk to it from the Bronx firmware.

When a function in this module asks for "data", it is asking for the output of the load_file function, which itself should only be called on a json file describing the contents of the EEPROM.
"""


def yonkers_generate_checksum(filedata):
    """
    This is for internal use, mostly, but is used to generate a checksum of the interesting contents of the Yonkers EEPROM - aka everything but the version, id, uid, and the checksum itself.
    @param dict filedata: A dict, aka the return value of load_file.
    @returns str checksum: the Intel Hex-style checksum of the data (one byte, in hex, as text.)
    """
    checksum=0
    for dictrecord in filedata:
        if dictrecord['name'] != 'checksum' and \
           dictrecord['name'] != 'id' and \
           dictrecord['name'] != 'version' and \
           dictrecord['name'] != 'uid':
            record=int(dictrecord['hex'],16)
            for x in range(dictrecord['size']):
                checksum += (int(record)>>(x*8))&0xff
    return hex(int(checksum%256))

def yonkers_load_file(filename, tool_id=None, skip_id_check=False):
    """
    Load a JSON file describing the content of a Yonkers EEPROM. This should, at the minimum, contain an object called 'map', consisting of strings called 'version' and 'id'.
    @param str filename: File to open and read from.
    @returns dict data: The dictionary read from the JSON in the file.
    """
    mapdata = []
    with open(filename, 'r') as inputfile:
        filedata = json.load(inputfile)
        if skip_id_check or tool_id in filedata["supported_tools"]:
            mapdata = filedata["map"]
        else:
            raise(UnsupportedVersionException)
    return mapdata

def yonkers_checksum_hex_line(line):
    """
    This is for internal use, mostly, but is used to checksum a line of Intel Hex for writing the checksum at the end of the line.
    @param str line: The line of Intel Hex, not including the opening colon or the trailing checksum, but yes including the size, address, and record type.
    @returns str checksum: The checksum of the line, in the Intel Hex style of two hex digits.
    """
    check = 0
    for i in range(0,len(line),2):
        check += int(line[i:i+2],16)
    return hex(256 - (check&0xff))[2:].zfill(2)

def yonkers_generate_intel_hex(inputdata, uid, mapping):
    """
    Generate a valid Intel Hex file for reading by the Brooklyn, describing the content in a Yonkers EEPROM. Please provide your own UID, which you can generate however you like, but which should fit into a 32 bit unsigned integer.
    @param dict inputdata: The dict created by loading a Yonkers EEPROM description JSON file, e.g. by load_file in this module.
    @param uint uid: A unique ID. Please make this fit in an unsigned 32-bit int.
    @param dict mapping: dict used to substitutue for template strings within the inputdata
    """
    if uid<0 or uid > pow(2,33)-1:
        raise(InvalidDataException)
    #uidrecord = '04000000'+hex(uid)[2:].zfill(8)
    #ihex = ':'+uidrecord+checksum_hex_line(uidrecord)
    ihex = ''
    address = 0
    from string import Template
    # Do template match/replace before generating the checksum
    for dictrecord in inputdata:
        for key in dictrecord:
            #If the key data is a placeholder
            if str(dictrecord[key]).startswith('$'):
                dictrecord[key] = Template(dictrecord[key].upper())\
                    .substitute(mapping)

    for dictrecord in inputdata:
        if dictrecord['name'] == 'checksum':
            dictrecord['hex'] = yonkers_generate_checksum(inputdata)
        size = dictrecord['size']
        record = hex(size)[2:].zfill(2)
        record +=hex(address)[2:].zfill(4)
        record += '00'
        record += dictrecord['hex'][2:].zfill(size*2)
        check = yonkers_checksum_hex_line(record)
        ihex += (':'+record+check+'\n')
        address += size
    ihex += ':00000001ff'
    return ihex

def yonkers_generate_c_defines(inputdata):
    """
    Create a solid set of #defines in C, for putting in Bronx firmware.
    @param dict inputdata: The data loaded from a Yonkers EEPROM description JSON file, aka with load_data in this module.
    """
    defines = ''
    index = 0
    for record in inputdata:
        defines+=("\n#define EEPROM_MAP_"+record["name"].upper()+"_IDX "+str(index))
        defines+=("\n#define EEPROM_MAP_"+record["name"].upper()+"_SIZE "+hex(record['size']))
        index+=record["size"]
    return defines

def yonkers_generate_usage_defines(inputdata):
    """
    Create a set of #defines in C for dealing with the usage data that lives in
    the EEPROM after the rest of the data. This is handled separately for
    backwards compatibility.
    """
    defines = ''
    defines += "\n#define EEPROM_USAGE_OFFSET " + str(inputdata['offset'])
    for record in inputdata["map"]:
        if record["name"] == "extras_size":
            defines += "\n#define EEPROM_USAGE_SIZE " + record["hex"]
    return defines

def generate_eeprom_map_structs(extruder_path, bwsconstools_path):
    pystache_lib_path = os.path.join(bwsconstools_path,
                                     "lib", "pystache")
    sys.path.insert(0, pystache_lib_path)
    import pystache

    template = open(os.path.join(extruder_path, "eeprom_map.template")).read()
    maps_dir = os.path.abspath(os.path.join(extruder_path, "versions"))
    maps = []
    for mf in filter(lambda fn: "json" in fn, os.listdir(maps_dir)):
        json_map = json.load(open(os.path.join(maps_dir, mf)))

        map_version = 0;
        map_size = 0
        for item in json_map["map"]:
            if item["name"] == "version":
                map_version = int(item["hex"], 16)
            map_size += item['size']

        #Make the EEPROM map struct name nice lookin', Add on the maps major version
        if map_version == 0:
            json_map["map_name"] = "EepromMapBase"
        else:
            json_map["map_name"] = "EepromMapVersion" + str(major_version(map_version))
        json_map["size"] = map_size
        maps.append(json_map)

    context = {}
    #Add all version maps to the context, and sort them by version num
    context["tool_maps"] =\
        sorted(maps, cmp=lambda x,y: cmp(x["map_name"],y["map_name"]))
    usage = json.load(open(os.path.join(extruder_path, "usage.json")))
    context['usage'] = usage['map']
    context['offset'] = usage['offset']
    context['size_map_size'] = len(maps)+3
    sizes = [35, 35, 35] + [x['size']
                        for x in context['tool_maps']
                        if x['map_name'] != 'EepromMapBase']
    size_str = "const unsigned int version::version_size_map[{0}] = {{"\
        .format(len(maps)+3)
    max_size = 0
    for elem in sizes:
        size_str += "{0}, ".format(elem)
        if int(elem) > max_size:
            max_size = elem;
    context['max_map_size'] = max_size
    size_str += "0};"
    return (size_str, pystache.render(template, context))

def major_version(version):
    return version>>5

def get_latest_eeprom_map(maps_dir):
    latest_map_name = ''
    latest_version = 0
    for mf in filter(lambda fn: "json" in fn, os.listdir(maps_dir)):
        mf_path = os.path.join(maps_dir, mf)
        json_map = json.load(open(mf_path))

        for item in json_map["map"]:
            if item["name"] == "version":
                current_version = major_version(int(item["hex"], 16))
                if current_version > latest_version:
                    latest_version = current_version
                    latest_map_name = mf_path
    return os.path.abspath(latest_map_name)


class InvalidDataException(Exception):
    pass
class UnsupportedVersionException(Exception):
    pass
