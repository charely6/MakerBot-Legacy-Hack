"""
Algorithms for analyzing timeseries responses from the
hall effect sensor used for z-homing.
"""

import math

base64_urlsafe_alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"

class HesWaveformException(Exception):
    def __init__(self):
        pass

def find_contact_point(waveform,
                       max_seated_value=7000,
                       min_range=7000,
                       window=15,
                       threshold=0.05,
                       plot_function=None):
    """
    @param waveform - Timeseries sample of HES values while moving
                      build plate up at a constant rate
    @param max_seated_value - Maximum absolute value of first sample
    @param min_range - Minimum difference between maximum and minimum values
    @param plot_function - Optional plotting function to visualize processing

    Finds the contact point by:
    1. Taking the derivative
    2. Applying a smoothing filter (moving average)
    3. Thresholding relative to max (normalizes for slope)

    Example usage with plotting function:

    import matplotlib.pyplot as plt
    waveform = [1, 2, 3...] # HES waveform
    find_contact_point_samples(waveform, plot_function=plt.plot)
    plt.show()
    """
    # define some shorthand
    V = waveform
    # check seating and travel range
    if abs(V[0]) > max_seated_value:
        raise HesWaveformException
    if max(V) - min(V) < min_range:
        raise HesWaveformException
    # take derivative
    dV = []
    for i in range(len(V)-1):
        dV.append(V[i+1] - V[i])
    # moving average
    dV_smooth = [0] * window # zero pad beginning
    for i in range(len(dV)-window):
        dV_smooth.append(sum(dV[i:i+window]))
    # determine threshold and direction
    if sum(dV) > 0:
        # sloped up (HES installed backwards?)
        direction = 1
        T = threshold * max(dV_smooth)
    else:
        # sloped down like normal
        direction = -1
        T = threshold * abs(min(dV_smooth))
    # threshold and find contact point
    contact_point = -1
    for i in range(len(dV_smooth)):
        if dV_smooth[i] * direction > T:
            contact_point = i
            break
    # plot
    if plot_function:
        plot_function(V)
        plot_function(dV)
        plot_function(dV_smooth)
        plot_function([0, len(V)], [T, T])
        plot_function([contact_point, contact_point], [min(V), max(V)])
    # return contact point
    if contact_point < 0:
        # this should never happen
        raise HesWaveformException
    else:
        return contact_point

def find_contact_point_mm(waveform, speed, sample_rate, **kwargs):
    """
    Find contact point relative to the start of the waveform.

    @param waveform - a list representing a timeseries waveform of HES values
    @param speed - movement speed while waveform was captured in mm/s
    @param sample_rate - sample rate that waveform was captured at in samples per second
    """
    sample_point = find_contact_point(waveform, **kwargs)
    sample_point_mm = sample_point * speed / sample_rate
    return sample_point_mm

def encode_waveform(waveform):
    """
    This returns a url-safe representation of the waveform.
    Waveform is an array of integers.
    For HES values, the most interesting 12 bits are generally
    the 12 most significant bits of the 2 least significant bytes.
    Since this is used for google analytics, we have a 500 character limit.
    So we get 2 6-bit base64 characters per sample, and limit things to 250 samples.
    """
    waveform_ascii = []
    max_length = 250
    lsb = 4
    def base64_encode(sample):
        return base64_urlsafe_alphabet[(sample & 0x3f)]
    for sample in waveform[:max_length]:
        waveform_ascii += base64_encode(sample >> lsb+6)
        waveform_ascii += base64_encode(sample >> lsb)
    return "".join(waveform_ascii)

def decode_waveform(waveform_ascii):
    """
    Decodes waveform encoded using the above function.
    """
    waveform = []
    lsb = 4
    def base64_decode(value):
        return base64_urlsafe_alphabet.index(value)
    for i in range(0, len(waveform_ascii), 2):
        sample = 0
        sample += base64_decode(waveform_ascii[i]) << lsb+6
        sample += base64_decode(waveform_ascii[i+1]) << lsb
        # TODO: may want to shift over 1 additional bit during encoding
        # We currently overflow for most waveforms 
        if sample > 2**15:
            sample -= 2**16
        waveform.append(int(sample))
    return waveform



