import logging
import os
import sys
import math
import zipfile
import time
import errno
import datetime

import kaiten.error

from kaiten.processes.process import Process

class ZipLogsProcess(Process):
    def __init__(self, machine_manager, pymach, zip_path):
        super(ZipLogsProcess, self).__init__(machine_manager, pymach,
                                             machine_manager._config)
        self.logs_path = os.path.join("/", "home", "logs")
        self.zip_path = zip_path
        self._logs_zip = None

        self._progress = 0
        self.ignore_all_toolhead_errors()
        self._cancellable = False

    def _do_initialize(self):
        self._logs_zip = zipfile.ZipFile(self.zip_path, "w")
        yield kaiten.error.ok

    def _recursive_add_to_zip(self, path):
        """ Add all contents of the given directory to self._logs_zip """
        # Zip files can't handle dates before 1980, ie ALL of our dates
        GOOD_DATE = 1406833482
        for root, subdirs, files in os.walk(path):
            for filename in files:
                filepath = os.path.join(root, filename)
                # We modify the timestamps in place because attempting
                # to not do so was messing up file permissions...
                os.utime(filepath, (GOOD_DATE, GOOD_DATE))
                self._logs_zip.write(filepath, filename)
                yield

    def _do_run(self):
        try:
            yield from self._recursive_add_to_zip(self.logs_path)
        except OSError as e:
            if e.errno == errno.ENOSPC:
                self._cancellable = True
                yield kaiten.error.insufficient_usb_space
            else:
                raise e

    def _do_cleanup(self):
        try:
            if self._logs_zip is not None:
                self._logs_zip.close()
        except OSError as e:
            if e.errno == errno.ENOSPC:
                # We've already thrown an error in _do_run()
                pass
            else:
                raise e
        yield kaiten.error.ok

    def expected_run_time(self):
        # this process tends to block in several chunks of 8 to 15 seconds each
        return datetime.timedelta(seconds=20)

    def get_info_dict(self):
        info = super(ZipLogsProcess, self).get_info_dict()
        info.update({
            'progress': self._progress
        })
        return info
