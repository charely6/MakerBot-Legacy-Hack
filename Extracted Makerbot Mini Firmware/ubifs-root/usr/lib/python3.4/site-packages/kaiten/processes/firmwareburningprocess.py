import logging
import datetime
import json
import os
import sys
import zipfile
import contextlib

import tempfile

import kaiten.constants
import kaiten.enum
import kaiten.error
import kaiten.log
import kaiten.util

from kaiten.processes.process import Process

class FirmwareBurningProcess(Process):

    _firmware_steps = kaiten.enum.enum("firmware_steps",
                                       "downloading",
                                       "transfer",
                                       "verify_firmware",
                                       "writing",)

    def __init__(self, machine_manager, pymach, config,
                 firmware_path=None, transfer_wait=False,
                 firmware_updates=None):
        """
        This process is a total mess.  It supports both brooklyn_upload,
        where the client gives us an arbitrary firmware file to install,
        and the newer process where kaiten finds and downloads the newest
        available firmware and asks clients if they want to download it.
        For the latter case, the running instance of FirmwareUpdates must
        be passed in as firmware_updates, and the other arguments will be
        ignored.

        @param firmware_path full de-chrooted path to the firmware zip/folder
        @param transfer_wait if true, do not start burning until a file
            transfer to the specified path occurs and is marked as done. Flag
            ignored when download_firmware is set.
        """
        super(FirmwareBurningProcess, self).__init__(machine_manager,
            pymach, config)
        self._log = kaiten.log.getlogger(self)
        self._progress = 0
        self._firmware_updates = firmware_updates
        if firmware_updates:
            self._transfer_wait = False
            self._firmware_path = firmware_updates.get_firmware_path()
        else:
            self._transfer_wait = transfer_wait
            self._firmware_path = firmware_path
        self._manifest = {}
        self._zip = None
        # This gets ignored by machine_manager's toolhead error handling...
        self.ignore_all_toolhead_errors()

        # Waiting for a transfer is implemented by transfer callbacks
        self._machine_manager._server.add_transfer_callback(
            self._firmware_path, self.transfer_progress)

    # Order to execute the elements of manifest.json
    MANIFEST = [
        'pre_flash_script',
        'rootfs',
        'uImage',
        'post_flash_script',
    ]

    class BadSignatureException(Exception):
        def __init__(self, hash, msg):
            self.hash = hash
            self.msg = msg

    def contract_duration(self):
        if self._transfer_wait and not self.cancelled:
            # We aren't doing any work for the transfer, just doing an
            # inactivity timeout, which we set at 30 seconds
            return datetime.timedelta(0, 30, 0)
        else:
            return datetime.timedelta(0, 0, 0)

    def reschedule(self):
        # TODO: properly expose this function
        server = self._machine_manager._server
        server.reschedule_contract_generator(self)

    def transfer_progress(self, progress, done):
        if not self._transfer_wait:
            raise StopIteration
        if self.step != self._firmware_steps.transfer:
            self._step_change(self._firmware_steps.transfer)
        if progress != self._progress:
            self._progress = progress
            # This process isn't actually iterating during tranfer, so
            # machine_manager is not iterating in sync with this progress
            # function.  So we need to directly update our progress.
            self._machine_manager._update_process_info()
        if done:
            self._transfer_wait = False
        # If not done, we need to reset the timeout to 30 seconds
        # If done, we don't want to wait the 30 seconds until our contract is up
        # Either way, same action
        self.reschedule()

    def _open_firmware_file(self, manifest_file):
        self._log.info("opening {0}".format(manifest_file))
        if self._zip:
            return self._zip.open(manifest_file)
        else:
            file_path = os.path.join(self._firmware_path, manifest_file)
            return open(file_path, 'rb')

    def _get_firmware_file_size(self, manifest_file):
        if self._zip:
            return self._zip.getinfo(manifest_file).file_size
        else:
            file_path = os.path.join(self._firmware_path, manifest_file)
            return os.path.getsize(file_path)

    @contextlib.contextmanager
    def _get_firmware_file_path(self, manifest_file):
        """
        Return a path to an element of the manifest.  If the file does not exist
        on the filesystem already, a copy will be created in /tmp, and deleted
        afterwards, which is why this is implemented as a context manager.  This
        must not be called on manifest elements which are too large for /tmp.
        """
        if self._zip:
            import stat
            out = tempfile.NamedTemporaryFile(delete=False)
            tmp_path = out.name
            try:
                with contextlib.closing(out), \
                     self._open_firmware_file(manifest_file) as f:
                    for data in kaiten.util.read_bytes(f, 8192):
                        out.write(data)
                os.chmod(tmp_path, stat.S_IRWXU)
                yield tmp_path
            finally:
                os.unlink(tmp_path)
        else:
            return os.path.join(self._firmware_path, manifest_file)

    def _firmware_file_init(self):
        if os.path.isdir(self._firmware_path):
            self._firmware_list = os.listdir(self._firmware_path)
        else:
            self._zip = zipfile.ZipFile(self._firmware_path, 'r')
            self._firmware_list = self._zip.namelist()
        with self._open_firmware_file("manifest.json") as f:
            self._manifest = json.loads(f.read().decode("UTF-8"))
        self._firmware_version = self._manifest["version"]

    def _do_initialize(self):
        with self._machine_manager.light_context("busy"):
            if self._firmware_updates:
                firmware_download = self._firmware_updates.firmware_download
                if firmware_download is not None:
                    # Don't continue until we are done downloading
                    while not firmware_download.complete:
                        self._step_change(self._firmware_steps.downloading)
                        self._progress = firmware_download.progress()
                        yield
                    if firmware_download.error:
                        yield kaiten.error.firmware_download_error
                elif not os.path.exists(self._firmware_path):
                    # I think we might never be able to get into this
                    # state, but if we can it is almost certainly because
                    # the file transfer just failed.
                    yield kaiten.error.firmware_download_error
            elif self._transfer_wait:
                # If we are still waiting for the transfer when this iterates,
                # our transfer has timed out.  Reschedule us to iterate immediately
                # so we can clean up properly
                self._transfer_wait = False
                self.reschedule()
                yield kaiten.error.file_transfer_timeout
            self._progress = 0
            self._step_change(self._firmware_steps.verify_firmware)
            try:
                self._firmware_file_init()
                yield from self._verify_firmware()
            except Exception:
                self._log.info("{0} is corrupted, aborting".format(self._firmware_path),
                               exc_info=True)
                try:
                    self._log.info("Deleting corrupted firmware {0}".format(self._firmware_path))
                    os.unlink(self._firmware_path)
                except Exception as e:
                    self._log.error("Error deleting corrupted firmware: {0}".format(e))
                yield kaiten.error.corrupted_firmware_file
                raise # Just in case
            # Cancelling not allowed once verification is done
            self._cancellable = False
            yield

    def _run_script(self, script):
        if script not in self._firmware_list: return
        with self._get_firmware_file_path(script) as file_path:
            import subprocess
            if subprocess.call([file_path]):
                self._log.info("Error running upgrade script %s", file_path)

    def _burn_firmware_morepork(self):
        # Pre and post scripts are deprecated -- we ignore them here.
        self._log.info("Burning firmware")
        ext_size = self._get_firmware_file_size('rootfs')

        root_parts = {
            '0': '/dev/mmcblk0p1',
            '1': '/dev/mmcblk0p2',
        }
        root_nums = {v: k for k, v in root_parts.items()}

        # Figure out which partition we are booting from.  We prefer to
        # look at what we actually booted from but we also check the file
        # that u-boot should be reading to determine what to boot.
        with open('/proc/cmdline') as f:
            vals = dict(x.split('=', 1) for x in f.read().split() if '=' in x)
            curr_root_part = vals.get('root')
        with open('var/bootpartnr') as f:
            curr_root_num = f.read().strip()
        if curr_root_part not in root_nums:
            self._log.warning('Unknown root partition %r', curr_root_part)
            curr_root_part = root_parts[curr_root_num]
        elif root_nums[curr_root_part] != curr_root_num:
            self._log.warning('Mounted partition %s does not match %r',
                              curr_root_part, curr_root_num)
            curr_root_num = root_nums[curr_root_part]

        # Write to whatever we aren't currently using
        next_root_num = next(x for x in root_parts if x != curr_root_num)
        next_root_part = root_parts[next_root_num]

        # Actually write the image to the partition
        done = 0
        block_size = 32768
        with self._open_firmware_file('rootfs') as f:
            with open(next_root_part, 'wb') as dev:
                for data in kaiten.util.read_bytes(f, block_size):
                    dev.write(data)
                    done += len(data)
                    self._progress = (done * 100) / ext_size
                    yield

        # Set up booting from the new partition
        with kaiten.util.open_write('var/bootpartnr') as f:
            f.write(next_root_num + '\n')

    def _burn_firmware_birdwing(self):
        if '/usr/scripts' not in sys.path:
            sys.path.append('/usr/scripts')
        from UBootEnv import UBootEnv
        from UBI import UBIWriter

        self._log.info("Burning firmware")
        self._run_script('pre_flash_script')
        yield

        kernel_size = self._get_firmware_file_size('uImage')
        ubi_size = self._get_firmware_file_size('rootfs')
        if (kernel_size > 0x700000):
            raise Exception('Kernel image is too large')
        kernel_progress_scale = 8
        # Include in kernel size the size of the u-boot environment
        progress_size = kernel_progress_scale * (kernel_size + 2**17) + ubi_size

        env = UBootEnv()
        env.read_env()
        new_addr = env['backup_kernel_addr']
        new_vol = env['backup_root_volume']

        # Update the NAND image
        done = 0
        with UBIWriter.open(new_vol, ubi_size) as ubi, \
             self._open_firmware_file('rootfs') as f:
            for data in kaiten.util.read_bytes(f, 32768):
                ubi.write(data)
                done += len(data)
                self._progress = (done * 100) / progress_size
                yield

        # Unconditionally protect the top half of the nor before we start writing.
        # The bottom half is already sufficiently protected in all cases.
        # Ignored by the progress counter
        import subprocess
        kernel_protect_cmd = [
            'nor_write', '-vP',
            '-a', '0x800000',
            '-l', '0x800000',
        ]
        protect_output = subprocess.check_output(kernel_protect_cmd)
        self._log.info('Output from kernel protect:\n' +
                       protect_output.decode('utf-8'))

        # We are almost done so shutdown our mdns service now to give plenty of
        # time to send a goodbye packet.
        if self._machine_manager._server.dbus_manager:
            self._machine_manager._server.dbus_manager.kill_discovery()

        # Update the kernel
        kernel_burn_cmd = [
            'nor_write', '-ve',
            '-a', new_addr,
            '-s', '10000000'
        ]
        write_proc = subprocess.Popen(kernel_burn_cmd, stdin=subprocess.PIPE,
                                      stdout=subprocess.PIPE)
        output = []
        def _readerthread(fh, buf):
            buf.append(fh.read())
            fh.close()
        import threading
        readerthread = threading.Thread(target=_readerthread, args=(write_proc.stdout, output))
        readerthread.start()
        try:
            with self._open_firmware_file('uImage') as f:
                for data in kaiten.util.read_bytes(f, 8192):
                    write_proc.stdin.write(data)
                    done += len(data) * kernel_progress_scale
                    self._progress = (done * 100) / progress_size
                    yield
        finally:
            write_proc.stdin.close()
            readerthread.join(10)
        if output:
            self._log.info('Output from kernel burn:\n'+output[0].decode('utf-8'))
        return_code = write_proc.wait() # This will wait for the process to terminate
        if return_code != 0:
            raise subprocess.CalledProcessError(returncode=return_code,
                                                cmd=kernel_burn_cmd)

        # Update environment variables to boot from the new firmware
        env['backup_kernel_addr'] = env['current_kernel_addr']
        env['backup_root_volume'] = env['current_root_volume']
        env['current_kernel_addr'] = new_addr
        env['current_root_volume'] = new_vol
        env.set_boot_nand()
        env.write_env()

        self._run_script('post_flash_script')
        self._progress = 100
        yield

    def _verify_firmware(self):
        import hashlib
        m = hashlib.sha256()

        # First get the total size so we can do progress
        size = 1
        for _file in self.MANIFEST:
            if _file not in self._firmware_list: continue
            size += self._get_firmware_file_size(_file)
        yield

        # Now we hash the files and report progress
        done = 0
        for _file in self.MANIFEST:
            if _file not in self._firmware_list: continue
            with self._open_firmware_file(_file) as f:
                for data in kaiten.util.read_bytes(f, 65536):
                    m.update(data)
                    done += len(data)
                    self._progress = (done * 100) / size
                    yield

        hash = m.hexdigest()

        try:
            self._verify_signature(hash)
        except self.BadSignatureException as e:
            self._log.info("Firmware failed signature check\n%s\n%s"%
                           (e.hash, e.msg))
            with self._open_firmware_file('hash') as f:
                real_hash = f.read().decode("UTF-8").strip()
            if hash != real_hash:
                raise Exception('Firmware is actually corrupted')
            self._machine_manager._server.play_buzzer("notify")
            with self._machine_manager.light_context("error"):
                res = yield from self._client_request(
                    'lcd', 'allow_unknown_firmware', {})
            if res != 'allow':
                raise Exception('User hates the firmware')
        else:
            self._log.info("Firmware passed signature check")
        self._progress = 100

    def _verify_signature(self, hash):
        # Actually check the signature (fast enough not to matter for progress)
        sig = [
            b"-----BEGIN PGP SIGNED MESSAGE-----",
            b"Hash: SHA256",
            b"",
            hash.encode("utf-8"),
        ]
        try:
            with self._open_firmware_file('signature') as f:
                sig.append(f.read())
        except Exception:
            raise self.BadSignatureException(hash, 'No signature')
        sigcmd = ['gpgv', '--ignore-time-conflict']
        altpath = '/var/gnupg/trustedkeys.gpg' # Do not put this in config.py
        if os.path.exists(altpath):
            sigcmd.extend(['--keyring', altpath])
        import subprocess
        p = subprocess.Popen(sigcmd,
                stdin=subprocess.PIPE, stderr=subprocess.PIPE)
        result = p.communicate(b'\n'.join(sig))[1].decode('utf-8').strip().split('\n')
        if p.returncode or not result[-1].startswith('gpgv: Good signature'):
            raise self.BadSignatureException(hash, '\n'.join(result))

    def _shutdown(self):
        import subprocess
        subprocess.check_output([
                                "reboot",
                                "-d", "0", # No delay time
                                ])
        self._log.info("Shutting down")
        # This loop happens so we don't continue iterating after the shutdown
        while not self._stop:
            pass

    def _do_run(self):
        with self._machine_manager.light_context("busy"):
            self._log.info("Beginning non-blocking firmware write")
            self._progress = 0
            self._step_change(self._firmware_steps.writing)
            # TODO: less bad way to differentiate birdwing and morepork
            if 'uImage' in self._firmware_list:
                with self._machine_manager.disable_toolhead_spi():
                    yield from self._burn_firmware_birdwing()
            else:
                yield from self._burn_firmware_morepork()
            if os.path.isfile(kaiten.constants.do_fre):
                os.remove(kaiten.constants.do_fre)
            boot_file = kaiten.constants.first_firmware_boot
            with kaiten.util.open_write(boot_file) as f:
                f.write('%s\n'% kaiten.util.get_fw_version().safe_str())
            self._shutdown()

    def _do_cleanup(self):
        if self._progress == 100:
            try:
                os.unlink(self._firmware_path)
            except Exception as e:
                self._log.info("Unable to clean up firmware file {0}".format(self._firmware_path))
        self._machine_manager._server.clear_transfer_callbacks(
            self._firmware_path)
        yield

    def expected_run_time(self):
        return datetime.timedelta(seconds=30)

    def get_info_dict(self):
        info = super(FirmwareBurningProcess, self).get_info_dict()
        info["progress"] = int(self._progress)
        if hasattr(self, "_firmware_version"):
            info["firmware_version"] = self._firmware_version
        return info
