import os
import sys
import time
import kaiten.enum
import kaiten.util
import kaiten.log
import kaiten.constants
import kaiten.processes

class LightManager(object):

    def __init__(self, pymachine=None, config=None):
        self._log = kaiten.log.getlogger(self)
        self._pymach = pymachine
        self._light_config = config["lights"]
        self._interface_address = config["interface_address"]
        self._single_button_interface = config["single_button_interface"]
        try:
            self._knob_on = self._light_config["knob_on"]
            self._chamber_on = self._light_config["chamber_on"]
        except:
            self._log.debug(("No persistent light state keys were found in the"
                            " config, using defaults"))
            self._knob_on = True; #Determines if the light state sets the knob
            self._chamber_on = True; #Same as above but for the chamber light
        self._heaters_hot = False
        self._needs_update = False
        self._update_generator = None
        self.light_states = kaiten.enum.enum("light_states",
                                             "idle",
                                             "print",
                                             "busy",
                                             "priority_busy",
                                             "acknowledge",
                                             "chamber_ack",
                                             "ready",
                                             "error")
        #_light_state_stacks is a dict of priority keys (0,1,2,...) whose value
        #is a list which holds the state stack for the given priority.
        #The lower the number the higher the priority of the light state
        self._light_state_stacks = {}
        for state in self.light_states:
            self._light_state_stacks[self._priority(state)] = []
        self._lowest_priority = self._priority(self.light_states.idle)
        self._setup_lights()

    def needs_update(self):
        return self._needs_update

    def _priority(self, state):
        """
        Returns the priority of the given state, here for abstraction
        and to save on code length
        """
        return self._light_config[state]["priority"]

    def _write_persistent_light_settings(self):
        """
        Write the persistent light settings to the printer_settings file in the
        home directory. This is done so (dis/en)abling LEDs will be persistent
        over sessions
        """
        new_settings = {"lights": {
                            "knob_on" : self._knob_on,
                            "chamber_on" : self._chamber_on}}
        config_path = kaiten.constants.config_home_path
        #If the config file doesn't exist we should create it with the given
        #settings
        if not os.path.isfile(config_path):
            kaiten.util.write_json_file(config_path, new_settings)
        else:
            #Try to load in the json file and update it with the new settings
            try:
                home_settings = kaiten.util.read_json_file(config_path)
                kaiten.util.recursive_update(home_settings, new_settings)
                kaiten.util.write_json_file(config_path, home_settings)
            #If that fails just write the settings out to the file
            except:
                kaiten.util.write_json_file(config_path, new_settings)

    def disable_lights(self, disable_knob, disable_chamber):
        """
        Disable lights for any light state changes going forward

        @param disable_knob: If True, disable the knob's LED
        @param disable_chamber: If True, disable the chamber's LED
        """
        if disable_knob:
            self._knob_on = False
            if self._pymach:
                self._pymach.set_knob_color(0.0, 0.0, 0.0, 0.0)
        if disable_chamber:
            self._chamber_on = False
            if self._light_config["chamber_type"] == "unicolor":
                if self._pymach:
                    self._pymach.set_moose_chamber_brightness(0.0)
            else:
                if self._pymach:
                    self._pymach.set_chamber_color(0.0, 0.0, 0.0, 0.0)
        #Write the new chamber/knob on states to the home config file
        self._write_persistent_light_settings()

    def enable_lights(self, enable_knob, enable_chamber):
        """
        Enable light for light state changes going forward

        @param enable_knob: If True, the knob's LED is enabled
        @param enable_chamber: If True, the chamber's LED is enabled
        """
        if enable_knob:
            self._knob_on = True
        if enable_chamber:
            self._chamber_on = True
        #Write the new chamber/knob on states to the home config file
        self._write_persistent_light_settings()
        self._update_lights()

    def update_lights(self):
        """
        Generator that is used to update the lights
        """
        #handle the check for hot tools here
        self._handle_hot_tool()
        if self._needs_update:
            #If a state change has occurred that affects the light state, update
            self._update_lights()

    def _update_lights(self):
        """
        Internal function for updating lights. This is used externally via
        self.update_lights(). It will set higher priority light states first.
        """
        self._log.debug("STACK: " + str(self._light_state_stacks))
        set_state = self.light_states.idle
        state_priority = self._lowest_priority
        #Attempt to set the light state starting with the hightest priority
        for priority in sorted(self._light_state_stacks):
            try:
                #See if there is a state in this priority, disregarding 'hold'
                #states
                set_state =\
                    [s for s in self._light_state_stacks[priority] if s != "hold"][-1]
                state_priority = priority
                break
            except:
                pass

        #Logic to determine if the chamber color should be set
        #If the chamber is enabled and either the heaters are not hot or the
        #states priority is higher than the default (lowest) priority we will
        #set the chamber light
        #We want to set the chamber for a high priority state since they may
        #have an important chamber light function (chamber_ack).
        set_chamber = (self._chamber_on and ((not self._heaters_hot) or
            (state_priority > self._lowest_priority)))

        self._set_lights(set_state, self._knob_on, set_chamber)
        self._needs_update = False

    def _handle_hot_tool(self):
        """
        Handle setting the chamber light to red when heaters are hot
        also sets some boolean values to disable ovewriting the chamber color
        whilst it remains hot
        """
        if not self._pymach:
            return
        if (not self._heaters_hot) and self._pymach.any_heater_above_temp(50):
            self._heaters_hot = True
            self._set_lights(self.light_states.print, set_knob=False)
        if self._heaters_hot and (not self._pymach.any_heater_above_temp(50)):
            self._heaters_hot = False
            self._needs_update = True

    def push_hold_state_to_stack(self, priority_state:str):
        """
        Push a hold state (ie keep the same state) state to the light_state_stacks. Priority is determinted
        by the given priority_state.
        """
        self._light_state_stacks[self._priority(priority_state)].append("hold")

    def push_state_to_stack(self, new_light_state):
        """
        Push a given state to the the proper priority light stack
        """
        #If the new state is idle consider it the start of a new stack
        if new_light_state == self.light_states.idle:
            self._light_state_stacks[self._priority(self.light_states.idle)] =\
                [self.light_states.idle]
        else:
            #Append the new light state to the correct priority stack
            self._light_state_stacks[self._priority(new_light_state)].append(
                new_light_state)
        self._needs_update = True

    def clear_state_from_stack(self, state):
        self._needs_update = True
        priority = self._priority(state)
        self._light_state_stacks[priority].clear()
        #If the low priority light state stack is empty set the bot to idle
        if (len(self._light_state_stacks[self._lowest_priority]) == 0):
            self._light_state_stacks[self._lowest_priority] =\
                [self.light_states.idle]

    def pop_state_from_stack(self, state):
        """
        Pops a state off the priority stack for the given state
        if the idle state's priority stack is empty we set the stack
        to the idle state
        """
        self._needs_update = True
        priority = self._priority(state)
        #If we are a single button bot and are popping 'error'
        #state we should pop the whole lot of 'em, since having the user press
        #the button multiple times to clear the LED state is pointless
        if self._single_button_interface and (priority == self._priority("error")):
            self.clear_state_from_stack('error')
        else:
            try:
                self._light_state_stacks[priority].pop()
            except IndexError:
                pass

        #If the low priority light state stack is empty set the bot to idle
        if (len(self._light_state_stacks[self._lowest_priority]) == 0):
            self._light_state_stacks[self._lowest_priority] =\
                [self.light_states.idle]

    def _setup_lights(self):
        """
        Setup the lights I2C address and set everything to it's default light
        state. This is iterated over when the LightManager is initialized
        """
        chamber_type = self._light_config["chamber_type"]

        #I2C Address and Color Setting
        if self._pymach:
            self._pymach.set_interface_address(self._interface_address)
        if self._light_config["cycle_colors_on_start"]:
            self._cycle_colors() #Cycle through LED state colors
        self.push_state_to_stack(self.light_states.idle)
        self._update_lights()

    def _set_lights(self, state, set_knob=True, set_chamber=True):
        """
        Generator that sets lights
        """
        #First set the knob color, then the chamber
        light_sources = []
        if set_knob:
            light_sources.append("knob")
        if set_chamber:
            light_sources.append("chamber")

        for light_source in light_sources:
            try:
                r = self._light_config[state][light_source]["r"]
                g = self._light_config[state][light_source]["g"]
                b = self._light_config[state][light_source]["b"]
                period = self._light_config[state][light_source]["period"]
            except KeyError as e:
                self._log.info("Could not find light key {0}".format(state))
            else:
                #TODO: fix me when the rev of queens that fixes this comes out
                if self._light_config["invert_led_colors"]:
                    #With current revs of the queens board the rgb lines are
                    #hooked up backward so we handle that here
                    r, g, b = b, g, r

                if light_source == "knob":
                    if self._pymach:
                        self._pymach.set_knob_blink(period)
                        self._pymach.set_knob_color(r,g,b, 1.0)
                elif light_source == "chamber":
                    if self._light_config["chamber_type"] == "unicolor":
                        brightness = (r + b + g)/3
                        #If close to full brighness, set brightness to 100%
                        # to reduce PWM noise
                        if brightness >= 0.9: brightness = 1.0
                        if self._pymach:
                            self._pymach.set_moose_chamber_brightness(brightness)
                    else:
                        if self._pymach:
                            self._pymach.set_chamber_color(r,g,b, 1.0)
                        #We don't set the chamber period since it can cause
                        #issues with the knob period
                    if (state == 'chamber_ack'):
                        if self._pymach:
                            self._pymach.set_chamber_blink(period)
                        # Set the chamber to blink in special case of chamber authorization

    def _cycle_colors(self):
        """
        Cycle through all LED state colors on one button bots (Tink, WildDuck)
        so users know the difference between white and blue
        """
        if not self._pymach:
            return
        #Set chamber to white otherwise it remains off
        self._pymach.set_chamber_color(1.0, 1.0, 1.0, 1.0)
        self._pymach.set_knob_color(1.0, 0.0, 0.0, 1.0) #red
        #Allow color to show for a time so the user can see it.
        time.sleep(0.5)
        self._pymach.set_knob_color(0.0, 0.0, 1.0, 1.0)#blue
        time.sleep(0.5)
        #white will be next since it is the default light state

