""" A process for calculating the offset between the build plate and a hardpoint.

The routine basically goes -

-Find the Z position of a point on the build plate (we used the "fixed" knob)
-Find the Z position of the hard point
-Store the offset in /home/settings/printer_settings.json
"""

import json
import logging
import math
import datetime
import os

import kaiten.activities
import kaiten.error

from kaiten.processes.process import Process

class ZCalibrationProcess(Process):
    def __init__(self, machine_manager, pymach, config):
        super(ZCalibrationProcess, self).__init__(machine_manager, pymach, config)
        self.ignorable_toolhead_errors.update([\
                                               kaiten.error.no_filament,
                                               kaiten.error.filament_slip,
                                               kaiten.error.door_interlock_triggered
                                           ])
        self._zcal_steps = kaiten.enum.enum("zcal_steps",
                                            "initializing",
                                            "cooling",
                                            "preheating",
                                            "clear_filament",
                                            "preheating_unloading",
                                            "unloading_filament",
                                            "calibrating",
                                            "remove_filament")
        self._calibrate_hot = self.should_calibrate_hot(machine_manager, config)
        self._use_alternate_home = self.should_use_alternate_home(machine_manager, config)
        self._waiting_for_continue = False
        self._step_change(self._zcal_steps.initializing)
        self._gantry_homed = False

    @staticmethod
    def should_calibrate_hot(machine_manager, config):
        calibrate_hot = False
        calibrate_type = config['home']['z_calibration_hot']
        if calibrate_type == 'yes':
            calibrate_hot = True
        elif calibrate_type == 'no':
            calibrate_hot = False
        elif calibrate_type == 'squid-only':
            if machine_manager.configured_tool[0].type == 'mk12':
                self._log.info("squid connected, homing hot to pin")
                calibrate_hot = True
            else:
                self._log.info("orca connected, cool running")
                calibrate_hot = False
        else:
            self._log.error("Invalid z_calibration_hot value: {0}"\
                            .format(calibrate_type))
            calibrate_hot = False
        return calibrate_hot

    @staticmethod
    def should_use_alternate_home(machine_manager, config):
        calibrate_type = config['home']['z_calibration_hot']
        if calibrate_type == 'squid-only':
            if machine_manager.configured_tool[0].type == 'mk12':
                return True
        return False

    def contract_duration(self):
        return datetime.timedelta(0, 0, 0, 15)

    def light_condition(self):
        """
        Determine whether we should change the front light for this process.
        """
        return self._calibrate_hot

    def _do_initialize(self):
        with self._machine_manager.conditional_light_context('print',
                                                             self.light_condition):
            self._machine_manager._server.mixpanel_event("z_calibration_start")
            self._machine_manager._server.play_buzzer("start_print")
            if self._pymach.get_filament_presence(0):
                self._step_change(self._zcal_steps.clear_filament)
                yield from self._wait_for_continue()
                yield from self._do_filament_unload()
                # After unloading request user to remove filament
                self._step_change(self._zcal_steps.remove_filament)
                yield from self._wait_for_continue()
            if self._calibrate_hot:
                yield from self._ensure_tool_attached()
                home_temp = self._config['home']['temperature']
                self._log.info("Z calibration preheating to {0} Celsius".format(home_temp))
                self._step_change(self._zcal_steps.preheating)
                yield from self._heat_to_temperature([home_temp], wait=True,
                                                     wait_check=(True,False))
            else:
                cool_temp = self._config["home"]['cool_temp_c']
                if self._pymach.any_heater_above_temp(cool_temp):
                    self._log.info("Z calibration cooling")
                    self._step_change(self._zcal_steps.cooling)
                    yield from self._pymach.set_temperature_target(0, 0)
                    yield from self._pymach.toggle_fan(0, True)
                    while self._pymach.any_heater_above_temp(cool_temp):
                        yield kaiten.error.ok
                    yield from self._pymach.toggle_fan(0, False)
                yield from self._ensure_tool_attached()
            self._pymach.set_toolhead_idle_update_period(0, .01)

    def _do_run(self):
        with self._machine_manager.conditional_light_context('print',
                                                             self.light_condition):
            self._step_change(self._zcal_steps.calibrating)
            yield from self._create_and_run_activity(
                kaiten.activities.GantryHomeActivity,
                self._environment)
            self._gantry_homed = True
            if self._config["home"]['z_calibration_type'] == "leveling":
                yield from self._create_and_run_activity(
                  kaiten.activities.ZCalibrationActivity)
            else:
                yield from self._create_and_run_activity(
                    kaiten.activities.EndstopZCalibrationActivity,
                    self._use_alternate_home)
            yield from self._pymach.move_axis(2, self._config['park']['z'],
                                              20, relative=True)

    def _do_cleanup(self):
        self._machine_manager._server.mixpanel_event("z_calibration_end")
        if self._gantry_homed:
            yield from self._xypark()
        self._log.info("Shutting down")
        yield from self._pymach.shutdown()
        if self._calibrate_hot:
            yield from self._pymach.cool()

    def _wait_for_continue(self):
       self._waiting_for_continue = True
       while self._waiting_for_continue:
            yield

    @kaiten.decorator.process_method(["clear_filament",
                                      "remove_filament"])
    def continue_process(self):
        self._waiting_for_continue = False

    def _do_filament_unload(self):
        with self._machine_manager.light_context("print"):
            self._step_change(self._zcal_steps.preheating_unloading)
            self.overrides_heater_watchdog = True
            self._cancellable = True
            # TODO: handle multiple extruders more elegantly
            temperature_settings =\
                [self._config["toolheads"]["bronx"]["heater"]["print_temperature_default"]]
            yield from self._pymach.load_temperature_settings([temperature_settings[0]])
            yield from self._pymach.heat()
            yield from self._pymach.wait_for_heaters_at_target(10,
                [True]*self._config['toolhead_count'])
            self._cancellable = False
            self._step_change(self._zcal_steps.unloading_filament)
            yield from self._create_and_run_activity(
                kaiten.activities.UnloadFilamentActivity)
            yield from self._do_filament_cleanup()

    def _do_filament_cleanup(self):
        #If this bot is not set to level the plate whilst hot, we should cool now
        if not self._calibrate_hot:
            yield from self._pymach.cool()
        self._cancellable = True
        yield
