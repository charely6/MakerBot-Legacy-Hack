import datetime
import json
import os
import sys
import logging

import kaiten.constants
import kaiten.error
import kaiten.util

from kaiten.processes.process import Process

class DiagnosticProcess(Process):
    def __init__(self, machinemanager, machinedriver, tests, config):
        super(DiagnosticProcess, self).__init__(machinemanager, machinedriver, config)
        self._config = config
        self._passed_idle_5v = False
        self._passed_idle_12v = False
        self._passed_motors = [False, False, False]
        self._passed_camera = False
        self._tool_passed = False
        self._tool_extended_results = {}
        self.ignore_all_toolhead_errors()
        self._initialize_parameters()
        self._setup_logging()
        self._tests = list(map(lambda s: s.lower(), tests))
        self._locations = []
        self._idle_5v_voltage = 0
        self._idle_12v_voltage = 0
        self._motor_currents = [0, 0, 0]
        self._endstop_ok = False
        for th in self._config['toolheads'].values():
            for loc in th['locations']:
                self._locations.append(loc)
                self._tool_extended_results[loc] = {}

    def _initialize_parameters(self):
        diagnostics_settings = kaiten.util.read_json_file(
            kaiten.constants.diagnostics_settings)
        self._idle_12v_current = 0
        self._idle_5v_current = 0
        self._motor_maxes = diagnostics_settings['motor_current_max']
        self._motor_mins = diagnostics_settings['motor_current_min']
        self._heater_min = diagnostics_settings['heater_current_min']
        self._heater_max = diagnostics_settings['heater_current_max']
        self._12v_standby_current_limit = diagnostics_settings['12v_standby_current_limit']
        self._5v_standby_current_limit = diagnostics_settings['5v_standby_current_limit']
        self._diagnostics_settings = diagnostics_settings

    def _validate_current_high_limit(self, measured, high_limit):
        if measured > high_limit:
            self._diag_logger.warning("ERROR: Measured current draw above limit. Measured: " +
                str(measured) + ". Limit: " + str(int(high_limit)) + "mA")
            return False
        return True

    def _validate_current_low_limit(self, measured, low_limit):
        if measured < low_limit:
            self._diag_logger.warning("ERROR: Measured current draw below limit. Measured: " +
                str(measured) + "mA. Limit: " + str(int(low_limit)) + "mA")
            return False
        return True

    def _check_motor_current(self, axis):
        self._passed_motors[axis] = True
        # turn on motor
        yield from self._pymach.motor_enable(axis, True)
        yield from kaiten.util.sleep(2)
        # measure current

        yield from self._pymach.sample_power('12v', 'Current', 10)
        (single_12_current, self._motor_currents[axis], std_12_current)\
            = self._pymach.get_power_value('12v', 'Current')
        logstring = "axis {0} 12v current: {1} mA avg, stdev {2}"\
            .format(axis, self._motor_currents[axis], std_12_current)

        if not self._validate_current_high_limit(self._motor_currents[axis],\
                                                 self._motor_maxes[axis]):
            self._passed_motors[axis] = False
            logstring += ": FAILS HIGH LIMIT"

        if not self._validate_current_low_limit(self._motor_currents[axis],\
                                                self._motor_mins[axis]):
            self._passed_motors[axis] = False
            logstring += ": FAILS LOW LIMIT"

        self._diag_logger.info(logstring)
        # disable motor
        yield from self._pymach.abort()

    def _setup_logging(self):
        diag_dir = os.path.dirname(kaiten.constants.diagnostics_log)
        if not os.path.exists(diag_dir):
            os.mkdir(diag_dir)
        self._diag_logger = logging.getLogger('diag_log')
        self._diag_logger.setLevel(logging.DEBUG)
        self._diag_fh = logging.FileHandler(kaiten.constants.diagnostics_log)
        self._diag_fh.setLevel(logging.DEBUG)
        self._diag_formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        self._diag_fh.setFormatter(self._diag_formatter)
        self._diag_logger.addHandler(self._diag_fh)
        self._diag_logger.info("Diagnostics begun.")

    def _run_motor_diagnostics(self):
        self._diag_logger.info("Executing idle current test")
        self._diag_logger.debug("Disabling all motors")
        # turn off all motors
        yield from self._pymach.abort()

        yield from self._pymach.sample_power('12v', 'Voltage', 10)
        (single_12_v, self._idle_12v_voltage, stdev_12_v)\
            = self._pymach.get_power_value('12v', 'Voltage')

        yield from self._pymach.sample_power('5v', 'Voltage', 10)
        (single_12_v, self._idle_5v_voltage, stdev_5_v)\
            = self._pymach.get_power_value('5v', 'Voltage')

        self._diag_logger.info("Idle 12v voltage: {0}V, stdev {1}V; Idle 5v voltage {2}V, stdev {3}V"\
                               .format(self._idle_12v_voltage, stdev_12_v,
                                       self._idle_5v_voltage, stdev_5_v))


        self._log.info("Rail voltage check: 12V: {0}, 5V: {1}"\
                       .format(self._idle_12v_voltage, self._idle_5v_voltage))
        yield from kaiten.util.sleep(2)

        yield from self._pymach.sample_power('12v', 'Current', 10)
        (single_12v, self._idle_12v_current, stdev_12_current)\
            = self._pymach.get_power_value('12v', 'Current')

        yield from self._pymach.sample_power('5v', 'Current', 10)
        (single_5V, self._idle_5v_current, stdev_5_current)\
            = self._pymach.get_power_value('5v', 'Current')
        self._diag_logger.info("Idle 12v current: {0}mA, stdev {1}; Idle 5v current {2}mA, stdev {3}mA"\
                               .format(self._idle_12v_current, stdev_12_current,
                                       self._idle_5v_current, stdev_5_current))

        # validate idle current
        self._diag_logger.debug("Validating current measurements")
        self._passed_idle_12v = self._validate_current_high_limit(
            self._idle_12v_current, self._12v_standby_current_limit)

        self._passed_idle_5v = self._validate_current_high_limit(
            self._idle_5v_current, self._5v_standby_current_limit)

        # loop through all Broooklyn motors
        for axis in range(0, 3):

            self._diag_logger.info("Checking axis: " + str(axis))
            yield from self._check_motor_current(axis)
            self._diag_logger.info("Axis: " + str(axis) + " diagnostics finished")

        self._diag_logger.info("Motor diagnostics complete")

    def get_info_dict(self):
        info = {'idle_current_12V' : self._passed_idle_12v,
                'idle_current_5V' : self._passed_idle_5v,
                'motors' : [self._passed_motors[0], self._passed_motors[1], self._passed_motors[2]] ,
                'tool' : self._tool_passed,
                'tool_extended_results' : self._tool_extended_results,
                'camera' : self._passed_camera,
                'details' : {
                    'idle_12v_current' : self._idle_12v_current,
                    'idle_5v_current' : self._idle_5v_current,
                    'idle_5v_voltage' : self._idle_5v_voltage,
                    'idle_12v_voltage' : self._idle_12v_voltage,
                    'motor_l_current' : self._motor_currents[0],
                    'motor_r_current' : self._motor_currents[1],
                    'motor_z_current' : self._motor_currents[2]
                }
        }
        if self._diagnostics_settings.get('z_endstop', False):
            info['endstop_ok'] = self._endstop_ok
        for loc in self._locations:
            info['th_{0}_extended'.format(loc)] = self._tool_extended_results[loc]

        info.update(super(DiagnosticProcess, self).get_info_dict())
        return info

    def _do_cleanup(self):
        self._diag_logger.removeHandler(self._diag_fh)
        yield from self._pymach.power_monitor_close()
        yield kaiten.error.ok

    def _do_initialize(self):
        yield from self._pymach.power_monitor_init()

    def _format_toolhead_diagnostics(self, location):
        result_list\
            = self._pymach.get_extended_toolhead_self_check_results(location)
        result_str = ''.join([b.decode('UTF-8')
                              for b in result_list[0]
                              if b != b'\000'])
        result_dict = json.loads(result_str)
        return result_dict

    def _run_tool_diagnostics(self):
        th = self._config['toolheads']
        self._tool_passed = True
        for key in filter(lambda t: t in ['bronx','chamber'],
                          self._tests):
            for loc in th[key.lower()]['locations']:
                self._log.info("Starting {0} diagnostics at location {1}".format(key,
                                                                                 loc))

                if not self._pymach.toolhead_ok(loc):
                    th_passed = False
                    self._tool_extended_results[loc]\
                        = self._format_toolhead_diagnostics(loc)
                    def set_th_dced(in_dict):
                        for key in in_dict.keys():
                            if isinstance(in_dict[key], dict):
                                set_th_dced(in_dict[key])
                            else:
                                in_dict[key] = 'toolhead_disconnected'
                    set_th_dced(self._tool_extended_results[loc])
                    continue

                self._pymach.set_toolhead_idle_update_period(loc, 10)
                yield from self._pymach.perform_toolhead_self_check(loc)
                yield from kaiten.util.sleep(2)
                logpath = os.path.join(kaiten.constants.home_dir,
                                       'logs/printer/th{0}_results.log'.format(loc))
                th_passed = self._pymach.get_toolhead_self_check_results(loc,\
                                                                         bytes(logpath, 'UTF-8'))
                self._pymach.set_toolhead_idle_update_period(loc, 0.5)
                result = self._format_toolhead_diagnostics(loc)
                self._tool_extended_results.update({loc: result})

                if key == 'chamber':
                    yield from self._pymach.toggle_fan(loc, True)
                    yield from self._pymach.set_fan_duty(loc, 1.0)
                    yield from kaiten.util.sleep(5)
                    toolheads = self._machine_manager.toolhead_status
                    chambers = [s for s in toolheads.values() if s['type'] == 'chamber']
                    speed = chambers[0]['fan_speed_hz'] if chambers else 0
                    self._log.info("Got speed %s from dict %s", speed, toolheads)
                    if speed == 0:
                        self._tool_extended_results[loc]['Results']['Fan']\
                            = kaiten.error.chamber_fan_failure
                    else:
                        self._tool_extended_results[loc]['Results']['Fan']\
                            = kaiten.error.none
                    yield from self._pymach.set_fan_duty(loc, 0.0)
                    yield from self._pymach.toggle_fan(loc, False)


                self._tool_passed = self._tool_passed and bool(th_passed)

                self._pymach.set_toolhead_idle_update_period(loc, 0.5)

    def _do_run(self):

        # Check camera initialization
        if 'camera' in self._tests:
            self._camera_check()

        if 'brooklyn' in self._tests:
            self._log.info("Starting Brooklyn diagnostics")
            yield from self._run_motor_diagnostics()
        yield from self._run_tool_diagnostics()
        if self._diagnostics_settings['z_endstop']:
             yield from self._do_z_endstop_diagnostic()
        # Notify the LCD to start its diagnostics
        if 'lcd' in self._tests:
            if not self._config["single_button_interface"]:
                yield from self._lcd_hoboken_diagnostics()
        if 'button' in self._tests:
            yield from self._queens_diagnostics()

    def _do_z_endstop_diagnostic(self):
        self._log.info("Running Z-endstop diagnostic")
        state = self._pymach.endstop_triggered(2)
        if not state:
            self._endstop_ok = True
            self._log.info("Endstop OK")
            yield
        else:
            self._log.info("Endstop depressed or not connected, moving z-stage...")
            yield from self._ensure_move_axis(2, 5, 5, relative=True)
            yield from self._pymach.shutdown()
            state = self._pymach.endstop_triggered(2)
            if not state:
                self._log.info("Endstop OK")
                self._endstop_ok = True
            else:
                self._log.warning("Endstop is bad!")

    def _lcd_hoboken_diagnostics(self):
        """
        Sends the request to start the LCD hoboken diagnostics.
        """
        self._log.info("Sending request to LCD to start hoboken diagnostics.")
        method = "start_diagnostics"
        params = {}
        yield from self._client_request('lcd', method, params)

    def _queens_diagnostics(self):
        """
        Runs the Queens diagnostics. Prompts the user, via a green button LED,
        to press the button.
        """
        with self._machine_manager.light_context("idle"):
            self._diag_logger.info("Queens diagnostics start")
            with self._machine_manager.light_context("acknowledge"):
                yield from self._lcd_request_user_input('diagnostic_acknowledge')
            self._diag_logger.info("Button pressed, user acknowledged")
            self._diag_logger.info("Queens diagnostics complete")

    def _camera_check(self):
        # Check to see if camera has been initialized by determining if /dev/video is a path that exists.
        self._passed_camera = False
        self._diag_logger.info("Camera diagnostics start")
        if not os.path.exists('/dev/video0'):
            self._diag_logger.warning("ERROR: Camera not initialized.")
        else:
            self._diag_logger.info("Camera initialized.")
            self._passed_camera = True
        self._diag_logger.info("Camera diagnostics complete")
