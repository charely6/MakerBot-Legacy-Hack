import dbm
import json
import logging
import os
import re

import kaiten.constants
import kaiten.log
import kaiten.util
import kaiten.usb

from kaiten.processes.process import Process

class FirmwareCleanupProcess(Process):
    def __init__(self, machine_manager, pymach, config):
        super(FirmwareCleanupProcess, self).__init__(machine_manager, pymach, config)
        self._log = kaiten.log.getlogger(self)
        self._server = self._machine_manager._server
        self._hex_path = kaiten.constants.bronx_firmware
        self.ignore_all_toolhead_errors()
        self._cancellable = False

    def _do_initialize(self):
        self._get_last_firmware_version()
        yield

    def _get_last_firmware_version(self):
        with open(kaiten.constants.first_firmware_boot) as f:
            fw_str = f.read().strip()
        if fw_str:
            self._last_fw_version = kaiten.util.Version.from_str(fw_str)
        else:
            # Upgrading from a firmware version where we weren't tracking
            # Choose a version that is < any valid version
            self._last_fw_version = kaiten.util.Version(0, 0, 0)

    def _verify_software(self):
        self._log.info("Verifying software")
        yield

    def _program_toolheads(self):
        self._log.info("Programming toolheads")
        for th, th_config in self._config['toolheads'].items():
            path = th_config['program']
            if os.path.exists(path):
                for loc in th_config['locations']:
                    self._log.info("Programming {0} at {1} from {2}".format(
                        th,
                        loc,
                        path
                    ))
                    upload_process = self._machine_manager.get_bronx_upload_process(
                        path,
                        loc
                    )
                    yield from upload_process.tasklets
            else:
                self._log.info("Firmware file %s not found", th_config['program'])

    def _update_example_files(self):
        backup_path = kaiten.constants.example_print_dir
        target_path = kaiten.constants.example_print_dest_dir
        if os.path.exists(target_path):
            yield from kaiten.util.remove_dir(target_path)
        if os.path.exists(backup_path):
            yield from kaiten.util.iterative_copytree(backup_path, target_path)
        else:
            yield

    def _unpack_fcgi_dbval(self, packed):
        return dict([pair.split('=') for pair in packed.decode().split('&')])

    def _update_auth(self):
        """ Copy over the contents of our old auth databases """
        # The database formerly used by the fcgi server
        fcgi_db_path = kaiten.constants.fcgi_token_db_path
        try:
            fcgi_db = dbm.open(fcgi_db_path)
        except dbm.error:
            pass
        else:
            fail_count = 0
            for local_code_bytes, packed in fcgi_db.items():
                yield
                try:
                    local_code = local_code_bytes.decode()
                    values = self._unpack_fcgi_dbval(packed)
                    username = values.get('username')
                    local_secret = values.get('client_secret')
                    makerbot_token = values.get('thingiverse_token')
                    if not username or not local_secret: continue
                    account = self._server.auth_store.make_account(username)
                    account.add_local_auth(local_secret, local_code)
                    if makerbot_token:
                        account.makerbot_tokens = makerbot_token
                    self._log.info('migrated user: %s from fcgi_db', username)
                except Exception as e:
                    self._log.info("Failed to migrate %s due to : %s", username, str(e))
                    fail_count += 1
            if fail_count > 0:
                self._log.error('Failed to migrate %d of %d fcgi codes',
                                fail_count, len(fcgi_db))
            fcgi_db.close()
            yield from kaiten.util.remove_prefix(fcgi_db_path)

        # The kaiten database formerly used for only mb tokens
        tv_db_path = kaiten.constants.thingiverse_token_db_path
        try:
            tv_db = dbm.open(tv_db_path)
        except dbm.error:
            pass
        else:
            fail_count = 0
            for makerbot_token_bytes, username_bytes in tv_db.items():
                yield
                if not username_bytes: continue
                try:
                    username = username_bytes.decode()
                    makerbot_token = makerbot_token_bytes.decode()
                    account = self._server.auth_store.make_account(username)
                    if makerbot_token:
                        account.makerbot_tokens = makerbot_token
                    self._log.info('migrated user: %s from tv_db', username)
                except Exception as e:
                    self._log.info("Failed to migrate %s due to : %s", username, str(e))
                    fail_count += 1
            if fail_count > 0:
                self._log.error('Failed to migrate %d of %d tv tokens',
                                fail_count, len(tv_db))
            tv_db.close()
            yield from kaiten.util.remove_prefix(tv_db_path)

    @staticmethod
    def _decamel_str(s):
        # Find every capital letter that is preceeded by a non '_'
        # character, prefix each with '_', then convert to lowercase.
        return re.sub('(?<=[^_])([A-Z])', r'_\1', s).lower()

    def _decamel_dict(self, d):
        for key, val in list(d.items()):
            del d[key]
            d[self._decamel_str(key)] = val
            if isinstance(val, dict):
                self._decamel_dict(val)

    def _decamel_configs(self, *paths):
        for path in paths:
            config = kaiten.util.read_json_file(path, ignore_error=True)
            if not config or not isinstance(config, dict): continue
            self._log.info('DeCamelCasing %s', path)
            self._decamel_dict(config)
            kaiten.util.write_json_file(path, config)

    def _remove_old_core_dumps(self):
        logs_path = '/home/logs'
        for file in os.listdir(logs_path):
            if file.endswith('.core'):
                os.remove(os.path.join(logs_path, file))
                yield

    def _do_run(self):
        yield from kaiten.util.simple_parallel(
            self._program_toolheads(),
            self._update_example_files(),
            self._update_auth(),
        )

        # We shipped a firmware with bad calibration settings that got
        # written permanently onto bots that shouldn't have any such
        # settings.  So we delete the key if we are upgrading from
        # an old enough firmware that this is an issue.
        if (not self._config["kaiten"]["keep_calibration_settings"] and
          self._last_fw_version < kaiten.constants.bad_calibration_version):
            cal_path = kaiten.constants.calibration_settings
            if os.path.isfile(cal_path):
                os.remove(cal_path)
                self._server.reload_config()
                yield

        # We removed camel casing from our printer configuration prior to
        # exposing part of it through our API.  We _have_ to correctly
        # convert our calibration values, and we put in our best effort
        # to convert any custom printer settings that internal users may
        # have set.  Custom printer settings may require a reboot to take
        # effect though...
        if self._last_fw_version < kaiten.constants.decamel_version:
            kaiten.util.fix_kaiten_home_config(self._config)
            self._decamel_configs(
                kaiten.constants.calibration_settings,
                kaiten.constants.config_home_path,
            )
            self._server.reload_config()
            yield

        yield from self._remove_old_core_dumps()
        yield from self._verify_software()

    def _do_cleanup(self):
        try:
            os.unlink(kaiten.constants.first_firmware_boot)
        except Exception as e:
            self._log.info("Could not unlink file %s", kaiten.constants.first_firmware_boot)
        yield
