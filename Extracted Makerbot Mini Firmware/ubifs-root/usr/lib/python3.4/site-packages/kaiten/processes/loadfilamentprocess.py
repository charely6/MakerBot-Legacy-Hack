import sys
import logging
import datetime

import kaiten.activities
import kaiten.error

from kaiten.processes.process import Process
from kaiten.processes.printprocess import PrintProcess

class LoadFilamentProcess(Process):
    """
    Generic process for Filament extrusion.

    @param machine_manager: The machine_manager object.  This process calls
        notify on that object to notify conneted clients of events.
    @param pymach: The pymachine object
    @param id: The id of this process
    @param tool_index: Index of tool to load
    @param temperature: Temperature to heat to
    """
    def __init__(self, machine_manager:object, pymach:object,
                 tool_index:int, config:dict,
                 temperature_settings:list=None):
        super(LoadFilamentProcess, self).__init__(machine_manager, pymach, config)
        self._config = config
        if not isinstance(temperature_settings, list):
            temperature_settings = [0]*self._config['toolhead_count']
            for th in self._config['toolheads'].values():
                for loc in th['locations']:
                    if int(loc) == int(tool_index):
                        temperature_settings[loc] \
                            = th['heater']['print_temperature_default']
                    else:
                        temperature_settings[loc] = 0
        # We only want to heat the extruder that is heating up, so set all others
        # to 0
        for i in range(len(temperature_settings)):
            if i != tool_index:
                temperature_settings[i] = 0
        self._temperature_settings = temperature_settings;
        self._tool_index = tool_index
        self.ignorable_toolhead_errors.update({
            kaiten.error.door_interlock_triggered,
            kaiten.error.no_filament,
            kaiten.error.filament_slip,
        })
        self.cancellable_toolhead_errors.discard(kaiten.error.door_interlock_triggered)
        self._set_requires_heating(True)
        self._iterating_process_generator = True
        self._load_filament_steps = kaiten.enum.enum("load_filament_steps",
                                                     "preheating",
                                                     "extrusion",
                                                     "stopping",
                                                     "unloading_filament")

    def _set_progress(self):
        """
        Unlike printing, we can just get the machine's percent, since we're
        only going to have one setpoint
        """
        self._progress = self._pymach.get_heater_progress_percent()

    def _do_filament_activity(self):
        self._log_event("Load Filament", "load_filament")
        self._step_change(self._load_filament_steps.extrusion)
        yield from self._create_and_run_activity(
            kaiten.activities.LoadFilamentActivity,
            tool_index=self._tool_index)

    def _auto_unload_filament(self, error_dict=None):
        self.ignorable_toolhead_errors.add(kaiten.error.no_filament)
        if error_dict is not None:
            yield from self._pymach.motor_abort(True)
        self._step_change(self._load_filament_steps.unloading_filament)
        yield from self._create_and_run_activity(
            kaiten.activities.UnloadFilamentActivity,
            tool_index=self._tool_index,
            as_autounload=True)
        if not self._iterating_process_generator:
            self._restore_process_generator()
        if error_dict is not None:
            self.cancel()
        self.ignorable_toolhead_errors.discard(kaiten.error.no_filament)
        #Need this yield so that loaded tasklets get run properly
        yield kaiten.error.ok

    def _do_run(self):
        with self._machine_manager.light_context('print'):
            yield from self._ensure_tool_attached()
            self._step_change(self._load_filament_steps.preheating)
            yield from self._heat_to_temperature(self._temperature_settings, wait=False)
            self._machine_manager._server.play_buzzer("start_print")
            #TODO: timeout shouldn't be hardcoded everywhere
            timeout = self._get_heater_timeout(map(lambda t: t!=0, self._temperature_settings))
            wait_map = [False]*self._config['toolhead_count']
            wait_map[self._tool_index] = True
            yield
            for response in self._pymach.wait_for_heaters_at_least_target(timeout,
                                                                          wait_map):
                self._set_progress()
                yield response
            yield from self._do_filament_activity()

    @kaiten.decorator.process_method(["extrusion"])
    def stop_filament(self, error_dict=None):
        self._step_change(self._load_filament_steps.stopping)
        self._set_tasklets(self._do_stop_filament())

    def _do_stop_filament(self):
        if self._current_activity:
            yield from self._current_activity.cancel()
            yield from self._current_activity.cleanup_generator
            self._current_activity = None
        yield from self._do_filament_cleanup()
        yield from self._pymach.motor_abort(False)
        self._step_change(self.steps.done)
        self.complete = True

    def _do_filament_cleanup(self):
        self.overrides_heater_watchdog = False
        self._cancellable = True
        yield

    def _suspended_generator(self):
        """
        Superclass Implementation
        This is the suspended generator.  It yields OK forever.
        """
        with self._machine_manager.light_context("ready"):
            while True:
                yield kaiten.error.ok

    def get_info_dict(self):
        info = super(LoadFilamentProcess, self).get_info_dict()
        info.update({
            "temperature_settings": self._temperature_settings,
            "tool_index": self._tool_index
        })
        return info

    def contract_duration(self):
        """
        Superclass Implementation
        """
        return datetime.timedelta(0, 0, 0, 5)

    def handle_error(self, error_dict):
        # BW-2538 - If loading a short piece of filament stop motor immediately
        # and unload filament to prevent it from going past the drive gear
        if (error_dict['code'] == kaiten.error.no_filament):
            self._set_tasklets(self._auto_unload_filament(error_dict))
        return False

    def _do_cleanup(self):
        # this isn't part of the activity because we don't
        # want to do this during a print
        if self._pymach.is_tool_connected(0):
            (saturated, value) = yield from self._pymach.get_raw_hes_value(0)
            self._log.info("Current tool seated raw HES is {0}, saturated={1}"\
                           .format(value, saturated))
            self._machine_manager._server.mixpanel_event('raw_hes', value=str(value))
        yield from self._pymach.motor_abort(True)

    def _set_tasklets(self, generator):
        # This is a safe way to set self.tasklets
        # It ensures that if we are running the primary genetator of this process
        # then it gets cached.
        if self._iterating_process_generator:
            self._cached_generator = self.tasklets
        self._iterating_process_generator = False
        self.tasklets = generator

    def _restore_process_generator(self):
        self.tasklets = self._cached_generator
        self._iterating_process_generator = True
