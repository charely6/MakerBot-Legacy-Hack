# Note that for anything we import here that is not imported by kaiten,
# we will later have to pick apart which dependencies are and are not
# used by kaiten...
import importlib.util
import sys
import os
import marshal

# The approach of this script is to add an import hook so that every module
# we import gets a copy of its code object stored in this dict.
mods = {}

def code_patch(code, new_bytecode):
    """ Wow python really does not like you to mess with bytecode """
    m_code = marshal.dumps(code)
    m_old_bc = marshal.dumps(code.co_code)
    m_new_bc = marshal.dumps(new_bytecode)
    return marshal.loads(m_code.replace(m_old_bc, m_new_bc, 1))

def strip_import(code, mod):
    """
    Remove any direct top level imports of mod from the given code.  Maybe.
    """
    NOP = b'\x09'
    LOAD_CONST = b'\x64'
    IMPORT_NAME = b'\x6c'
    STORE_NAME = b'\x5a'

    if mod not in code.co_names:
        # Can't do anything here if it gets imported without a name
        return
    name_idx = code.co_names.index(mod)
    zero_idx = code.co_consts.index(0)
    none_idx = code.co_consts.index(None)
    def index_for_op(idx):
        return bytes([idx%256, idx//256])

    # The compiler seems to be pretty consitent about this
    import_code = (
        LOAD_CONST + index_for_op(zero_idx) +
        LOAD_CONST + index_for_op(none_idx) +
        IMPORT_NAME + index_for_op(name_idx) +
        STORE_NAME + index_for_op(name_idx)
    )

    # Assign None to the module name instead
    new_code = (
        LOAD_CONST + index_for_op(none_idx) +
        STORE_NAME + index_for_op(name_idx) +
        NOP * 6
    )

    # We are going to assume that this pattern does not ever show up
    # unaligned in other bytecode.  Aside from general improbability,
    # zero_idx appears to always be 0, and 0 is not a valid opcode.
    bytecode = code.co_code.replace(import_code, new_code)
    return code_patch(code, bytecode)

def fix_path(path):
    """
    Running this script on the bot works great, but when we run this
    from the build system, all of our module paths have an extra prefix
    in front of them.  So we have the build system pass in the extra
    prefix to get rid of it.
    """
    if len(sys.argv) > 2 and path.startswith(sys.argv[2]):
        return os.path.join('/', path[len(sys.argv[2]):])
    else:
        return path

class Loader():
    def __init__(self, path, fullname):
        self._fullname = fullname
        self._path = path

    def exec_module(self, module):
        module.__path__ = module.__file__ = self._path
        module.__package__ = self._fullname
        code = self.get_code()
        # We don't want to import importlib or imp.  zipfile does, but
        # only for use in PyZipFile, which we don't use
        if self._fullname == 'zipfile':
            code = strip_import(code, 'importlib.util')
        mods[self._fullname] = (fix_path(self._path), code)
        try:
            exec(code, module.__dict__)
        except Exception:
            # dbus subclasses modules imported from python extensions we
            # cannot load during cross compile, so we ignore errors
            # raised during import and hope we still import everything.
            if not self._fullname.startswith('dbus.'): raise

    def get_code(self, fullname=None):
        src = self.get_source()
        return compile(src, fix_path(self._path), 'exec', optimize=2)

    def get_data(self, path):
        pass

    def get_filename(self, fullname):
        return self._path

    def get_source(self, fullname=None):
        with open(self._path, 'rb') as f:
            return f.read()

class Finder():
    @staticmethod
    def find_module(fullname, path=None):
        """ Approximate reimplementation of the standard module finder. """
        names = fullname.split('.')
        for base in sys.path:
            mod_base = os.path.join(base, *names)
            for suffix in ('.py', '/__init__.py'):
                py_path = mod_base + suffix
                if os.path.exists(py_path):
                    print('Importing: '+fullname)
                    return Loader(py_path, fullname)

sys.meta_path.insert(0, Finder)

# Hack for cross compiling so that we can "import" .so files not found
# in the standard library.  Includes some specific unicodedata hacks
# because build-root's host python doesn't have this
class Yes():
    def __getattr__(self, attr):
        return self
    def __eq__(self, other):
        return True
class FakeLoader(Loader):
    def exec_module(self, module):
        module = Yes()
        sys.modules[self._fullname] = module
        module.__name__ = self._fullname
        module.__package__ = False
        module.__loader__ = self.__class__
        module.__path__ = module.__file__ = self._path
        return module
class FakeFinder():
    @staticmethod
    def find_module(fullname, path=None):
        if fullname in ['unicodedata']:
            return FakeLoader('<empty>', fullname)
        names = fullname.split('.')
        for base in sys.path:
            if not base.rstrip('/').endswith('site-packages'): continue
            so_path = os.path.join(base, *names) + '.so'
            if os.path.exists(so_path):
                print('Faking .so import: '+fullname)
                return FakeLoader(so_path, fullname)
sys.meta_path.insert(1, FakeFinder)


# Everything we import from here will also be stored in mods,
# but we also want modules that have already been imported
for fullname, mod in sys.modules.items():
    if not hasattr(mod, '__file__'): continue
    if not mod.__file__.endswith('.py'): continue
    # importlib doesn't really work with this, and we only use it
    # for the code in this file, not kaiten
    if fullname.startswith('importlib'): continue
    # Not sure why these have a __file__ attribute
    if fullname in ('_frozen_importlib', '__main__'): continue

    print('Reimporting: '+fullname)
    loader = Loader(mod.__file__, fullname)
    mods[fullname] = (mod.__file__, loader.get_code())
    loader = None

def write_mods(filepath):
    with open(filepath, 'wb') as f:
        marshal.dump(mods, f)

# Import our main entry point, which _should_ get every
# module needed to run kaiten
import kaiten.main

# ... except for these JIT imports
import subprocess
import encodings.idna
import encodings.cp437
import dbm.dumb

write_mods(sys.argv[1])
