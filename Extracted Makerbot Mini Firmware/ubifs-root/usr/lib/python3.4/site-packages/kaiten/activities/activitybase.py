""" Superclass for Activities and Processes

Contains low level functions shared by multiple
acitivies and processes.
"""
import kaiten.error
import kaiten.log
import kaiten.util
import math
import datetime

class ActivityBase():

    def __init__(self, machine_manager, pymach, config):
        self._machine_manager = machine_manager
        self._pymach = pymach
        self._config = config
        self._log = kaiten.log.getlogger(self)
        self._event_log = kaiten.log.getlogger(self, base_logger_name='user_event')

    def _create_event_log_message(self, msg, event_type, error_dict=None):
        """Create a event log string for use with the _event_log.
        @param msg String: Main log message
        @param event_type String: type of event that caused the log action
        @param error_dict dict: dict containing error info, Optional
        @return String: Formatted event log message string
        """
        log_string = "{0}".format(msg)

        if error_dict is not None:
            code = error_dict["code"]
            err_string = kaiten.error.error_to_string.get(code, "")
            log_string =\
                log_string.rstrip() +\
                "\nError: {0}, {1}".format(code, err_string)

        return log_string

    def _log_event(self, msg, event_type, error_dict=None):
        """Log event to the event log.
        @param msg String: Main log message
        @param event_type String: type of event that caused the log action
        @param error_dict dict: dict containing error info, Optional
        """
        self._event_log.info(
            self._create_event_log_message(msg, event_type, error_dict))

    def _get_heater_timeout(self, heater_active:list):
        """Get the appropriate timeout for the specified list of active heaters.
           The timeout will be the longest timeout of the active heaters.
        @param heater_active List (bool) of heaters, True for active, False for not.
        """
        timeout_list = [None] * self._config['toolhead_count']
        for th in self._config['toolheads'].values():
            for loc in th['locations']:
                timeout_list[loc] = th['heater']['wait_for_target_timeout']
        timeout = max([timeout_list[idx]
                       for idx,active in enumerate(heater_active) if active])
        return timeout

    def _heat_to_temperature(self, temperatures:list,
                             wait=False, wait_check=None,
                             at_least=False):
        """ Heat to a (multi-toolhead) temperature, and optionally wait,
        using the appropriate timeout.

        @param temperatures List (int) List of temperatures, the same length
                                       or smaller as the number of heaters.
        @param wait bool Whether or not to wait for the command to achieve
                         temperature. If true, there will be a timeout loaded
                         from the config.
        @param wait_check List(bool) of heaters to wait for, if you're waiting.
                                      Ignored if not waiting.
        """

        # These are a lot of kinda gross checks, but this call got more fragile
        # when we switched to code generation, and we should provide it with
        # the right values.
        etc = self._config['toolhead_count']
        if None is wait_check:
            wait_check = [False]*etc
        elif len(wait_check) < etc:
            temp = [False]*etc
            for idx, elem in enumerate(wait_check):
                temp[idx] = elem
            wait_check = temp
        elif len(wait_check) > etc:
            wait_check = wait_check[:etc]
        if len(temperatures) > etc:
            temperatures = temperatures[:etc]
        yield from self._pymach.load_temperature_settings(temperatures)
        yield from self._pymach.heat()
        if wait:
            timeout = self._get_heater_timeout(map(lambda v: v!=0, temperatures))
            self._log.info("heating to {0} with timeout {1}".format(temperatures,
                                                                    timeout))
            if at_least:
                yield from self._pymach.wait_for_heaters_at_least_target(timeout,
                                                                         wait_check)
            else:
                yield from self._pymach.wait_for_heaters_at_target(timeout,
                                                                   wait_check)

    def _ensure_move(self, position, speed,
                     relative):
        for error_code in self._pymach.move(position, speed, relative):
            yield error_code
        yield from self._pru_delay_loop()

    def _ensure_move_axis(self, axis, position, speed, relative):
        for error_code in self._pymach.move_axis(axis, position, speed, relative):
            yield error_code
        yield from self._pru_delay_loop()

    def _pru_delay_loop(self):
        """
        We need to make sure the move gets into the PRU buffer before its executed.
        """
        while not self._pymach.move_buffer_empty():
            yield kaiten.error.not_ready

    def _xymove(self, pos, speed=100, relative=[False, False]):
        extra_axes = self._machine_manager.extruder_count() + 1
        yield from self._ensure_move(pos + ([0] * extra_axes), speed,
                                     relative + ([True] * extra_axes))

    def _safe_xypark(self):
        park_prep_position = [self._config['park_prep']['x'],
                              self._config['park_prep']['y']]
        safe_park_position = self._config.get('safe_park', self._config['park'])
        park_position = [safe_park_position['x'], safe_park_position['y']]
        yield from self._xymove(park_prep_position)
        yield from self._xymove(park_position)

    def _xypark(self):
        park_prep_position = [self._config['park_prep']['x'],
                              self._config['park_prep']['y']]
        park_position = [self._config['park']['x'],
                         self._config['park']['y']]
        yield from self._xymove(park_prep_position)
        yield from self._xymove(park_position)

    def _unpark(self):
        park_prep_position = [self._config['park_prep']['x'],
                              self._config['park_prep']['y']]
        yield from self._xymove(park_prep_position)

    def _parked(self):
        """
        Checks if the machine is _parked
        """
        tolerance = 0.1
        position = self._pymach.get_move_buffer_position()
        park = self._config['park']
        self._log.info("Park? Position {0} and park pos {1}".format(position, park))
        return (abs(position[0] - park['x']) < tolerance)\
            and\
            (abs(position[1] - park['y']) < tolerance)


    def _sample_hes(self, duration=None):
        """Take a time-averaged HES reading over @duration seconds.

        @brief This method is an alternative to using the reading in the c++ status
        packet. It will take a set of HES readings at 215 Hz for the commanded duration
        and return the mean and range of that sample set.

        @param duration Time, in seconds, to sample for. Will be clamped to a minimum
        of 4.65e-3 and a maximum of 1.19 seconds, as these are 1 sample and the max
        number of possible samples, respectively. If no duration is provided, the
        default from the machine settings will be used.

        @returns a tuple of (average, jitter): average - mean of the HES log, jitter -
        range of the HES log.

        """
        hes_log_start_value = 0xabcd # put in log to mark the start
        raw_sample = yield from self._get_bronx_log(duration)
        try:
            start_idx = raw_sample.index(hes_log_start_value)
            sample = raw_sample[0:start_idx]
        except ValueError:
            sample = raw_sample

        if not sample:
            self._log.error("Computed empty HES sample, raw sample is {0}".format(raw_sample))
            yield kaiten.error.no_hes_log

        jitter = math.fabs(min(sample) - max(sample))
        mean = sum(sample)/len(sample)
        self._log.debug("HOME: Got avg {0} and jitter {1} culling {2} 0s from sample\n{3}"
                        .format(mean, jitter, len(raw_sample)-len(sample), sample))
        return (mean, jitter)

    def _get_bronx_log(self, duration=None):
        """Take a set of HES samples over duration seconds.

        @brief This gets around the problem of high latency when just looking at the
        status struct returned from the machine. This method will return a set of
        samples taken over @duration seconds, to a maximum of 1.19s, sampled at
        215 Hz.

        @note The log will return a _maximum_ of the samples you asked for. It may
        provide fewer because of latency issues. If it provides fewer, the log
        will be shorter than requested.

        @note Generally used to get an average, since it will not sync up with any
        motion.

        @param duration Time, in seconds, to take a sample for. Will be clamped to
        a minimum of 4.65e-3 and a maximum of 1.19 (1 and 256 samples, respectively.)
        If no duration is specified, the default from the machine settings will be
        used.

        @returns waveform Returns the list of HES values seen over the duration.
        """
        bronx_fs = 215.0 # Bronx sample rate
        if not duration:
            hes_sample_size = self._config["home"]['mag_sense']['sample_size']
        else:
            hes_sample_size = int(bronx_fs * duration)
            if hes_sample_size > 256:
                hes_sample_size = 256
            elif hes_sample_size < 1:
                hes_sample_size = 1

        yield from self._pymach.begin_hes_log(0, hes_sample_size, immediate=True)
        yield from self._sleep(float(hes_sample_size)/bronx_fs)  #fill the log
        yield from self._pymach.end_hes_log(0)
        waveform = yield from self._grab_hes_log(hes_sample_size, 0)
        if not waveform:
            yield kaiten.kaiten.error.no_hes_log
        return waveform

    def _grab_hes_log(self, size, toolhead=0, timeout=20):
        yield
        then = datetime.datetime.utcnow()
        while not self._pymach.hes_log_loaded(toolhead):
            yield
            if (datetime.datetime.utcnow()-then).seconds > timeout:
                self._log.error("Couldn't get HES log!")
                yield kaiten.error.no_hes_log
        val = self._pymach.get_hes_log(toolhead, size)
        return val

    def _sleep(self, seconds):
        yield from kaiten.util.sleep(seconds)

    def _await_eeprom_transaction_finished(self, timeout, uid):
        """Yield until the current UID goes away and then comes back.

        All tool EEPROM update operations cause the bronx to return a 0 UID during
        the process of the operation, and then return the programmed UID afterwards.
        This method is used to wait for that process. The timeout is a total timeout:
        the time for the UID to become 0 plus the time for the UID to become the
        specified UID must be less than the timeout.

        This method is currently used by both YonkersUploadProcess and PrintProcess.
        """
        then = datetime.datetime.utcnow()
        iterations=0
        while (datetime.datetime.utcnow()-then).seconds < timeout:
            if self._pymach.toolhead_blocking(0) == True:
                self._log.info("EEPROM transaction begins after {0} seconds ({1} iterations)"\
                               .format((datetime.datetime.utcnow()-then).seconds,
                                       iterations))
                break
            yield
            iterations+=1
        while (datetime.datetime.utcnow()-then).seconds < timeout:
            if self._pymach.toolhead_blocking(0) == False:
                self._log.info("EEPROM transaction done after {0} seconds ({1} iterations)"\
                               .format((datetime.datetime.utcnow()-then).seconds,
                                       iterations))
                break
            yield
            iterations+=1
        if (datetime.datetime.utcnow()-then).seconds >= timeout:
            self._log.error("Hit timeout awaiting EEPROM transaction finished")
            yield kaiten.error.eeprom_update_failed
        else:
            self._log.info("EEPROM transaction yields ok")
            yield kaiten.error.ok
